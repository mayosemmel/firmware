#!/bin/sh
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.


# IMPORTANT!!
# DO NOT RUN THIS IN CRONJOB!

BOARD="$(uci get board.model.name)"
. /etc/network.$BOARD

#load uci functions
. /lib/functions.sh
. /usr/share/libubox/jshn.sh

#load fff functions
. /lib/functions/fff/wireless
. /lib/functions/fff/network
. /lib/functions/fff/keyxchange



configure() {
    # ensure client config exists
    if ! uci get gateway.@client[0] > /dev/null; then
        echo "ERROR: No client config or error parsing config!"
        exit 1
    fi


    echo "This script might remove existing vlans, interfaces, addresses, etc."
    read -r -p "Do you really want to continue? (y/n) " response
    if ! [ "$response" == "y" ] || [ "$response" == "Y" ]; then
        exit 1
    fi


    ## set hostname

    if uci -q get gateway.@gateway[0].name; then
        uci set system.@system[0].hostname=$(uci get gateway.@gateway[0].name)
    else
        echo "WARNING: No gateway name set!"
    fi


    ## set location

    if uci -q get gateway.@gateway[0].latitude && uci -q get gateway.@gateway[0].longitude; then
        uci -q set fff.system.latitude='$(uci -q get gateway.@gateway[0].latitude)'
        uci -q set fff.system.longitude='$(uci -q get gateway.@gateway[0].longitude)'
    fi


    ## configure vlans

    add_vlan() {
        local vlan="$1"
        local ports=$(uci get gateway.$vlan.ports)
        local name="$SWITCHDEV"_$vlan

        uci set network.$name='switch_vlan'
        uci set network.$name.device="$(uci get network.$SWITCHDEV.name)"
        uci set network.$name.vlan="$vlan"
        uci set network.$name.ports="$CPUPORT $ports"
    }

    remove_vlan() {
        local name="$1"

        local switchdev=$(echo $name | cut -d_ -f1)
        local vlan=$(echo $name | cut -d_ -f2)

        # only remove vlans not present in gateway config
        if ! uci -q get gateway.$vlan > /dev/null; then
            # remove switch_vlan
            uci del network.$name
        fi
    }

    config_load network
    config_foreach remove_vlan switch_vlan

    config_load gateway
    config_foreach add_vlan vlan



    ## configure clientnet

    # ipaddr
    #remove old ipaddr
    uci del network.mesh.ipaddr
    #set new ipaddr
    if uci -q get gateway.@client[0].ipaddr; then
        uci add_list network.mesh.ipaddr=$(uci get gateway.@client[0].ipaddr)
        uci set network.mesh.ip4table='fff'
        uci set network.mesh.ip6table='fff'
    else
        echo "WARNING: No client ipaddr set!"
    fi

    # ip6addr
    #remove old ip6addr
    for ip in $(uci get network.mesh.ip6addr); do
        if ( echo "$ip" | grep -v -e "fdff:" -e "fe80::1/64" ); then
            uci del_list network.mesh.ip6addr="$ip"
        fi
    done
    #set new ip6addr
    if uci -q get gateway.@client[0].ip6addr; then
        uci add_list network.mesh.ip6addr=$(uci get gateway.@client[0].ip6addr)
    else
        echo "WARNING: No client ip6addr set!"
    fi

    # dhcp
    uci del dhcp.mesh.start
    uci del dhcp.mesh.limit
    if uci -q get gateway.@client[0].dhcp_start; then
        uci set dhcp.mesh=dhcp
        uci set dhcp.mesh.interface=mesh
        uci set dhcp.mesh.start=$(uci get gateway.@client[0].dhcp_start)
        uci set dhcp.mesh.limit=$(uci get gateway.@client[0].dhcp_limit)
    else
        echo "WARNING: No DHCP range start and/or limit set!"
    fi

    # set interface
    #remove all eth interfaces
    ifaces=$(uci get network.mesh.ifname | sed -e "s/ *eth\d\.\d//g" -e "s/ *eth\d//g" -e "s/^ //")
    if uci -q get gateway.@client[0].vlan; then
        uci set network.mesh.ifname="${SWITCHDEV}.$(uci get gateway.@client[0].vlan) $ifaces"
    elif uci -q get gateway.@client[0].iface; then
        uci set network.mesh.ifname="$(uci get gateway.@client[0].iface) $ifaces"
    else
        echo "WARNING: No Interface for client specified"
    fi



    ## dns
    uci delete dhcp.@dnsmasq[0].server
    if uci -q get gateway.@dns[0].server; then
        for f in $(uci get gateway.@dns[0].server); do
            uci add_list dhcp.@dnsmasq[0].server=$f
            uci add_list dhcp.@dnsmasq[0].server="/in-addr.arpa/$f"
            uci add_list dhcp.@dnsmasq[0].server="/ip6.arpa/$f"
        done
    else
        echo "WARNING: No DNS servers set!"
    fi



    ## batman
    # set interface
    #remove all eth interfaces
    if uci -q get gateway.@batman[0].vlan; then
        uci set network.ethmesh.ifname="${SWITCHDEV}.$(uci get gateway.@batman[0].vlan)"
    elif uci -q get gateway.@batman[0].iface; then
        uci set network.ethmesh.ifname="$(uci get gateway.@batman[0].iface)"
    else
        echo "WARNING: No Interface for batman specified"
    fi



    ## HOODFILE
    if [ -s "$hoodfilecopy" ]; then
        json_load "$(cat "$hoodfilecopy")"

        # ULA
        json_select network
        json_get_var prefix ula_prefix
        json_select ".."
        # Set $prefix::MAC as IP
        if [ -n "$prefix" ] ; then
            prefix="$(echo "$prefix" | sed -e 's,\\,,')"
            addr="$(ipMacAssemble "$prefix" "br-mesh")"
            addr="$(ipTidyColon "$addr")"
            addr_eui="$(ipEUIAssemble "$prefix" "br-mesh")"
            addr_eui="$(ipTidyColon "$addr_eui")"

            # add new addresses
            if ! ( uci get network.mesh.ip6addr | grep -q "$addr" ) ; then
                uci add_list network.mesh.ip6addr="$addr"
                echo "Set ULA address to br-mesh: $addr"
            else
                echo "Address already set."
            fi
            # Set $prefix::link-local as IP
            if ! ( uci get network.mesh.ip6addr | grep -q "$addr_eui" ) ; then
                uci add_list network.mesh.ip6addr="$addr_eui"
                echo "Set ULA EUI-64 address to br-mesh: $addr_eui"
            else
                echo "Address already set."
            fi
        fi

        # WIFI
        json_select hood
        json_get_var hood name
        json_get_var mesh_id mesh_id
        json_get_var mesh_bssid mesh_bssid
        json_get_var mesh_essid mesh_essid
        json_get_var essid essid
        json_get_var chan2ghz channel2
        json_get_var mesh_type2 mesh_type2
        json_get_var chan5ghz channel5
        json_get_var mesh_type5 mesh_type5
        json_select ".."

        echo "Setting hood name: $hood"
        uci -q set "system.@system[0].hood=$hood"

        if ! wifiDelIface; then
            echo "Can't delete current wifi setup"
            exit 1
        fi

        if ([ -n "$chan2ghz" ] && [ -n "$chan5ghz" ]) ; then
            for phy in $(iw phy | awk '/^Wiphy/{ print $2 }'); do
                radio="$(wifiAddPhyCond "$phy" "2" "$chan2ghz")"
                radio5="$(wifiAddPhyCond "$phy" "5" "$chan5ghz")"
                [ -n "$radio5" ] && radio="$radio5"

                if ! wifiAddAP "$radio" "$essid" "mesh" "ap" "0"; then
                    echo "Can't add AP interface on $radio."
                    exit 1
                fi

                # add config ap
                iface="configap2"
                if [ -n "$radio5" ]; then
                    iface="configap5"
                fi
                uci set network.${iface}=interface
                uci set network.${iface}.proto='static'
                uci set network.${iface}.ip6addr='fe80::1/64'
                if ! wifiAddAP "$radio" "config.franken.freifunk.net" "$iface" "configap" "1"; then
                    echo "Can't add Config interface on $radio."
                    exit 1
                fi

                # add 802.11s mesh if type == "802.11s"
                if ( [ -n "$radio5" ] && [ "$mesh_type5" == "802.11s" ] ) || [ "$mesh_type2" == "802.11s" ]; then
                    if ! wifiAddMesh "$radio" "$mesh_id"; then
                        echo "Can't add Mesh interface on $radio."
                        exit 1
                    fi
                fi

                # add IBSS mesh if type == "ibss"
                if ( [ -n "$radio5" ] && [ "$mesh_type5" == "ibss" ] ) || [ "$mesh_type2" == "ibss" ]; then
                    if ! wifiAddAdHocMesh "$radio" "$mesh_essid" "$mesh_bssid"; then
                        echo "Can't add AdHocMesh interface on $radio."
                        exit 1
                    fi
                fi
            done
        fi
    else
        echo "WARNING: No hoodfile!"
    fi


    ## babelpeer
    # remove peers missing in gateway config
    remove_babelpeer() {
        local name="$1"
        if ! echo $name | grep cfg > /dev/null; then # do not delete default interface
            if ! uci -q get gateway.$name > /dev/null; then
                # remove interface
                uci del network.$name
                # remove iif-rules
                uci del network.${name}_rule
                uci del network.${name}_rule6
                # remove babel interface
                uci del babeld.$name
                # remove wireguard config
                uci -q del network.@wireguard_$name[0]
            fi
        fi
    }

    config_load babeld
    config_foreach remove_babelpeer interface

    #add new peers
    add_babelpeer() {
        local name="$1"
        local vlan
        local type

        # prohibit cfg* as name
        if echo $name | grep cfg > /dev/null; then
            echo "ERROR: name $name is invalid for babelpeer!"
            return
        fi

        # get iface
        if uci -q get gateway.$name.vlan; then
            iface="${SWITCHDEV}.$(uci get gateway.$name.vlan)"
        elif uci -q get gateway.$name.iface; then
            iface="$(uci get gateway.$name.iface)"
        else
            echo "ERROR: No iface set for babelpeer $name!"
            return
        fi

        # get type
        if uci -q get gateway.$name.type; then
            type=$(uci get gateway.$name.type)
        else
            type=wired
        fi

        # add interface
        uci set network.$name=interface
        uci set network.$name.proto=static
        uci set network.$name.ifname=$iface

        # add iif-rules
        uci set network.${name}_rule=rule
        uci set network.${name}_rule.in="$name"
        uci set network.${name}_rule.lookup='10'
        uci set network.${name}_rule.priority='31'

        uci set network.${name}_rule6=rule6
        uci set network.${name}_rule6.in="$name"
        uci set network.${name}_rule6.lookup='10'
        uci set network.${name}_rule6.priority='31'

        # peer_ip
        if uci -q get gateway.@gateway[0].peer_ip; then
            uci set network.$name.ipaddr=$(uci get gateway.@gateway[0].peer_ip)
        elif uci -q get gateway.@client[0].ipaddr; then
            # use ipaddr (without subnet) if no peer_ip set
            uci set network.$name.ipaddr=$(uci get gateway.@client[0].ipaddr | cut -d / -f1)
        else
            echo "FATAL: Neither peer_ip nor ipaddr set! No peering ipv4 set!"
        fi

        # peer_ip6
        if uci -q get gateway.@gateway[0].peer_ip6; then
            uci set network.$name.ip6addr=$(uci get gateway.@gateway[0].peer_ip6)
        fi

        # add babel interface
        uci set babeld.$name=interface
        uci set babeld.$name.ifname=$name
        uci set babeld.$name.type=$type
    }

    config_load gateway
    config_foreach add_babelpeer babelpeer



    ## wireguardpeer
    #add new peers
    add_wgpeer() {
        local name="$1"

        # prohibit cfg* as name
        if echo $name | grep cfg > /dev/null; then
            echo "ERROR: name $name is invalid for wireguardpeer!"
            return
        fi

        # add interface
        uci set network.$name=interface
        uci set network.$name.proto=wireguard
        if uci -q get gateway.$name.private_key > /dev/null; then
            uci set network.$name.private_key="$(uci get gateway.$name.private_key)"
        else
            privkey=$(wg genkey)
            uci set network.$name.private_key="$privkey"
            uci set gateway.$name.private_key="$privkey"
        fi
        echo "WIREGUARD: publickey for ${name}: $(echo $(uci get gateway.$name.private_key) | wg pubkey)"

        # add iif-rules
        uci set network.${name}_rule=rule
        uci set network.${name}_rule.in="$name"
        uci set network.${name}_rule.lookup='10'
        uci set network.${name}_rule.priority='31'

        uci set network.${name}_rule6=rule6
        uci set network.${name}_rule6.in="$name"
        uci set network.${name}_rule6.lookup='10'
        uci set network.${name}_rule6.priority='31'

        # configure wireguard
        if uci -q get network.@wireguard_$name[0] > /dev/null
        then
            #config already exists
            cfg="@wireguard_$name[0]"
        else
            #create new config
            cfg=$(uci add network wireguard_$name)
        fi
        uci set network.$cfg.public_key="$(uci get gateway.$name.public_key)"
        uci set network.$cfg.endpoint_host="$(uci get gateway.$name.endpoint_host)"
        uci set network.$cfg.endpoint_port="$(uci get gateway.$name.endpoint_port)"
        uci set network.$cfg.persistent_keepalive="$(uci get gateway.$name.persistent_keepalive)"
        uci delete network.$cfg.allowed_ips
        uci add_list network.$cfg.allowed_ips='::/0'
        uci add_list network.$cfg.allowed_ips='0.0.0.0/0'

        # remove old addresses
        uci -q del network.$name.addresses

        # link local
        uci add_list network.$name.addresses="$(ipEUIAssemble "fe80::/64" "$SWITCHDEV")"

        # add iif-rules
        uci set network.${name}_rule=rule
        uci set network.${name}_rule.in="$name"
        uci set network.${name}_rule.lookup='10'
        uci set network.${name}_rule.priority='31'

        uci set network.${name}_rule6=rule6
        uci set network.${name}_rule6.in="$name"
        uci set network.${name}_rule6.lookup='10'
        uci set network.${name}_rule6.priority='31'

        # peer_ip
        if uci -q get gateway.@gateway[0].peer_ip; then
            uci add_list network.$name.addresses="$(uci get gateway.@gateway[0].peer_ip)"
        elif uci -q get gateway.@client[0].ipaddr; then
            # use ipaddr (without subnet) if no peer_ip set
            uci add_list network.$name.addresses="$(uci get gateway.@client[0].ipaddr | cut -d / -f1)"
        else
            echo "FATAL: Neither peer_ip nor ipaddr set! No peering ipv4 set!"
        fi

        # peer_ip6
        if uci -q get gateway.@gateway[0].peer_ip6; then
            uci add_list network.$name.addresses=$(uci get gateway.@gateway[0].peer_ip6)
        fi

        # add babel interface
        uci set babeld.$name=interface
        uci set babeld.$name.ifname="$name"
        uci set babeld.$name.type='tunnel'
    }

    config_load gateway
    config_foreach add_wgpeer wireguardpeer

    exit 0
}


apply_changes() {
    uci commit
    echo "$(uci get "system.@system[0].hostname")" > /proc/sys/kernel/hostname
    /etc/init.d/network restart
    /etc/init.d/babeld restart
}


revert_changes() {
    uci revert system
    uci revert network
    uci revert gateway
    uci revert dhcp
    uci revert babeld
    uci revert fff
}


test_changes() {
    /etc/init.d/network restart
    /etc/init.d/babeld restart
    echo "services restarted. waiting up to 200s for SIGINT.."

    sleep 200

    echo "reverting changes.."
    revert_changes
    /etc/init.d/network restart
    /etc/init.d/babeld restart
}


usage() {
    echo Usage: $0 [OPTION];
    echo;
    echo "Options:"
    echo "  -c: configure. No commit, no restart!"
    echo "  -t: test changes. Restarts services, waits up to 200s for SIGINT"
    echo "  -a: apply changes"
    echo "  -r: revert changes"
}


if [ $# != 1 ]; then
    usage; exit 1
fi

case "$1" in
    -c) configure ;;
    -t) test_changes ;;
    -a) apply_changes ;;
    -r) revert_changes ;;
    *) usage; exit 1 ;;
esac
