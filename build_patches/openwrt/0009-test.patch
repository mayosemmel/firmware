unchanged:
--- a/target/linux/ramips/patches-4.14/0024-GPIO-add-named-gpio-exports.patch
+++ b/target/linux/ramips/patches-4.14/0024-GPIO-add-named-gpio-exports.patch
@@ -22,7 +22,7 @@ Signed-off-by: John Crispin <blogic@openwrt.org>
  
  #include "gpiolib.h"
  
-@@ -506,3 +508,69 @@ void of_gpiochip_remove(struct gpio_chip
+@@ -506,3 +508,62 @@ void of_gpiochip_remove(struct gpio_chip
  	gpiochip_remove_pin_ranges(chip);
  	of_node_put(chip->of_node);
  }
@@ -32,7 +32,7 @@ Signed-off-by: John Crispin <blogic@openwrt.org>
 +	{ /* sentinel */ }
 +};
 +
-+static int __init of_gpio_export_probe(struct platform_device *pdev)
++static int of_gpio_export_probe(struct platform_device *pdev)
 +{
 +	struct device_node *np = pdev->dev.of_node;
 +	struct device_node *cnp;
@@ -85,13 +85,10 @@ Signed-off-by: John Crispin <blogic@openwrt.org>
 +		.owner	= THIS_MODULE,
 +		.of_match_table	= of_match_ptr(gpio_export_ids),
 +	},
++	.probe		= of_gpio_export_probe,
 +};
 +
-+static int __init of_gpio_export_init(void)
-+{
-+	return platform_driver_probe(&gpio_export_driver, of_gpio_export_probe);
-+}
-+device_initcall(of_gpio_export_init);
++module_platform_driver(gpio_export_driver);
 --- a/drivers/gpio/gpiolib-sysfs.c
 +++ b/drivers/gpio/gpiolib-sysfs.c
 @@ -553,7 +553,7 @@ static struct class gpio_class = {
unchanged:
--- b/target/linux/ramips/mt7621/config-4.14
+++ b/target/linux/ramips/mt7621/config-4.14
@@ -5,28 +5,40 @@
 # CONFIG_ARCH_HAS_GCOV_PROFILE_ALL is not set
 CONFIG_ARCH_HAS_RESET_CONTROLLER=y
 # CONFIG_ARCH_HAS_SG_CHAIN is not set
+# CONFIG_ARCH_HAS_STRICT_KERNEL_RWX is not set
+# CONFIG_ARCH_HAS_STRICT_MODULE_RWX is not set
+CONFIG_ARCH_HAS_TICK_BROADCAST=y
 CONFIG_ARCH_HIBERNATION_POSSIBLE=y
 CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
 CONFIG_ARCH_MIGHT_HAVE_PC_SERIO=y
+CONFIG_ARCH_MMAP_RND_BITS_MAX=15
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MAX=15
+# CONFIG_ARCH_OPTIONAL_KERNEL_RWX is not set
+# CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT is not set
 CONFIG_ARCH_SUPPORTS_UPROBES=y
 CONFIG_ARCH_SUSPEND_POSSIBLE=y
 CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_ARCH_USE_QUEUED_RWLOCKS=y
+CONFIG_ARCH_USE_QUEUED_SPINLOCKS=y
 CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_AT803X_PHY=y
 CONFIG_BLK_MQ_PCI=y
 CONFIG_BOARD_SCACHE=y
 CONFIG_BOUNCE=y
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
 CONFIG_CEVT_R4K=y
 # CONFIG_CEVT_SYSTICK_QUIRK is not set
 CONFIG_CLKDEV_LOOKUP=y
 CONFIG_CLKSRC_MIPS_GIC=y
-CONFIG_CLKSRC_OF=y
-CONFIG_CLKSRC_PROBE=y
 CONFIG_CLONE_BACKWARDS=y
 CONFIG_CMDLINE="rootfstype=squashfs,jffs2"
 CONFIG_CMDLINE_BOOL=y
 # CONFIG_CMDLINE_OVERRIDE is not set
 CONFIG_COMMON_CLK=y
 # CONFIG_COMMON_CLK_BOSTON is not set
+CONFIG_COMMON_CLK_MT7621=y
+CONFIG_COMMON_CLK_MT7621_ETHSYS=y
 CONFIG_CPU_GENERIC_DUMP_TLB=y
 CONFIG_CPU_HAS_PREFETCH=y
 CONFIG_CPU_HAS_RIXI=y
@@ -46,6 +58,7 @@
 CONFIG_CPU_SUPPORTS_HIGHMEM=y
 CONFIG_CPU_SUPPORTS_MSA=y
 CONFIG_CRC16=y
+CONFIG_CRYPTO_ACOMP2=y
 CONFIG_CRYPTO_AEAD=y
 CONFIG_CRYPTO_AEAD2=y
 CONFIG_CRYPTO_DEFLATE=y
@@ -65,9 +78,12 @@
 CONFIG_FIXED_PHY=y
 CONFIG_GENERIC_ATOMIC64=y
 CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
 CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_GENERIC_CPU_AUTOPROBE=y
 CONFIG_GENERIC_IO=y
 CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK=y
 CONFIG_GENERIC_IRQ_IPI=y
 CONFIG_GENERIC_IRQ_SHOW=y
 CONFIG_GENERIC_PCI_IOMAP=y
@@ -75,9 +91,13 @@
 CONFIG_GENERIC_SMP_IDLE_THREAD=y
 CONFIG_GENERIC_TIME_VSYSCALL=y
 CONFIG_GPIOLIB=y
+CONFIG_GPIOLIB_IRQCHIP=y
 CONFIG_GPIO_MT7621=y
+CONFIG_GPIO_PCA953X=y
+CONFIG_GPIO_PCA953X_IRQ=y
 # CONFIG_GPIO_RALINK is not set
 CONFIG_GPIO_SYSFS=y
+# CONFIG_GRO_CELLS is not set
 CONFIG_HANDLE_DOMAIN_IRQ=y
 CONFIG_HARDWARE_WATCHPOINTS=y
 CONFIG_HAS_DMA=y
@@ -95,6 +115,7 @@
 CONFIG_HAVE_CLK=y
 CONFIG_HAVE_CLK_PREPARE=y
 CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_COPY_THREAD_TLS=y
 CONFIG_HAVE_C_RECORDMCOUNT=y
 CONFIG_HAVE_DEBUG_KMEMLEAK=y
 CONFIG_HAVE_DEBUG_STACKOVERFLOW=y
@@ -118,12 +139,12 @@
 CONFIG_HAVE_PERF_EVENTS=y
 CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
 CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
-CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
 CONFIG_HIGHMEM=y
 CONFIG_HW_HAS_PCI=y
 CONFIG_HZ_PERIODIC=y
 CONFIG_I2C=y
 CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
 CONFIG_I2C_MT7621=y
 CONFIG_INITRAMFS_SOURCE=""
 CONFIG_IRQCHIP=y
@@ -132,10 +153,14 @@
 CONFIG_IRQ_FORCED_THREADING=y
 CONFIG_IRQ_MIPS_CPU=y
 CONFIG_IRQ_WORK=y
+# CONFIG_ISDN is not set
 CONFIG_LIBFDT=y
 CONFIG_LZO_COMPRESS=y
 CONFIG_LZO_DECOMPRESS=y
-CONFIG_MDIO_BOARDINFO=y
+CONFIG_MDIO_BUS=y
+CONFIG_MDIO_DEVICE=y
+CONFIG_MDIO_I2C=y
+CONFIG_MFD_SYSCON=y
 CONFIG_MIPS=y
 CONFIG_MIPS_ASID_BITS=8
 CONFIG_MIPS_ASID_SHIFT=0
@@ -185,13 +210,68 @@
 CONFIG_MTD_UBI_WL_THRESHOLD=4096
 CONFIG_MTK_MTD_NAND=y
 CONFIG_NEED_DMA_MAP_STATE=y
+# CONFIG_NET_CADENCE is not set
+CONFIG_NET_DSA=y
+CONFIG_NET_DSA_MT7530=y
+CONFIG_NET_DSA_TAG_MTK=y
 CONFIG_NET_FLOW_LIMIT=y
-CONFIG_NET_MEDIATEK_GSW_MT7621=y
-CONFIG_NET_MEDIATEK_MDIO=y
-CONFIG_NET_MEDIATEK_MDIO_MT7620=y
-CONFIG_NET_MEDIATEK_MT7621=y
 CONFIG_NET_MEDIATEK_SOC=y
+CONFIG_NET_SWITCHDEV=y
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_AGERE is not set
+# CONFIG_NET_VENDOR_ALACRITECH is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_NET_VENDOR_AMAZON is not set
+# CONFIG_NET_VENDOR_AMD is not set
+# CONFIG_NET_VENDOR_AQUANTIA is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_VENDOR_AURORA is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_EXAR is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_HP is not set
+# CONFIG_NET_VENDOR_HUAWEI is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
 CONFIG_NET_VENDOR_MEDIATEK=y
+# CONFIG_NET_VENDOR_MELLANOX is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NETRONOME is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_RDC is not set
+# CONFIG_NET_VENDOR_REALTEK is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_SOLARFLARE is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_TOSHIBA is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+# CONFIG_NET_VENDOR_XILINX is not set
 CONFIG_NO_GENERIC_PCI_IOPORT_MAP=y
 # CONFIG_NO_IOPORT_MAP is not set
 CONFIG_NR_CPUS=4
@@ -214,6 +294,7 @@
 CONFIG_PERF_USE_VMALLOC=y
 CONFIG_PGTABLE_LEVELS=2
 CONFIG_PHYLIB=y
+CONFIG_PHYLINK=y
 # CONFIG_PHY_RALINK_USB is not set
 CONFIG_PINCTRL=y
 CONFIG_PINCTRL_RT2880=y
@@ -221,12 +302,16 @@
 CONFIG_POWER_RESET=y
 CONFIG_POWER_RESET_GPIO=y
 CONFIG_POWER_SUPPLY=y
+CONFIG_QUEUED_RWLOCKS=y
+CONFIG_QUEUED_SPINLOCKS=y
 CONFIG_RALINK=y
 # CONFIG_RALINK_WDT is not set
 CONFIG_RATIONAL=y
+CONFIG_RCU_NEED_SEGCBLIST=y
 CONFIG_RCU_STALL_COMMON=y
 CONFIG_REGMAP=y
 CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_MMIO=y
 CONFIG_REGMAP_SPI=y
 CONFIG_REGULATOR=y
 CONFIG_REGULATOR_FIXED_VOLTAGE=y
@@ -244,6 +329,7 @@
 CONFIG_SERIAL_8250_NR_UARTS=3
 CONFIG_SERIAL_8250_RUNTIME_UARTS=3
 CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_SFP=y
 CONFIG_SMP=y
 CONFIG_SMP_UP=y
 # CONFIG_SOC_MT7620 is not set
@@ -256,8 +342,8 @@
 CONFIG_SPI_MT7621=y
 # CONFIG_SPI_RT2880 is not set
 CONFIG_SRCU=y
-CONFIG_SWCONFIG_LEDS=y
 CONFIG_SWCONFIG=y
+CONFIG_SWCONFIG_LEDS=y
 CONFIG_SWPHY=y
 CONFIG_SYNC_R4K=y
 CONFIG_SYSCTL_EXCEPTION_TRACE=y
@@ -275,7 +361,10 @@
 CONFIG_SYS_SUPPORTS_SCHED_SMT=y
 CONFIG_SYS_SUPPORTS_SMP=y
 CONFIG_TICK_CPU_ACCOUNTING=y
+CONFIG_TIMER_OF=y
+CONFIG_TIMER_PROBE=y
 CONFIG_TREE_RCU=y
+CONFIG_TREE_SRCU=y
 CONFIG_UBIFS_FS=y
 CONFIG_UBIFS_FS_ADVANCED_COMPR=y
 CONFIG_UBIFS_FS_LZO=y
@@ -284,6 +373,7 @@
 CONFIG_USE_OF=y
 CONFIG_WATCHDOG_CORE=y
 CONFIG_WEAK_ORDERING=y
+CONFIG_WEAK_REORDERING_BEYOND_LLSC=y
 CONFIG_XPS=y
 CONFIG_ZLIB_DEFLATE=y
 CONFIG_ZLIB_INFLATE=y
unchanged:
--- /dev/null
+++ b/target/linux/ramips/patches-4.14/2000-Patches-for-mt7623-tree.patch
@@ -0,0 +1,15561 @@
+From ebead4af1e8c4f54d2d05fe020195f11bfec6805 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Ren=C3=A9=20van=20Dorst?= <opensource@vdorst.com>
+Date: Thu, 26 Jul 2018 13:13:15 +0200
+Subject: [PATCH 2000/2002] Patches for mt7623 tree
+
+---
+ drivers/clk/Makefile                        |    2 +-
+ drivers/clk/clk.c                           |    2 +-
+ drivers/clk/mediatek/Kconfig                |  145 +-
+ drivers/clk/mediatek/Makefile               |   15 +-
+ drivers/clk/mediatek/clk-mt2701.c           |    2 +
+ drivers/clk/mediatek/clk-mt2712-bdp.c       |  102 +
+ drivers/clk/mediatek/clk-mt2712-img.c       |   80 +
+ drivers/clk/mediatek/clk-mt2712-jpgdec.c    |   76 +
+ drivers/clk/mediatek/clk-mt2712-mfg.c       |   75 +
+ drivers/clk/mediatek/clk-mt2712-mm.c        |  170 +
+ drivers/clk/mediatek/clk-mt2712-vdec.c      |   94 +
+ drivers/clk/mediatek/clk-mt2712-venc.c      |   77 +
+ drivers/clk/mediatek/clk-mt2712.c           | 1435 ++++++++
+ drivers/clk/mediatek/clk-mt7622-aud.c       |  200 ++
+ drivers/clk/mediatek/clk-mt7622-eth.c       |  156 +
+ drivers/clk/mediatek/clk-mt7622-hif.c       |  169 +
+ drivers/clk/mediatek/clk-mt7622.c           |  780 +++++
+ drivers/clk/mediatek/clk-mtk.h              |   10 +-
+ drivers/clk/mediatek/clk-pll.c              |   13 +-
+ drivers/net/dsa/mt7530.c                    |   65 +-
+ drivers/net/dsa/mt7530.h                    |    4 +
+ drivers/net/ethernet/mtk/Kconfig       |   77 +-
+ drivers/net/ethernet/mtk/Makefile      |   21 +-
+ drivers/net/ethernet/mtk/esw_rt3050.c  | 1461 --------
+ drivers/net/ethernet/mtk/esw_rt3050.h  |   29 -
+ drivers/net/ethernet/mtk/ethtool.c     |  230 --
+ drivers/net/ethernet/mtk/ethtool.h     |   22 -
+ drivers/net/ethernet/mtk/gsw_mt7620.c  |  260 --
+ drivers/net/ethernet/mtk/gsw_mt7620.h  |  127 -
+ drivers/net/ethernet/mtk/gsw_mt7621.c  |  281 --
+ drivers/net/ethernet/mtk/mdio.c        |  260 --
+ drivers/net/ethernet/mtk/mdio.h        |   27 -
+ drivers/net/ethernet/mtk/mdio_mt7620.c |  168 -
+ drivers/net/ethernet/mtk/mdio_rt2880.c |  222 --
+ drivers/net/ethernet/mtk/mdio_rt2880.h |   23 -
+ drivers/net/ethernet/mtk/mt7530.c      |  979 ------
+ drivers/net/ethernet/mtk/mt7530.h      |  186 -
+ drivers/net/ethernet/mtk/mtk_debugfs.c |  115 -
+ drivers/net/ethernet/mtk/mtk_eth_soc.c | 3462 ++++++++++++-------
+ drivers/net/ethernet/mtk/mtk_eth_soc.h | 1104 +++---
+ drivers/net/ethernet/mtk/mtk_offload.c |  526 ---
+ drivers/net/ethernet/mtk/mtk_offload.h |  260 --
+ drivers/net/ethernet/mtk/soc_mt7620.c  |  335 --
+ drivers/net/ethernet/mtk/soc_mt7621.c  |  186 -
+ drivers/net/ethernet/mtk/soc_rt2880.c  |   76 -
+ drivers/net/ethernet/mtk/soc_rt3050.c  |  158 -
+ drivers/net/ethernet/mtk/soc_rt3883.c  |   75 -
+ drivers/net/phy/phy.c                       |   15 +-
+ drivers/net/phy/phy_device.c                |    2 +-
+ 49 files changed, 6511 insertions(+), 7848 deletions(-)
+ create mode 100644 drivers/clk/mediatek/clk-mt2712-bdp.c
+ create mode 100644 drivers/clk/mediatek/clk-mt2712-img.c
+ create mode 100644 drivers/clk/mediatek/clk-mt2712-jpgdec.c
+ create mode 100644 drivers/clk/mediatek/clk-mt2712-mfg.c
+ create mode 100644 drivers/clk/mediatek/clk-mt2712-mm.c
+ create mode 100644 drivers/clk/mediatek/clk-mt2712-vdec.c
+ create mode 100644 drivers/clk/mediatek/clk-mt2712-venc.c
+ create mode 100644 drivers/clk/mediatek/clk-mt2712.c
+ create mode 100644 drivers/clk/mediatek/clk-mt7622-aud.c
+ create mode 100644 drivers/clk/mediatek/clk-mt7622-eth.c
+ create mode 100644 drivers/clk/mediatek/clk-mt7622-hif.c
+ create mode 100644 drivers/clk/mediatek/clk-mt7622.c
+ delete mode 100644 drivers/net/ethernet/mtk/esw_rt3050.c
+ delete mode 100644 drivers/net/ethernet/mtk/esw_rt3050.h
+ delete mode 100644 drivers/net/ethernet/mtk/ethtool.c
+ delete mode 100644 drivers/net/ethernet/mtk/ethtool.h
+ delete mode 100644 drivers/net/ethernet/mtk/gsw_mt7620.c
+ delete mode 100644 drivers/net/ethernet/mtk/gsw_mt7620.h
+ delete mode 100644 drivers/net/ethernet/mtk/gsw_mt7621.c
+ delete mode 100644 drivers/net/ethernet/mtk/mdio.c
+ delete mode 100644 drivers/net/ethernet/mtk/mdio.h
+ delete mode 100644 drivers/net/ethernet/mtk/mdio_mt7620.c
+ delete mode 100644 drivers/net/ethernet/mtk/mdio_rt2880.c
+ delete mode 100644 drivers/net/ethernet/mtk/mdio_rt2880.h
+ delete mode 100644 drivers/net/ethernet/mtk/mt7530.c
+ delete mode 100644 drivers/net/ethernet/mtk/mt7530.h
+ delete mode 100644 drivers/net/ethernet/mtk/mtk_debugfs.c
+ delete mode 100644 drivers/net/ethernet/mtk/mtk_offload.c
+ delete mode 100644 drivers/net/ethernet/mtk/mtk_offload.h
+ delete mode 100644 drivers/net/ethernet/mtk/soc_mt7620.c
+ delete mode 100644 drivers/net/ethernet/mtk/soc_mt7621.c
+ delete mode 100644 drivers/net/ethernet/mtk/soc_rt2880.c
+ delete mode 100644 drivers/net/ethernet/mtk/soc_rt3050.c
+ delete mode 100644 drivers/net/ethernet/mtk/soc_rt3883.c
+
+diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
+index f7f761b02bed..2e3fb08352a7 100644
+--- a/drivers/clk/Makefile
++++ b/drivers/clk/Makefile
+@@ -67,7 +67,7 @@ obj-$(CONFIG_ARCH_MXC)			+= imx/
+ obj-$(CONFIG_MACH_INGENIC)		+= ingenic/
+ obj-$(CONFIG_ARCH_KEYSTONE)		+= keystone/
+ obj-$(CONFIG_MACH_LOONGSON32)		+= loongson1/
+-obj-$(CONFIG_ARCH_MEDIATEK)		+= mediatek/
++obj-y					+= mediatek/
+ obj-$(CONFIG_COMMON_CLK_AMLOGIC)	+= meson/
+ obj-$(CONFIG_MACH_PIC32)		+= microchip/
+ ifeq ($(CONFIG_COMMON_CLK), y)
+diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
+index 6f4c98ca6e50..09f157b0693b 100644
+--- a/drivers/clk/clk.c
++++ b/drivers/clk/clk.c
+@@ -797,7 +797,7 @@ static void clk_disable_unused_subtree(struct clk_core *core)
+ 		clk_core_disable_unprepare(core->parent);
+ }
+ 
+-static bool clk_ignore_unused;
++static bool clk_ignore_unused = true;
+ static int __init clk_ignore_unused_setup(char *__unused)
+ {
+ 	clk_ignore_unused = true;
+diff --git a/drivers/clk/mediatek/Kconfig b/drivers/clk/mediatek/Kconfig
+index 28739a9a6e37..1f9ea0f21df1 100644
+--- a/drivers/clk/mediatek/Kconfig
++++ b/drivers/clk/mediatek/Kconfig
+@@ -1,99 +1,184 @@
+ #
+-# MediaTek SoC drivers
++# MediaTek Clock Drivers
+ #
++menu "Clock driver for MediaTek SoC"
++	depends on ARCH_MEDIATEK || COMPILE_TEST
++
+ config COMMON_CLK_MEDIATEK
+ 	bool
++	select RESET_CONTROLLER
+ 	---help---
+-	  Mediatek SoCs' clock support.
++	  MediaTek SoCs' clock support.
+ 
+ config COMMON_CLK_MT2701
+-	bool "Clock driver for Mediatek MT2701"
++	bool "Clock driver for MediaTek MT2701"
+ 	depends on (ARCH_MEDIATEK && ARM) || COMPILE_TEST
+ 	select COMMON_CLK_MEDIATEK
+ 	default ARCH_MEDIATEK && ARM
+ 	---help---
+-	  This driver supports Mediatek MT2701 basic clocks.
++	  This driver supports MediaTek MT2701 basic clocks.
+ 
+ config COMMON_CLK_MT2701_MMSYS
+-	bool "Clock driver for Mediatek MT2701 mmsys"
++	bool "Clock driver for MediaTek MT2701 mmsys"
+ 	depends on COMMON_CLK_MT2701
+ 	---help---
+-	  This driver supports Mediatek MT2701 mmsys clocks.
++	  This driver supports MediaTek MT2701 mmsys clocks.
+ 
+ config COMMON_CLK_MT2701_IMGSYS
+-	bool "Clock driver for Mediatek MT2701 imgsys"
++	bool "Clock driver for MediaTek MT2701 imgsys"
+ 	depends on COMMON_CLK_MT2701
+ 	---help---
+-	  This driver supports Mediatek MT2701 imgsys clocks.
++	  This driver supports MediaTek MT2701 imgsys clocks.
+ 
+ config COMMON_CLK_MT2701_VDECSYS
+-	bool "Clock driver for Mediatek MT2701 vdecsys"
++	bool "Clock driver for MediaTek MT2701 vdecsys"
+ 	depends on COMMON_CLK_MT2701
+ 	---help---
+-	  This driver supports Mediatek MT2701 vdecsys clocks.
++	  This driver supports MediaTek MT2701 vdecsys clocks.
+ 
+ config COMMON_CLK_MT2701_HIFSYS
+-	bool "Clock driver for Mediatek MT2701 hifsys"
++	bool "Clock driver for MediaTek MT2701 hifsys"
+ 	depends on COMMON_CLK_MT2701
+ 	---help---
+-	  This driver supports Mediatek MT2701 hifsys clocks.
++	  This driver supports MediaTek MT2701 hifsys clocks.
+ 
+ config COMMON_CLK_MT2701_ETHSYS
+-	bool "Clock driver for Mediatek MT2701 ethsys"
++	bool "Clock driver for MediaTek MT2701 ethsys"
+ 	depends on COMMON_CLK_MT2701
+ 	---help---
+-	  This driver supports Mediatek MT2701 ethsys clocks.
++	  This driver supports MediaTek MT2701 ethsys clocks.
+ 
+ config COMMON_CLK_MT2701_BDPSYS
+-	bool "Clock driver for Mediatek MT2701 bdpsys"
++	bool "Clock driver for MediaTek MT2701 bdpsys"
+ 	depends on COMMON_CLK_MT2701
+ 	---help---
+-	  This driver supports Mediatek MT2701 bdpsys clocks.
++	  This driver supports MediaTek MT2701 bdpsys clocks.
++
++config COMMON_CLK_MT2712
++	bool "Clock driver for MediaTek MT2712"
++	depends on (ARCH_MEDIATEK && ARM64) || COMPILE_TEST
++	select COMMON_CLK_MEDIATEK
++	default ARCH_MEDIATEK && ARM64
++	---help---
++	  This driver supports MediaTek MT2712 basic clocks.
++
++config COMMON_CLK_MT2712_BDPSYS
++	bool "Clock driver for MediaTek MT2712 bdpsys"
++	depends on COMMON_CLK_MT2712
++	---help---
++	  This driver supports MediaTek MT2712 bdpsys clocks.
++
++config COMMON_CLK_MT2712_IMGSYS
++	bool "Clock driver for MediaTek MT2712 imgsys"
++	depends on COMMON_CLK_MT2712
++	---help---
++	  This driver supports MediaTek MT2712 imgsys clocks.
++
++config COMMON_CLK_MT2712_JPGDECSYS
++	bool "Clock driver for MediaTek MT2712 jpgdecsys"
++	depends on COMMON_CLK_MT2712
++	---help---
++	  This driver supports MediaTek MT2712 jpgdecsys clocks.
++
++config COMMON_CLK_MT2712_MFGCFG
++	bool "Clock driver for MediaTek MT2712 mfgcfg"
++	depends on COMMON_CLK_MT2712
++	---help---
++	  This driver supports MediaTek MT2712 mfgcfg clocks.
++
++config COMMON_CLK_MT2712_MMSYS
++	bool "Clock driver for MediaTek MT2712 mmsys"
++	depends on COMMON_CLK_MT2712
++	---help---
++	  This driver supports MediaTek MT2712 mmsys clocks.
++
++config COMMON_CLK_MT2712_VDECSYS
++	bool "Clock driver for MediaTek MT2712 vdecsys"
++	depends on COMMON_CLK_MT2712
++	---help---
++	  This driver supports MediaTek MT2712 vdecsys clocks.
++
++config COMMON_CLK_MT2712_VENCSYS
++	bool "Clock driver for MediaTek MT2712 vencsys"
++	depends on COMMON_CLK_MT2712
++	---help---
++	  This driver supports MediaTek MT2712 vencsys clocks.
+ 
+ config COMMON_CLK_MT6797
+-       bool "Clock driver for Mediatek MT6797"
++       bool "Clock driver for MediaTek MT6797"
+        depends on (ARCH_MEDIATEK && ARM64) || COMPILE_TEST
+        select COMMON_CLK_MEDIATEK
+        default ARCH_MEDIATEK && ARM64
+        ---help---
+-         This driver supports Mediatek MT6797 basic clocks.
++         This driver supports MediaTek MT6797 basic clocks.
+ 
+ config COMMON_CLK_MT6797_MMSYS
+-       bool "Clock driver for Mediatek MT6797 mmsys"
++       bool "Clock driver for MediaTek MT6797 mmsys"
+        depends on COMMON_CLK_MT6797
+        ---help---
+-         This driver supports Mediatek MT6797 mmsys clocks.
++         This driver supports MediaTek MT6797 mmsys clocks.
+ 
+ config COMMON_CLK_MT6797_IMGSYS
+-       bool "Clock driver for Mediatek MT6797 imgsys"
++       bool "Clock driver for MediaTek MT6797 imgsys"
+        depends on COMMON_CLK_MT6797
+        ---help---
+-         This driver supports Mediatek MT6797 imgsys clocks.
++         This driver supports MediaTek MT6797 imgsys clocks.
+ 
+ config COMMON_CLK_MT6797_VDECSYS
+-       bool "Clock driver for Mediatek MT6797 vdecsys"
++       bool "Clock driver for MediaTek MT6797 vdecsys"
+        depends on COMMON_CLK_MT6797
+        ---help---
+-         This driver supports Mediatek MT6797 vdecsys clocks.
++         This driver supports MediaTek MT6797 vdecsys clocks.
+ 
+ config COMMON_CLK_MT6797_VENCSYS
+-       bool "Clock driver for Mediatek MT6797 vencsys"
++       bool "Clock driver for MediaTek MT6797 vencsys"
+        depends on COMMON_CLK_MT6797
+        ---help---
+-         This driver supports Mediatek MT6797 vencsys clocks.
++         This driver supports MediaTek MT6797 vencsys clocks.
++
++config COMMON_CLK_MT7622
++	bool "Clock driver for MediaTek MT7622"
++	depends on ARCH_MEDIATEK || COMPILE_TEST
++	select COMMON_CLK_MEDIATEK
++	default ARCH_MEDIATEK
++	---help---
++	  This driver supports MediaTek MT7622 basic clocks and clocks
++	  required for various periperals found on MediaTek.
++
++config COMMON_CLK_MT7622_ETHSYS
++	bool "Clock driver for MediaTek MT7622 ETHSYS"
++	depends on COMMON_CLK_MT7622
++	---help---
++	  This driver add support for clocks for Ethernet and SGMII
++	  required on MediaTek MT7622 SoC.
++
++config COMMON_CLK_MT7622_HIFSYS
++	bool "Clock driver for MediaTek MT7622 HIFSYS"
++	depends on COMMON_CLK_MT7622
++	---help---
++	  This driver supports MediaTek MT7622 HIFSYS clocks providing
++	  to PCI-E and USB.
++
++config COMMON_CLK_MT7622_AUDSYS
++	bool "Clock driver for MediaTek MT7622 AUDSYS"
++	depends on COMMON_CLK_MT7622
++	---help---
++	  This driver supports MediaTek MT7622 AUDSYS clocks providing
++	  to audio consumers such as I2S and TDM.
+ 
+ config COMMON_CLK_MT8135
+-	bool "Clock driver for Mediatek MT8135"
++	bool "Clock driver for MediaTek MT8135"
+ 	depends on (ARCH_MEDIATEK && ARM) || COMPILE_TEST
+ 	select COMMON_CLK_MEDIATEK
+ 	default ARCH_MEDIATEK && ARM
+ 	---help---
+-	  This driver supports Mediatek MT8135 clocks.
++	  This driver supports MediaTek MT8135 clocks.
+ 
+ config COMMON_CLK_MT8173
+-	bool "Clock driver for Mediatek MT8173"
++	bool "Clock driver for MediaTek MT8173"
+ 	depends on ARCH_MEDIATEK || COMPILE_TEST
+ 	select COMMON_CLK_MEDIATEK
+ 	default ARCH_MEDIATEK
+ 	---help---
+-	  This driver supports Mediatek MT8173 clocks.
++	  This driver supports MediaTek MT8173 clocks.
++endmenu
+diff --git a/drivers/clk/mediatek/Makefile b/drivers/clk/mediatek/Makefile
+index ba2a070765f0..5160fdc4bbb8 100644
+--- a/drivers/clk/mediatek/Makefile
++++ b/drivers/clk/mediatek/Makefile
+@@ -1,6 +1,5 @@
+ # SPDX-License-Identifier: GPL-2.0
+-obj-$(CONFIG_COMMON_CLK_MEDIATEK) += clk-mtk.o clk-pll.o clk-gate.o clk-apmixed.o clk-cpumux.o
+-obj-$(CONFIG_RESET_CONTROLLER) += reset.o
++obj-$(CONFIG_COMMON_CLK_MEDIATEK) += clk-mtk.o clk-pll.o clk-gate.o clk-apmixed.o clk-cpumux.o reset.o
+ obj-$(CONFIG_COMMON_CLK_MT6797) += clk-mt6797.o
+ obj-$(CONFIG_COMMON_CLK_MT6797_IMGSYS) += clk-mt6797-img.o
+ obj-$(CONFIG_COMMON_CLK_MT6797_MMSYS) += clk-mt6797-mm.o
+@@ -13,5 +12,17 @@ obj-$(CONFIG_COMMON_CLK_MT2701_HIFSYS) += clk-mt2701-hif.o
+ obj-$(CONFIG_COMMON_CLK_MT2701_IMGSYS) += clk-mt2701-img.o
+ obj-$(CONFIG_COMMON_CLK_MT2701_MMSYS) += clk-mt2701-mm.o
+ obj-$(CONFIG_COMMON_CLK_MT2701_VDECSYS) += clk-mt2701-vdec.o
++obj-$(CONFIG_COMMON_CLK_MT2712) += clk-mt2712.o
++obj-$(CONFIG_COMMON_CLK_MT2712_BDPSYS) += clk-mt2712-bdp.o
++obj-$(CONFIG_COMMON_CLK_MT2712_IMGSYS) += clk-mt2712-img.o
++obj-$(CONFIG_COMMON_CLK_MT2712_JPGDECSYS) += clk-mt2712-jpgdec.o
++obj-$(CONFIG_COMMON_CLK_MT2712_MFGCFG) += clk-mt2712-mfg.o
++obj-$(CONFIG_COMMON_CLK_MT2712_MMSYS) += clk-mt2712-mm.o
++obj-$(CONFIG_COMMON_CLK_MT2712_VDECSYS) += clk-mt2712-vdec.o
++obj-$(CONFIG_COMMON_CLK_MT2712_VENCSYS) += clk-mt2712-venc.o
++obj-$(CONFIG_COMMON_CLK_MT7622) += clk-mt7622.o
++obj-$(CONFIG_COMMON_CLK_MT7622_ETHSYS) += clk-mt7622-eth.o
++obj-$(CONFIG_COMMON_CLK_MT7622_HIFSYS) += clk-mt7622-hif.o
++obj-$(CONFIG_COMMON_CLK_MT7622_AUDSYS) += clk-mt7622-aud.o
+ obj-$(CONFIG_COMMON_CLK_MT8135) += clk-mt8135.o
+ obj-$(CONFIG_COMMON_CLK_MT8173) += clk-mt8173.o
+diff --git a/drivers/clk/mediatek/clk-mt2701.c b/drivers/clk/mediatek/clk-mt2701.c
+index ccfe5d30fe10..72d4e21da7a9 100644
+--- a/drivers/clk/mediatek/clk-mt2701.c
++++ b/drivers/clk/mediatek/clk-mt2701.c
+@@ -772,6 +772,8 @@ static void mtk_infrasys_init_early(struct device_node *node)
+ 	if (r)
+ 		pr_err("%s(): could not register clock provider: %d\n",
+ 			__func__, r);
++
++	mtk_register_reset_controller(node, 2, 0x30);
+ }
+ CLK_OF_DECLARE_DRIVER(mtk_infra, "mediatek,mt2701-infracfg",
+ 			mtk_infrasys_init_early);
+diff --git a/drivers/clk/mediatek/clk-mt2712-bdp.c b/drivers/clk/mediatek/clk-mt2712-bdp.c
+new file mode 100644
+index 000000000000..5fe4728c076e
+--- /dev/null
++++ b/drivers/clk/mediatek/clk-mt2712-bdp.c
+@@ -0,0 +1,102 @@
++/*
++ * Copyright (c) 2017 MediaTek Inc.
++ * Author: Weiyi Lu <weiyi.lu@mediatek.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#include <linux/clk-provider.h>
++#include <linux/platform_device.h>
++
++#include "clk-mtk.h"
++#include "clk-gate.h"
++
++#include <dt-bindings/clock/mt2712-clk.h>
++
++static const struct mtk_gate_regs bdp_cg_regs = {
++	.set_ofs = 0x100,
++	.clr_ofs = 0x100,
++	.sta_ofs = 0x100,
++};
++
++#define GATE_BDP(_id, _name, _parent, _shift) {	\
++		.id = _id,				\
++		.name = _name,				\
++		.parent_name = _parent,			\
++		.regs = &bdp_cg_regs,			\
++		.shift = _shift,			\
++		.ops = &mtk_clk_gate_ops_no_setclr,	\
++	}
++
++static const struct mtk_gate bdp_clks[] = {
++	GATE_BDP(CLK_BDP_BRIDGE_B, "bdp_bridge_b", "mm_sel", 0),
++	GATE_BDP(CLK_BDP_BRIDGE_DRAM, "bdp_bridge_d", "mm_sel", 1),
++	GATE_BDP(CLK_BDP_LARB_DRAM, "bdp_larb_d", "mm_sel", 2),
++	GATE_BDP(CLK_BDP_WR_CHANNEL_VDI_PXL, "bdp_vdi_pxl", "tvd_sel", 3),
++	GATE_BDP(CLK_BDP_WR_CHANNEL_VDI_DRAM, "bdp_vdi_d", "mm_sel", 4),
++	GATE_BDP(CLK_BDP_WR_CHANNEL_VDI_B, "bdp_vdi_b", "mm_sel", 5),
++	GATE_BDP(CLK_BDP_MT_B, "bdp_fmt_b", "mm_sel", 9),
++	GATE_BDP(CLK_BDP_DISPFMT_27M, "bdp_27m", "di_sel", 10),
++	GATE_BDP(CLK_BDP_DISPFMT_27M_VDOUT, "bdp_27m_vdout", "di_sel", 11),
++	GATE_BDP(CLK_BDP_DISPFMT_27_74_74, "bdp_27_74_74", "di_sel", 12),
++	GATE_BDP(CLK_BDP_DISPFMT_2FS, "bdp_2fs", "di_sel", 13),
++	GATE_BDP(CLK_BDP_DISPFMT_2FS_2FS74_148, "bdp_2fs74_148", "di_sel", 14),
++	GATE_BDP(CLK_BDP_DISPFMT_B, "bdp_b", "mm_sel", 15),
++	GATE_BDP(CLK_BDP_VDO_DRAM, "bdp_vdo_d", "mm_sel", 16),
++	GATE_BDP(CLK_BDP_VDO_2FS, "bdp_vdo_2fs", "di_sel", 17),
++	GATE_BDP(CLK_BDP_VDO_B, "bdp_vdo_b", "mm_sel", 18),
++	GATE_BDP(CLK_BDP_WR_CHANNEL_DI_PXL, "bdp_di_pxl", "di_sel", 19),
++	GATE_BDP(CLK_BDP_WR_CHANNEL_DI_DRAM, "bdp_di_d", "mm_sel", 20),
++	GATE_BDP(CLK_BDP_WR_CHANNEL_DI_B, "bdp_di_b", "mm_sel", 21),
++	GATE_BDP(CLK_BDP_NR_AGENT, "bdp_nr_agent", "nr_sel", 22),
++	GATE_BDP(CLK_BDP_NR_DRAM, "bdp_nr_d", "mm_sel", 23),
++	GATE_BDP(CLK_BDP_NR_B, "bdp_nr_b", "mm_sel", 24),
++	GATE_BDP(CLK_BDP_BRIDGE_RT_B, "bdp_bridge_rt_b", "mm_sel", 25),
++	GATE_BDP(CLK_BDP_BRIDGE_RT_DRAM, "bdp_bridge_rt_d", "mm_sel", 26),
++	GATE_BDP(CLK_BDP_LARB_RT_DRAM, "bdp_larb_rt_d", "mm_sel", 27),
++	GATE_BDP(CLK_BDP_TVD_TDC, "bdp_tvd_tdc", "mm_sel", 28),
++	GATE_BDP(CLK_BDP_TVD_54, "bdp_tvd_clk_54", "tvd_sel", 29),
++	GATE_BDP(CLK_BDP_TVD_CBUS, "bdp_tvd_cbus", "mm_sel", 30),
++};
++
++static int clk_mt2712_bdp_probe(struct platform_device *pdev)
++{
++	struct clk_onecell_data *clk_data;
++	int r;
++	struct device_node *node = pdev->dev.of_node;
++
++	clk_data = mtk_alloc_clk_data(CLK_BDP_NR_CLK);
++
++	mtk_clk_register_gates(node, bdp_clks, ARRAY_SIZE(bdp_clks),
++			clk_data);
++
++	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
++
++	if (r != 0)
++		pr_err("%s(): could not register clock provider: %d\n",
++			__func__, r);
++
++	return r;
++}
++
++static const struct of_device_id of_match_clk_mt2712_bdp[] = {
++	{ .compatible = "mediatek,mt2712-bdpsys", },
++	{}
++};
++
++static struct platform_driver clk_mt2712_bdp_drv = {
++	.probe = clk_mt2712_bdp_probe,
++	.driver = {
++		.name = "clk-mt2712-bdp",
++		.of_match_table = of_match_clk_mt2712_bdp,
++	},
++};
++
++builtin_platform_driver(clk_mt2712_bdp_drv);
+diff --git a/drivers/clk/mediatek/clk-mt2712-img.c b/drivers/clk/mediatek/clk-mt2712-img.c
+new file mode 100644
+index 000000000000..139ff55d495e
+--- /dev/null
++++ b/drivers/clk/mediatek/clk-mt2712-img.c
+@@ -0,0 +1,80 @@
++/*
++ * Copyright (c) 2017 MediaTek Inc.
++ * Author: Weiyi Lu <weiyi.lu@mediatek.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#include <linux/clk-provider.h>
++#include <linux/platform_device.h>
++
++#include "clk-mtk.h"
++#include "clk-gate.h"
++
++#include <dt-bindings/clock/mt2712-clk.h>
++
++static const struct mtk_gate_regs img_cg_regs = {
++	.set_ofs = 0x0,
++	.clr_ofs = 0x0,
++	.sta_ofs = 0x0,
++};
++
++#define GATE_IMG(_id, _name, _parent, _shift) {	\
++		.id = _id,				\
++		.name = _name,				\
++		.parent_name = _parent,			\
++		.regs = &img_cg_regs,			\
++		.shift = _shift,			\
++		.ops = &mtk_clk_gate_ops_no_setclr,	\
++	}
++
++static const struct mtk_gate img_clks[] = {
++	GATE_IMG(CLK_IMG_SMI_LARB2, "img_smi_larb2", "mm_sel", 0),
++	GATE_IMG(CLK_IMG_SENINF_SCAM_EN, "img_scam_en", "csi0", 3),
++	GATE_IMG(CLK_IMG_SENINF_CAM_EN, "img_cam_en", "mm_sel", 8),
++	GATE_IMG(CLK_IMG_CAM_SV_EN, "img_cam_sv_en", "mm_sel", 9),
++	GATE_IMG(CLK_IMG_CAM_SV1_EN, "img_cam_sv1_en", "mm_sel", 10),
++	GATE_IMG(CLK_IMG_CAM_SV2_EN, "img_cam_sv2_en", "mm_sel", 11),
++};
++
++static int clk_mt2712_img_probe(struct platform_device *pdev)
++{
++	struct clk_onecell_data *clk_data;
++	int r;
++	struct device_node *node = pdev->dev.of_node;
++
++	clk_data = mtk_alloc_clk_data(CLK_IMG_NR_CLK);
++
++	mtk_clk_register_gates(node, img_clks, ARRAY_SIZE(img_clks),
++			clk_data);
++
++	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
++
++	if (r != 0)
++		pr_err("%s(): could not register clock provider: %d\n",
++			__func__, r);
++
++	return r;
++}
++
++static const struct of_device_id of_match_clk_mt2712_img[] = {
++	{ .compatible = "mediatek,mt2712-imgsys", },
++	{}
++};
++
++static struct platform_driver clk_mt2712_img_drv = {
++	.probe = clk_mt2712_img_probe,
++	.driver = {
++		.name = "clk-mt2712-img",
++		.of_match_table = of_match_clk_mt2712_img,
++	},
++};
++
++builtin_platform_driver(clk_mt2712_img_drv);
+diff --git a/drivers/clk/mediatek/clk-mt2712-jpgdec.c b/drivers/clk/mediatek/clk-mt2712-jpgdec.c
+new file mode 100644
+index 000000000000..c7d4aada4892
+--- /dev/null
++++ b/drivers/clk/mediatek/clk-mt2712-jpgdec.c
+@@ -0,0 +1,76 @@
++/*
++ * Copyright (c) 2017 MediaTek Inc.
++ * Author: Weiyi Lu <weiyi.lu@mediatek.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#include <linux/clk-provider.h>
++#include <linux/platform_device.h>
++
++#include "clk-mtk.h"
++#include "clk-gate.h"
++
++#include <dt-bindings/clock/mt2712-clk.h>
++
++static const struct mtk_gate_regs jpgdec_cg_regs = {
++	.set_ofs = 0x4,
++	.clr_ofs = 0x8,
++	.sta_ofs = 0x0,
++};
++
++#define GATE_JPGDEC(_id, _name, _parent, _shift) {	\
++		.id = _id,				\
++		.name = _name,				\
++		.parent_name = _parent,			\
++		.regs = &jpgdec_cg_regs,			\
++		.shift = _shift,			\
++		.ops = &mtk_clk_gate_ops_setclr_inv,	\
++	}
++
++static const struct mtk_gate jpgdec_clks[] = {
++	GATE_JPGDEC(CLK_JPGDEC_JPGDEC1, "jpgdec_jpgdec1", "jpgdec_sel", 0),
++	GATE_JPGDEC(CLK_JPGDEC_JPGDEC, "jpgdec_jpgdec", "jpgdec_sel", 4),
++};
++
++static int clk_mt2712_jpgdec_probe(struct platform_device *pdev)
++{
++	struct clk_onecell_data *clk_data;
++	int r;
++	struct device_node *node = pdev->dev.of_node;
++
++	clk_data = mtk_alloc_clk_data(CLK_JPGDEC_NR_CLK);
++
++	mtk_clk_register_gates(node, jpgdec_clks, ARRAY_SIZE(jpgdec_clks),
++			clk_data);
++
++	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
++
++	if (r != 0)
++		pr_err("%s(): could not register clock provider: %d\n",
++			__func__, r);
++
++	return r;
++}
++
++static const struct of_device_id of_match_clk_mt2712_jpgdec[] = {
++	{ .compatible = "mediatek,mt2712-jpgdecsys", },
++	{}
++};
++
++static struct platform_driver clk_mt2712_jpgdec_drv = {
++	.probe = clk_mt2712_jpgdec_probe,
++	.driver = {
++		.name = "clk-mt2712-jpgdec",
++		.of_match_table = of_match_clk_mt2712_jpgdec,
++	},
++};
++
++builtin_platform_driver(clk_mt2712_jpgdec_drv);
+diff --git a/drivers/clk/mediatek/clk-mt2712-mfg.c b/drivers/clk/mediatek/clk-mt2712-mfg.c
+new file mode 100644
+index 000000000000..570f72d48d4d
+--- /dev/null
++++ b/drivers/clk/mediatek/clk-mt2712-mfg.c
+@@ -0,0 +1,75 @@
++/*
++ * Copyright (c) 2017 MediaTek Inc.
++ * Author: Weiyi Lu <weiyi.lu@mediatek.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#include <linux/clk-provider.h>
++#include <linux/platform_device.h>
++
++#include "clk-mtk.h"
++#include "clk-gate.h"
++
++#include <dt-bindings/clock/mt2712-clk.h>
++
++static const struct mtk_gate_regs mfg_cg_regs = {
++	.set_ofs = 0x4,
++	.clr_ofs = 0x8,
++	.sta_ofs = 0x0,
++};
++
++#define GATE_MFG(_id, _name, _parent, _shift) {	\
++		.id = _id,				\
++		.name = _name,				\
++		.parent_name = _parent,			\
++		.regs = &mfg_cg_regs,			\
++		.shift = _shift,			\
++		.ops = &mtk_clk_gate_ops_setclr,	\
++	}
++
++static const struct mtk_gate mfg_clks[] = {
++	GATE_MFG(CLK_MFG_BG3D, "mfg_bg3d", "mfg_sel", 0),
++};
++
++static int clk_mt2712_mfg_probe(struct platform_device *pdev)
++{
++	struct clk_onecell_data *clk_data;
++	int r;
++	struct device_node *node = pdev->dev.of_node;
++
++	clk_data = mtk_alloc_clk_data(CLK_MFG_NR_CLK);
++
++	mtk_clk_register_gates(node, mfg_clks, ARRAY_SIZE(mfg_clks),
++			clk_data);
++
++	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
++
++	if (r != 0)
++		pr_err("%s(): could not register clock provider: %d\n",
++			__func__, r);
++
++	return r;
++}
++
++static const struct of_device_id of_match_clk_mt2712_mfg[] = {
++	{ .compatible = "mediatek,mt2712-mfgcfg", },
++	{}
++};
++
++static struct platform_driver clk_mt2712_mfg_drv = {
++	.probe = clk_mt2712_mfg_probe,
++	.driver = {
++		.name = "clk-mt2712-mfg",
++		.of_match_table = of_match_clk_mt2712_mfg,
++	},
++};
++
++builtin_platform_driver(clk_mt2712_mfg_drv);
+diff --git a/drivers/clk/mediatek/clk-mt2712-mm.c b/drivers/clk/mediatek/clk-mt2712-mm.c
+new file mode 100644
+index 000000000000..a8b4b6d42488
+--- /dev/null
++++ b/drivers/clk/mediatek/clk-mt2712-mm.c
+@@ -0,0 +1,170 @@
++/*
++ * Copyright (c) 2017 MediaTek Inc.
++ * Author: Weiyi Lu <weiyi.lu@mediatek.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#include <linux/clk-provider.h>
++#include <linux/platform_device.h>
++
++#include "clk-mtk.h"
++#include "clk-gate.h"
++
++#include <dt-bindings/clock/mt2712-clk.h>
++
++static const struct mtk_gate_regs mm0_cg_regs = {
++	.set_ofs = 0x104,
++	.clr_ofs = 0x108,
++	.sta_ofs = 0x100,
++};
++
++static const struct mtk_gate_regs mm1_cg_regs = {
++	.set_ofs = 0x114,
++	.clr_ofs = 0x118,
++	.sta_ofs = 0x110,
++};
++
++static const struct mtk_gate_regs mm2_cg_regs = {
++	.set_ofs = 0x224,
++	.clr_ofs = 0x228,
++	.sta_ofs = 0x220,
++};
++
++#define GATE_MM0(_id, _name, _parent, _shift) {	\
++		.id = _id,				\
++		.name = _name,				\
++		.parent_name = _parent,			\
++		.regs = &mm0_cg_regs,			\
++		.shift = _shift,			\
++		.ops = &mtk_clk_gate_ops_setclr,	\
++	}
++
++#define GATE_MM1(_id, _name, _parent, _shift) {	\
++		.id = _id,				\
++		.name = _name,				\
++		.parent_name = _parent,			\
++		.regs = &mm1_cg_regs,			\
++		.shift = _shift,			\
++		.ops = &mtk_clk_gate_ops_setclr,	\
++	}
++
++#define GATE_MM2(_id, _name, _parent, _shift) {	\
++		.id = _id,				\
++		.name = _name,				\
++		.parent_name = _parent,			\
++		.regs = &mm2_cg_regs,			\
++		.shift = _shift,			\
++		.ops = &mtk_clk_gate_ops_setclr,	\
++	}
++
++static const struct mtk_gate mm_clks[] = {
++	/* MM0 */
++	GATE_MM0(CLK_MM_SMI_COMMON, "mm_smi_common", "mm_sel", 0),
++	GATE_MM0(CLK_MM_SMI_LARB0, "mm_smi_larb0", "mm_sel", 1),
++	GATE_MM0(CLK_MM_CAM_MDP, "mm_cam_mdp", "mm_sel", 2),
++	GATE_MM0(CLK_MM_MDP_RDMA0, "mm_mdp_rdma0", "mm_sel", 3),
++	GATE_MM0(CLK_MM_MDP_RDMA1, "mm_mdp_rdma1", "mm_sel", 4),
++	GATE_MM0(CLK_MM_MDP_RSZ0, "mm_mdp_rsz0", "mm_sel", 5),
++	GATE_MM0(CLK_MM_MDP_RSZ1, "mm_mdp_rsz1", "mm_sel", 6),
++	GATE_MM0(CLK_MM_MDP_RSZ2, "mm_mdp_rsz2", "mm_sel", 7),
++	GATE_MM0(CLK_MM_MDP_TDSHP0, "mm_mdp_tdshp0", "mm_sel", 8),
++	GATE_MM0(CLK_MM_MDP_TDSHP1, "mm_mdp_tdshp1", "mm_sel", 9),
++	GATE_MM0(CLK_MM_MDP_CROP, "mm_mdp_crop", "mm_sel", 10),
++	GATE_MM0(CLK_MM_MDP_WDMA, "mm_mdp_wdma", "mm_sel", 11),
++	GATE_MM0(CLK_MM_MDP_WROT0, "mm_mdp_wrot0", "mm_sel", 12),
++	GATE_MM0(CLK_MM_MDP_WROT1, "mm_mdp_wrot1", "mm_sel", 13),
++	GATE_MM0(CLK_MM_FAKE_ENG, "mm_fake_eng", "mm_sel", 14),
++	GATE_MM0(CLK_MM_MUTEX_32K, "mm_mutex_32k", "clk32k", 15),
++	GATE_MM0(CLK_MM_DISP_OVL0, "mm_disp_ovl0", "mm_sel", 16),
++	GATE_MM0(CLK_MM_DISP_OVL1, "mm_disp_ovl1", "mm_sel", 17),
++	GATE_MM0(CLK_MM_DISP_RDMA0, "mm_disp_rdma0", "mm_sel", 18),
++	GATE_MM0(CLK_MM_DISP_RDMA1, "mm_disp_rdma1", "mm_sel", 19),
++	GATE_MM0(CLK_MM_DISP_RDMA2, "mm_disp_rdma2", "mm_sel", 20),
++	GATE_MM0(CLK_MM_DISP_WDMA0, "mm_disp_wdma0", "mm_sel", 21),
++	GATE_MM0(CLK_MM_DISP_WDMA1, "mm_disp_wdma1", "mm_sel", 22),
++	GATE_MM0(CLK_MM_DISP_COLOR0, "mm_disp_color0", "mm_sel", 23),
++	GATE_MM0(CLK_MM_DISP_COLOR1, "mm_disp_color1", "mm_sel", 24),
++	GATE_MM0(CLK_MM_DISP_AAL, "mm_disp_aal", "mm_sel", 25),
++	GATE_MM0(CLK_MM_DISP_GAMMA, "mm_disp_gamma", "mm_sel", 26),
++	GATE_MM0(CLK_MM_DISP_UFOE, "mm_disp_ufoe", "mm_sel", 27),
++	GATE_MM0(CLK_MM_DISP_SPLIT0, "mm_disp_split0", "mm_sel", 28),
++	GATE_MM0(CLK_MM_DISP_OD, "mm_disp_od", "mm_sel", 31),
++	/* MM1 */
++	GATE_MM1(CLK_MM_DISP_PWM0_MM, "mm_pwm0_mm", "mm_sel", 0),
++	GATE_MM1(CLK_MM_DISP_PWM0_26M, "mm_pwm0_26m", "pwm_sel", 1),
++	GATE_MM1(CLK_MM_DISP_PWM1_MM, "mm_pwm1_mm", "mm_sel", 2),
++	GATE_MM1(CLK_MM_DISP_PWM1_26M, "mm_pwm1_26m", "pwm_sel", 3),
++	GATE_MM1(CLK_MM_DSI0_ENGINE, "mm_dsi0_engine", "mm_sel", 4),
++	GATE_MM1(CLK_MM_DSI0_DIGITAL, "mm_dsi0_digital", "dsi0_lntc", 5),
++	GATE_MM1(CLK_MM_DSI1_ENGINE, "mm_dsi1_engine", "mm_sel", 6),
++	GATE_MM1(CLK_MM_DSI1_DIGITAL, "mm_dsi1_digital", "dsi1_lntc", 7),
++	GATE_MM1(CLK_MM_DPI_PIXEL, "mm_dpi_pixel", "vpll_dpix", 8),
++	GATE_MM1(CLK_MM_DPI_ENGINE, "mm_dpi_engine", "mm_sel", 9),
++	GATE_MM1(CLK_MM_DPI1_PIXEL, "mm_dpi1_pixel", "vpll3_dpix", 10),
++	GATE_MM1(CLK_MM_DPI1_ENGINE, "mm_dpi1_engine", "mm_sel", 11),
++	GATE_MM1(CLK_MM_LVDS_PIXEL, "mm_lvds_pixel", "vpll_dpix", 16),
++	GATE_MM1(CLK_MM_LVDS_CTS, "mm_lvds_cts", "lvdstx", 17),
++	GATE_MM1(CLK_MM_SMI_LARB4, "mm_smi_larb4", "mm_sel", 18),
++	GATE_MM1(CLK_MM_SMI_COMMON1, "mm_smi_common1", "mm_sel", 21),
++	GATE_MM1(CLK_MM_SMI_LARB5, "mm_smi_larb5", "mm_sel", 22),
++	GATE_MM1(CLK_MM_MDP_RDMA2, "mm_mdp_rdma2", "mm_sel", 23),
++	GATE_MM1(CLK_MM_MDP_TDSHP2, "mm_mdp_tdshp2", "mm_sel", 24),
++	GATE_MM1(CLK_MM_DISP_OVL2, "mm_disp_ovl2", "mm_sel", 25),
++	GATE_MM1(CLK_MM_DISP_WDMA2, "mm_disp_wdma2", "mm_sel", 26),
++	GATE_MM1(CLK_MM_DISP_COLOR2, "mm_disp_color2", "mm_sel", 27),
++	GATE_MM1(CLK_MM_DISP_AAL1, "mm_disp_aal1", "mm_sel", 28),
++	GATE_MM1(CLK_MM_DISP_OD1, "mm_disp_od1", "mm_sel", 29),
++	GATE_MM1(CLK_MM_LVDS1_PIXEL, "mm_lvds1_pixel", "vpll3_dpix", 30),
++	GATE_MM1(CLK_MM_LVDS1_CTS, "mm_lvds1_cts", "lvdstx3", 31),
++	/* MM2 */
++	GATE_MM2(CLK_MM_SMI_LARB7, "mm_smi_larb7", "mm_sel", 0),
++	GATE_MM2(CLK_MM_MDP_RDMA3, "mm_mdp_rdma3", "mm_sel", 1),
++	GATE_MM2(CLK_MM_MDP_WROT2, "mm_mdp_wrot2", "mm_sel", 2),
++	GATE_MM2(CLK_MM_DSI2, "mm_dsi2", "mm_sel", 3),
++	GATE_MM2(CLK_MM_DSI2_DIGITAL, "mm_dsi2_digital", "dsi0_lntc", 4),
++	GATE_MM2(CLK_MM_DSI3, "mm_dsi3", "mm_sel", 5),
++	GATE_MM2(CLK_MM_DSI3_DIGITAL, "mm_dsi3_digital", "dsi1_lntc", 6),
++};
++
++static int clk_mt2712_mm_probe(struct platform_device *pdev)
++{
++	struct clk_onecell_data *clk_data;
++	int r;
++	struct device_node *node = pdev->dev.of_node;
++
++	clk_data = mtk_alloc_clk_data(CLK_MM_NR_CLK);
++
++	mtk_clk_register_gates(node, mm_clks, ARRAY_SIZE(mm_clks),
++			clk_data);
++
++	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
++
++	if (r != 0)
++		pr_err("%s(): could not register clock provider: %d\n",
++			__func__, r);
++
++	return r;
++}
++
++static const struct of_device_id of_match_clk_mt2712_mm[] = {
++	{ .compatible = "mediatek,mt2712-mmsys", },
++	{}
++};
++
++static struct platform_driver clk_mt2712_mm_drv = {
++	.probe = clk_mt2712_mm_probe,
++	.driver = {
++		.name = "clk-mt2712-mm",
++		.of_match_table = of_match_clk_mt2712_mm,
++	},
++};
++
++builtin_platform_driver(clk_mt2712_mm_drv);
+diff --git a/drivers/clk/mediatek/clk-mt2712-vdec.c b/drivers/clk/mediatek/clk-mt2712-vdec.c
+new file mode 100644
+index 000000000000..55c64ee8cc91
+--- /dev/null
++++ b/drivers/clk/mediatek/clk-mt2712-vdec.c
+@@ -0,0 +1,94 @@
++/*
++ * Copyright (c) 2017 MediaTek Inc.
++ * Author: Weiyi Lu <weiyi.lu@mediatek.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#include <linux/clk-provider.h>
++#include <linux/platform_device.h>
++
++#include "clk-mtk.h"
++#include "clk-gate.h"
++
++#include <dt-bindings/clock/mt2712-clk.h>
++
++static const struct mtk_gate_regs vdec0_cg_regs = {
++	.set_ofs = 0x0,
++	.clr_ofs = 0x4,
++	.sta_ofs = 0x0,
++};
++
++static const struct mtk_gate_regs vdec1_cg_regs = {
++	.set_ofs = 0x8,
++	.clr_ofs = 0xc,
++	.sta_ofs = 0x8,
++};
++
++#define GATE_VDEC0(_id, _name, _parent, _shift) {	\
++		.id = _id,				\
++		.name = _name,				\
++		.parent_name = _parent,			\
++		.regs = &vdec0_cg_regs,			\
++		.shift = _shift,			\
++		.ops = &mtk_clk_gate_ops_setclr_inv,	\
++	}
++
++#define GATE_VDEC1(_id, _name, _parent, _shift) {	\
++		.id = _id,				\
++		.name = _name,				\
++		.parent_name = _parent,			\
++		.regs = &vdec1_cg_regs,			\
++		.shift = _shift,			\
++		.ops = &mtk_clk_gate_ops_setclr_inv,	\
++	}
++
++static const struct mtk_gate vdec_clks[] = {
++	/* VDEC0 */
++	GATE_VDEC0(CLK_VDEC_CKEN, "vdec_cken", "vdec_sel", 0),
++	/* VDEC1 */
++	GATE_VDEC1(CLK_VDEC_LARB1_CKEN, "vdec_larb1_cken", "vdec_sel", 0),
++	GATE_VDEC1(CLK_VDEC_IMGRZ_CKEN, "vdec_imgrz_cken", "vdec_sel", 1),
++};
++
++static int clk_mt2712_vdec_probe(struct platform_device *pdev)
++{
++	struct clk_onecell_data *clk_data;
++	int r;
++	struct device_node *node = pdev->dev.of_node;
++
++	clk_data = mtk_alloc_clk_data(CLK_VDEC_NR_CLK);
++
++	mtk_clk_register_gates(node, vdec_clks, ARRAY_SIZE(vdec_clks),
++			clk_data);
++
++	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
++
++	if (r != 0)
++		pr_err("%s(): could not register clock provider: %d\n",
++			__func__, r);
++
++	return r;
++}
++
++static const struct of_device_id of_match_clk_mt2712_vdec[] = {
++	{ .compatible = "mediatek,mt2712-vdecsys", },
++	{}
++};
++
++static struct platform_driver clk_mt2712_vdec_drv = {
++	.probe = clk_mt2712_vdec_probe,
++	.driver = {
++		.name = "clk-mt2712-vdec",
++		.of_match_table = of_match_clk_mt2712_vdec,
++	},
++};
++
++builtin_platform_driver(clk_mt2712_vdec_drv);
+diff --git a/drivers/clk/mediatek/clk-mt2712-venc.c b/drivers/clk/mediatek/clk-mt2712-venc.c
+new file mode 100644
+index 000000000000..ccbfe98777c8
+--- /dev/null
++++ b/drivers/clk/mediatek/clk-mt2712-venc.c
+@@ -0,0 +1,77 @@
++/*
++ * Copyright (c) 2017 MediaTek Inc.
++ * Author: Weiyi Lu <weiyi.lu@mediatek.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#include <linux/clk-provider.h>
++#include <linux/platform_device.h>
++
++#include "clk-mtk.h"
++#include "clk-gate.h"
++
++#include <dt-bindings/clock/mt2712-clk.h>
++
++static const struct mtk_gate_regs venc_cg_regs = {
++	.set_ofs = 0x4,
++	.clr_ofs = 0x8,
++	.sta_ofs = 0x0,
++};
++
++#define GATE_VENC(_id, _name, _parent, _shift) {	\
++		.id = _id,				\
++		.name = _name,				\
++		.parent_name = _parent,			\
++		.regs = &venc_cg_regs,			\
++		.shift = _shift,			\
++		.ops = &mtk_clk_gate_ops_setclr_inv,	\
++	}
++
++static const struct mtk_gate venc_clks[] = {
++	GATE_VENC(CLK_VENC_SMI_COMMON_CON, "venc_smi", "mm_sel", 0),
++	GATE_VENC(CLK_VENC_VENC, "venc_venc", "venc_sel", 4),
++	GATE_VENC(CLK_VENC_SMI_LARB6, "venc_smi_larb6", "jpgdec_sel", 12),
++};
++
++static int clk_mt2712_venc_probe(struct platform_device *pdev)
++{
++	struct clk_onecell_data *clk_data;
++	int r;
++	struct device_node *node = pdev->dev.of_node;
++
++	clk_data = mtk_alloc_clk_data(CLK_VENC_NR_CLK);
++
++	mtk_clk_register_gates(node, venc_clks, ARRAY_SIZE(venc_clks),
++			clk_data);
++
++	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
++
++	if (r != 0)
++		pr_err("%s(): could not register clock provider: %d\n",
++			__func__, r);
++
++	return r;
++}
++
++static const struct of_device_id of_match_clk_mt2712_venc[] = {
++	{ .compatible = "mediatek,mt2712-vencsys", },
++	{}
++};
++
++static struct platform_driver clk_mt2712_venc_drv = {
++	.probe = clk_mt2712_venc_probe,
++	.driver = {
++		.name = "clk-mt2712-venc",
++		.of_match_table = of_match_clk_mt2712_venc,
++	},
++};
++
++builtin_platform_driver(clk_mt2712_venc_drv);
+diff --git a/drivers/clk/mediatek/clk-mt2712.c b/drivers/clk/mediatek/clk-mt2712.c
+new file mode 100644
+index 000000000000..498d13799388
+--- /dev/null
++++ b/drivers/clk/mediatek/clk-mt2712.c
+@@ -0,0 +1,1435 @@
++/*
++ * Copyright (c) 2017 MediaTek Inc.
++ * Author: Weiyi Lu <weiyi.lu@mediatek.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#include <linux/clk.h>
++#include <linux/delay.h>
++#include <linux/mfd/syscon.h>
++#include <linux/of.h>
++#include <linux/of_address.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++#include <linux/slab.h>
++
++#include "clk-mtk.h"
++#include "clk-gate.h"
++
++#include <dt-bindings/clock/mt2712-clk.h>
++
++static DEFINE_SPINLOCK(mt2712_clk_lock);
++
++static const struct mtk_fixed_clk top_fixed_clks[] = {
++	FIXED_CLK(CLK_TOP_VPLL3_DPIX, "vpll3_dpix", NULL, 200000000),
++	FIXED_CLK(CLK_TOP_VPLL_DPIX, "vpll_dpix", NULL, 200000000),
++	FIXED_CLK(CLK_TOP_LTEPLL_FS26M, "ltepll_fs26m", NULL, 26000000),
++	FIXED_CLK(CLK_TOP_DMPLL, "dmpll_ck", NULL, 350000000),
++	FIXED_CLK(CLK_TOP_DSI0_LNTC, "dsi0_lntc", NULL, 143000000),
++	FIXED_CLK(CLK_TOP_DSI1_LNTC, "dsi1_lntc", NULL, 143000000),
++	FIXED_CLK(CLK_TOP_LVDSTX3_CLKDIG_CTS, "lvdstx3", NULL, 140000000),
++	FIXED_CLK(CLK_TOP_LVDSTX_CLKDIG_CTS, "lvdstx", NULL, 140000000),
++	FIXED_CLK(CLK_TOP_CLKRTC_EXT, "clkrtc_ext", NULL, 32768),
++	FIXED_CLK(CLK_TOP_CLKRTC_INT, "clkrtc_int", NULL, 32747),
++	FIXED_CLK(CLK_TOP_CSI0, "csi0", NULL, 26000000),
++	FIXED_CLK(CLK_TOP_CVBSPLL, "cvbspll", NULL, 108000000),
++};
++
++static const struct mtk_fixed_factor top_early_divs[] = {
++	FACTOR(CLK_TOP_SYS_26M, "sys_26m", "clk26m", 1,
++		1),
++	FACTOR(CLK_TOP_CLK26M_D2, "clk26m_d2", "sys_26m", 1,
++		2),
++};
++
++static const struct mtk_fixed_factor top_divs[] = {
++	FACTOR(CLK_TOP_ARMCA35PLL, "armca35pll_ck", "armca35pll", 1,
++		1),
++	FACTOR(CLK_TOP_ARMCA35PLL_600M, "armca35pll_600m", "armca35pll_ck", 1,
++		2),
++	FACTOR(CLK_TOP_ARMCA35PLL_400M, "armca35pll_400m", "armca35pll_ck", 1,
++		3),
++	FACTOR(CLK_TOP_ARMCA72PLL, "armca72pll_ck", "armca72pll", 1,
++		1),
++	FACTOR(CLK_TOP_SYSPLL, "syspll_ck", "mainpll", 1,
++		1),
++	FACTOR(CLK_TOP_SYSPLL_D2, "syspll_d2", "syspll_ck", 1,
++		2),
++	FACTOR(CLK_TOP_SYSPLL1_D2, "syspll1_d2", "syspll_d2", 1,
++		2),
++	FACTOR(CLK_TOP_SYSPLL1_D4, "syspll1_d4", "syspll_d2", 1,
++		4),
++	FACTOR(CLK_TOP_SYSPLL1_D8, "syspll1_d8", "syspll_d2", 1,
++		8),
++	FACTOR(CLK_TOP_SYSPLL1_D16, "syspll1_d16", "syspll_d2", 1,
++		16),
++	FACTOR(CLK_TOP_SYSPLL_D3, "syspll_d3", "syspll_ck", 1,
++		3),
++	FACTOR(CLK_TOP_SYSPLL2_D2, "syspll2_d2", "syspll_d3", 1,
++		2),
++	FACTOR(CLK_TOP_SYSPLL2_D4, "syspll2_d4", "syspll_d3", 1,
++		4),
++	FACTOR(CLK_TOP_SYSPLL_D5, "syspll_d5", "syspll_ck", 1,
++		5),
++	FACTOR(CLK_TOP_SYSPLL3_D2, "syspll3_d2", "syspll_d5", 1,
++		2),
++	FACTOR(CLK_TOP_SYSPLL3_D4, "syspll3_d4", "syspll_d5", 1,
++		4),
++	FACTOR(CLK_TOP_SYSPLL_D7, "syspll_d7", "syspll_ck", 1,
++		7),
++	FACTOR(CLK_TOP_SYSPLL4_D2, "syspll4_d2", "syspll_d7", 1,
++		2),
++	FACTOR(CLK_TOP_SYSPLL4_D4, "syspll4_d4", "syspll_d7", 1,
++		4),
++	FACTOR(CLK_TOP_UNIVPLL, "univpll_ck", "univpll", 1,
++		1),
++	FACTOR(CLK_TOP_UNIVPLL_D7, "univpll_d7", "univpll_ck", 1,
++		7),
++	FACTOR(CLK_TOP_UNIVPLL_D26, "univpll_d26", "univpll_ck", 1,
++		26),
++	FACTOR(CLK_TOP_UNIVPLL_D52, "univpll_d52", "univpll_ck", 1,
++		52),
++	FACTOR(CLK_TOP_UNIVPLL_D104, "univpll_d104", "univpll_ck", 1,
++		104),
++	FACTOR(CLK_TOP_UNIVPLL_D208, "univpll_d208", "univpll_ck", 1,
++		208),
++	FACTOR(CLK_TOP_UNIVPLL_D2, "univpll_d2", "univpll_ck", 1,
++		2),
++	FACTOR(CLK_TOP_UNIVPLL1_D2, "univpll1_d2", "univpll_d2", 1,
++		2),
++	FACTOR(CLK_TOP_UNIVPLL1_D4, "univpll1_d4", "univpll_d2", 1,
++		4),
++	FACTOR(CLK_TOP_UNIVPLL1_D8, "univpll1_d8", "univpll_d2", 1,
++		8),
++	FACTOR(CLK_TOP_UNIVPLL_D3, "univpll_d3", "univpll_ck", 1,
++		3),
++	FACTOR(CLK_TOP_UNIVPLL2_D2, "univpll2_d2", "univpll_d3", 1,
++		2),
++	FACTOR(CLK_TOP_UNIVPLL2_D4, "univpll2_d4", "univpll_d3", 1,
++		4),
++	FACTOR(CLK_TOP_UNIVPLL2_D8, "univpll2_d8", "univpll_d3", 1,
++		8),
++	FACTOR(CLK_TOP_UNIVPLL_D5, "univpll_d5", "univpll_ck", 1,
++		5),
++	FACTOR(CLK_TOP_UNIVPLL3_D2, "univpll3_d2", "univpll_d5", 1,
++		2),
++	FACTOR(CLK_TOP_UNIVPLL3_D4, "univpll3_d4", "univpll_d5", 1,
++		4),
++	FACTOR(CLK_TOP_UNIVPLL3_D8, "univpll3_d8", "univpll_d5", 1,
++		8),
++	FACTOR(CLK_TOP_F_MP0_PLL1, "f_mp0_pll1_ck", "univpll_d2", 1,
++		1),
++	FACTOR(CLK_TOP_F_MP0_PLL2, "f_mp0_pll2_ck", "univpll1_d2", 1,
++		1),
++	FACTOR(CLK_TOP_F_BIG_PLL1, "f_big_pll1_ck", "univpll_d2", 1,
++		1),
++	FACTOR(CLK_TOP_F_BIG_PLL2, "f_big_pll2_ck", "univpll1_d2", 1,
++		1),
++	FACTOR(CLK_TOP_F_BUS_PLL1, "f_bus_pll1_ck", "univpll_d2", 1,
++		1),
++	FACTOR(CLK_TOP_F_BUS_PLL2, "f_bus_pll2_ck", "univpll1_d2", 1,
++		1),
++	FACTOR(CLK_TOP_APLL1, "apll1_ck", "apll1", 1,
++		1),
++	FACTOR(CLK_TOP_APLL1_D2, "apll1_d2", "apll1_ck", 1,
++		2),
++	FACTOR(CLK_TOP_APLL1_D4, "apll1_d4", "apll1_ck", 1,
++		4),
++	FACTOR(CLK_TOP_APLL1_D8, "apll1_d8", "apll1_ck", 1,
++		8),
++	FACTOR(CLK_TOP_APLL1_D16, "apll1_d16", "apll1_ck", 1,
++		16),
++	FACTOR(CLK_TOP_APLL2, "apll2_ck", "apll2", 1,
++		1),
++	FACTOR(CLK_TOP_APLL2_D2, "apll2_d2", "apll2_ck", 1,
++		2),
++	FACTOR(CLK_TOP_APLL2_D4, "apll2_d4", "apll2_ck", 1,
++		4),
++	FACTOR(CLK_TOP_APLL2_D8, "apll2_d8", "apll2_ck", 1,
++		8),
++	FACTOR(CLK_TOP_APLL2_D16, "apll2_d16", "apll2_ck", 1,
++		16),
++	FACTOR(CLK_TOP_LVDSPLL, "lvdspll_ck", "lvdspll", 1,
++		1),
++	FACTOR(CLK_TOP_LVDSPLL_D2, "lvdspll_d2", "lvdspll_ck", 1,
++		2),
++	FACTOR(CLK_TOP_LVDSPLL_D4, "lvdspll_d4", "lvdspll_ck", 1,
++		4),
++	FACTOR(CLK_TOP_LVDSPLL_D8, "lvdspll_d8", "lvdspll_ck", 1,
++		8),
++	FACTOR(CLK_TOP_LVDSPLL2, "lvdspll2_ck", "lvdspll2", 1,
++		1),
++	FACTOR(CLK_TOP_LVDSPLL2_D2, "lvdspll2_d2", "lvdspll2_ck", 1,
++		2),
++	FACTOR(CLK_TOP_LVDSPLL2_D4, "lvdspll2_d4", "lvdspll2_ck", 1,
++		4),
++	FACTOR(CLK_TOP_LVDSPLL2_D8, "lvdspll2_d8", "lvdspll2_ck", 1,
++		8),
++	FACTOR(CLK_TOP_ETHERPLL_125M, "etherpll_125m", "etherpll", 1,
++		1),
++	FACTOR(CLK_TOP_ETHERPLL_50M, "etherpll_50m", "etherpll", 1,
++		1),
++	FACTOR(CLK_TOP_CVBS, "cvbs", "cvbspll", 1,
++		1),
++	FACTOR(CLK_TOP_CVBS_D2, "cvbs_d2", "cvbs", 1,
++		2),
++	FACTOR(CLK_TOP_MMPLL, "mmpll_ck", "mmpll", 1,
++		1),
++	FACTOR(CLK_TOP_MMPLL_D2, "mmpll_d2", "mmpll_ck", 1,
++		2),
++	FACTOR(CLK_TOP_VENCPLL, "vencpll_ck", "vencpll", 1,
++		1),
++	FACTOR(CLK_TOP_VENCPLL_D2, "vencpll_d2", "vencpll_ck", 1,
++		2),
++	FACTOR(CLK_TOP_VCODECPLL, "vcodecpll_ck", "vcodecpll", 1,
++		1),
++	FACTOR(CLK_TOP_VCODECPLL_D2, "vcodecpll_d2", "vcodecpll_ck", 1,
++		2),
++	FACTOR(CLK_TOP_TVDPLL, "tvdpll_ck", "tvdpll", 1,
++		1),
++	FACTOR(CLK_TOP_TVDPLL_D2, "tvdpll_d2", "tvdpll_ck", 1,
++		2),
++	FACTOR(CLK_TOP_TVDPLL_D4, "tvdpll_d4", "tvdpll_ck", 1,
++		4),
++	FACTOR(CLK_TOP_TVDPLL_D8, "tvdpll_d8", "tvdpll_ck", 1,
++		8),
++	FACTOR(CLK_TOP_TVDPLL_429M, "tvdpll_429m", "tvdpll", 1,
++		1),
++	FACTOR(CLK_TOP_TVDPLL_429M_D2, "tvdpll_429m_d2", "tvdpll_429m", 1,
++		2),
++	FACTOR(CLK_TOP_TVDPLL_429M_D4, "tvdpll_429m_d4", "tvdpll_429m", 1,
++		4),
++	FACTOR(CLK_TOP_MSDCPLL, "msdcpll_ck", "msdcpll", 1,
++		1),
++	FACTOR(CLK_TOP_MSDCPLL_D2, "msdcpll_d2", "msdcpll_ck", 1,
++		2),
++	FACTOR(CLK_TOP_MSDCPLL_D4, "msdcpll_d4", "msdcpll_ck", 1,
++		4),
++	FACTOR(CLK_TOP_MSDCPLL2, "msdcpll2_ck", "msdcpll2", 1,
++		1),
++	FACTOR(CLK_TOP_MSDCPLL2_D2, "msdcpll2_d2", "msdcpll2_ck", 1,
++		2),
++	FACTOR(CLK_TOP_MSDCPLL2_D4, "msdcpll2_d4", "msdcpll2_ck", 1,
++		4),
++	FACTOR(CLK_TOP_D2A_ULCLK_6P5M, "d2a_ulclk_6p5m", "clk26m", 1,
++		4),
++};
++
++static const char * const axi_parents[] = {
++	"clk26m",
++	"syspll1_d2",
++	"syspll_d5",
++	"syspll1_d4",
++	"univpll_d5",
++	"univpll2_d2",
++	"msdcpll2_ck"
++};
++
++static const char * const mem_parents[] = {
++	"clk26m",
++	"dmpll_ck"
++};
++
++static const char * const mm_parents[] = {
++	"clk26m",
++	"vencpll_ck",
++	"syspll_d3",
++	"syspll1_d2",
++	"syspll_d5",
++	"syspll1_d4",
++	"univpll1_d2",
++	"univpll2_d2"
++};
++
++static const char * const pwm_parents[] = {
++	"clk26m",
++	"univpll2_d4",
++	"univpll3_d2",
++	"univpll1_d4"
++};
++
++static const char * const vdec_parents[] = {
++	"clk26m",
++	"vcodecpll_ck",
++	"tvdpll_429m",
++	"univpll_d3",
++	"vencpll_ck",
++	"syspll_d3",
++	"univpll1_d2",
++	"mmpll_d2",
++	"syspll3_d2",
++	"tvdpll_ck"
++};
++
++static const char * const venc_parents[] = {
++	"clk26m",
++	"univpll1_d2",
++	"mmpll_d2",
++	"tvdpll_d2",
++	"syspll1_d2",
++	"univpll_d5",
++	"vcodecpll_d2",
++	"univpll2_d2",
++	"syspll3_d2"
++};
++
++static const char * const mfg_parents[] = {
++	"clk26m",
++	"mmpll_ck",
++	"univpll_d3",
++	"clk26m",
++	"clk26m",
++	"clk26m",
++	"clk26m",
++	"clk26m",
++	"clk26m",
++	"syspll_d3",
++	"syspll1_d2",
++	"syspll_d5",
++	"univpll_d3",
++	"univpll1_d2",
++	"univpll_d5",
++	"univpll2_d2"
++};
++
++static const char * const camtg_parents[] = {
++	"clk26m",
++	"univpll_d52",
++	"univpll_d208",
++	"univpll_d104",
++	"clk26m_d2",
++	"univpll_d26",
++	"univpll2_d8",
++	"syspll3_d4",
++	"syspll3_d2",
++	"univpll1_d4",
++	"univpll2_d2"
++};
++
++static const char * const uart_parents[] = {
++	"clk26m",
++	"univpll2_d8"
++};
++
++static const char * const spi_parents[] = {
++	"clk26m",
++	"univpll2_d4",
++	"univpll1_d4",
++	"univpll2_d2",
++	"univpll3_d2",
++	"univpll1_d8"
++};
++
++static const char * const usb20_parents[] = {
++	"clk26m",
++	"univpll1_d8",
++	"univpll3_d4"
++};
++
++static const char * const usb30_parents[] = {
++	"clk26m",
++	"univpll3_d2",
++	"univpll3_d4",
++	"univpll2_d4"
++};
++
++static const char * const msdc50_0_h_parents[] = {
++	"clk26m",
++	"syspll1_d2",
++	"syspll2_d2",
++	"syspll4_d2",
++	"univpll_d5",
++	"univpll1_d4"
++};
++
++static const char * const msdc50_0_parents[] = {
++	"clk26m",
++	"msdcpll_ck",
++	"msdcpll_d2",
++	"univpll1_d4",
++	"syspll2_d2",
++	"msdcpll_d4",
++	"vencpll_d2",
++	"univpll1_d2",
++	"msdcpll2_ck",
++	"msdcpll2_d2",
++	"msdcpll2_d4"
++};
++
++static const char * const msdc30_1_parents[] = {
++	"clk26m",
++	"univpll2_d2",
++	"msdcpll_d2",
++	"univpll1_d4",
++	"syspll2_d2",
++	"univpll_d7",
++	"vencpll_d2"
++};
++
++static const char * const msdc30_3_parents[] = {
++	"clk26m",
++	"msdcpll2_ck",
++	"msdcpll2_d2",
++	"univpll2_d2",
++	"msdcpll2_d4",
++	"univpll1_d4",
++	"syspll2_d2",
++	"syspll_d7",
++	"univpll_d7",
++	"vencpll_d2",
++	"msdcpll_ck",
++	"msdcpll_d2",
++	"msdcpll_d4"
++};
++
++static const char * const audio_parents[] = {
++	"clk26m",
++	"syspll3_d4",
++	"syspll4_d4",
++	"syspll1_d16"
++};
++
++static const char * const aud_intbus_parents[] = {
++	"clk26m",
++	"syspll1_d4",
++	"syspll4_d2",
++	"univpll3_d2",
++	"univpll2_d8",
++	"syspll3_d2",
++	"syspll3_d4"
++};
++
++static const char * const pmicspi_parents[] = {
++	"clk26m",
++	"syspll1_d8",
++	"syspll3_d4",
++	"syspll1_d16",
++	"univpll3_d4",
++	"univpll_d26",
++	"syspll3_d4"
++};
++
++static const char * const dpilvds1_parents[] = {
++	"clk26m",
++	"lvdspll2_ck",
++	"lvdspll2_d2",
++	"lvdspll2_d4",
++	"lvdspll2_d8",
++	"clkfpc"
++};
++
++static const char * const atb_parents[] = {
++	"clk26m",
++	"syspll1_d2",
++	"univpll_d5",
++	"syspll_d5"
++};
++
++static const char * const nr_parents[] = {
++	"clk26m",
++	"univpll1_d4",
++	"syspll2_d2",
++	"syspll1_d4",
++	"univpll1_d8",
++	"univpll3_d2",
++	"univpll2_d2",
++	"syspll_d5"
++};
++
++static const char * const nfi2x_parents[] = {
++	"clk26m",
++	"syspll4_d4",
++	"univpll3_d4",
++	"univpll1_d8",
++	"syspll2_d4",
++	"univpll3_d2",
++	"syspll_d7",
++	"syspll2_d2",
++	"univpll2_d2",
++	"syspll_d5",
++	"syspll1_d2"
++};
++
++static const char * const irda_parents[] = {
++	"clk26m",
++	"univpll2_d4",
++	"syspll2_d4",
++	"univpll2_d8"
++};
++
++static const char * const cci400_parents[] = {
++	"clk26m",
++	"vencpll_ck",
++	"armca35pll_600m",
++	"armca35pll_400m",
++	"univpll_d2",
++	"syspll_d2",
++	"msdcpll_ck",
++	"univpll_d3"
++};
++
++static const char * const aud_1_parents[] = {
++	"clk26m",
++	"apll1_ck",
++	"univpll2_d4",
++	"univpll2_d8"
++};
++
++static const char * const aud_2_parents[] = {
++	"clk26m",
++	"apll2_ck",
++	"univpll2_d4",
++	"univpll2_d8"
++};
++
++static const char * const mem_mfg_parents[] = {
++	"clk26m",
++	"mmpll_ck",
++	"univpll_d3"
++};
++
++static const char * const axi_mfg_parents[] = {
++	"clk26m",
++	"axi_sel",
++	"univpll_d5"
++};
++
++static const char * const scam_parents[] = {
++	"clk26m",
++	"syspll3_d2",
++	"univpll2_d4",
++	"syspll2_d4"
++};
++
++static const char * const nfiecc_parents[] = {
++	"clk26m",
++	"nfi2x_sel",
++	"syspll_d7",
++	"syspll2_d2",
++	"univpll2_d2",
++	"univpll_d5",
++	"syspll1_d2"
++};
++
++static const char * const pe2_mac_p0_parents[] = {
++	"clk26m",
++	"syspll1_d8",
++	"syspll4_d2",
++	"syspll2_d4",
++	"univpll2_d4",
++	"syspll3_d2"
++};
++
++static const char * const dpilvds_parents[] = {
++	"clk26m",
++	"lvdspll_ck",
++	"lvdspll_d2",
++	"lvdspll_d4",
++	"lvdspll_d8",
++	"clkfpc"
++};
++
++static const char * const hdcp_parents[] = {
++	"clk26m",
++	"syspll4_d2",
++	"syspll3_d4",
++	"univpll2_d4"
++};
++
++static const char * const hdcp_24m_parents[] = {
++	"clk26m",
++	"univpll_d26",
++	"univpll_d52",
++	"univpll2_d8"
++};
++
++static const char * const rtc_parents[] = {
++	"clkrtc_int",
++	"clkrtc_ext",
++	"clk26m",
++	"univpll3_d8"
++};
++
++static const char * const spinor_parents[] = {
++	"clk26m",
++	"clk26m_d2",
++	"syspll4_d4",
++	"univpll2_d8",
++	"univpll3_d4",
++	"syspll4_d2",
++	"syspll2_d4",
++	"univpll2_d4",
++	"etherpll_125m",
++	"syspll1_d4"
++};
++
++static const char * const apll_parents[] = {
++	"clk26m",
++	"apll1_ck",
++	"apll1_d2",
++	"apll1_d4",
++	"apll1_d8",
++	"apll1_d16",
++	"apll2_ck",
++	"apll2_d2",
++	"apll2_d4",
++	"apll2_d8",
++	"apll2_d16",
++	"clk26m",
++	"clk26m"
++};
++
++static const char * const a1sys_hp_parents[] = {
++	"clk26m",
++	"apll1_ck",
++	"apll1_d2",
++	"apll1_d4",
++	"apll1_d8"
++};
++
++static const char * const a2sys_hp_parents[] = {
++	"clk26m",
++	"apll2_ck",
++	"apll2_d2",
++	"apll2_d4",
++	"apll2_d8"
++};
++
++static const char * const asm_l_parents[] = {
++	"clk26m",
++	"univpll2_d4",
++	"univpll2_d2",
++	"syspll_d5"
++};
++
++static const char * const i2so1_parents[] = {
++	"clk26m",
++	"apll1_ck",
++	"apll2_ck"
++};
++
++static const char * const ether_125m_parents[] = {
++	"clk26m",
++	"etherpll_125m",
++	"univpll3_d2"
++};
++
++static const char * const ether_50m_parents[] = {
++	"clk26m",
++	"etherpll_50m",
++	"univpll_d26",
++	"univpll3_d4"
++};
++
++static const char * const jpgdec_parents[] = {
++	"clk26m",
++	"univpll_d3",
++	"tvdpll_429m",
++	"vencpll_ck",
++	"syspll_d3",
++	"vcodecpll_ck",
++	"univpll1_d2",
++	"armca35pll_400m",
++	"tvdpll_429m_d2",
++	"tvdpll_429m_d4"
++};
++
++static const char * const spislv_parents[] = {
++	"clk26m",
++	"univpll2_d4",
++	"univpll1_d4",
++	"univpll2_d2",
++	"univpll3_d2",
++	"univpll1_d8",
++	"univpll1_d2",
++	"univpll_d5"
++};
++
++static const char * const ether_parents[] = {
++	"clk26m",
++	"etherpll_50m",
++	"univpll_d26"
++};
++
++static const char * const di_parents[] = {
++	"clk26m",
++	"tvdpll_d2",
++	"tvdpll_d4",
++	"tvdpll_d8",
++	"vencpll_ck",
++	"vencpll_d2",
++	"cvbs",
++	"cvbs_d2"
++};
++
++static const char * const tvd_parents[] = {
++	"clk26m",
++	"cvbs_d2",
++	"univpll2_d8"
++};
++
++static const char * const i2c_parents[] = {
++	"clk26m",
++	"univpll_d26",
++	"univpll2_d4",
++	"univpll3_d2",
++	"univpll1_d4"
++};
++
++static const char * const msdc0p_aes_parents[] = {
++	"clk26m",
++	"msdcpll_ck",
++	"univpll_d3",
++	"vcodecpll_ck"
++};
++
++static const char * const cmsys_parents[] = {
++	"clk26m",
++	"univpll_d3",
++	"syspll_d3",
++	"syspll1_d2",
++	"syspll2_d2"
++};
++
++static const char * const gcpu_parents[] = {
++	"clk26m",
++	"syspll_d3",
++	"syspll1_d2",
++	"univpll1_d2",
++	"univpll_d5",
++	"univpll3_d2",
++	"univpll_d3"
++};
++
++static const char * const aud_apll1_parents[] = {
++	"apll1",
++	"clkaud_ext_i_1"
++};
++
++static const char * const aud_apll2_parents[] = {
++	"apll2",
++	"clkaud_ext_i_2"
++};
++
++static const char * const audull_vtx_parents[] = {
++	"d2a_ulclk_6p5m",
++	"clkaud_ext_i_0"
++};
++
++static struct mtk_composite top_muxes[] = {
++	/* CLK_CFG_0 */
++	MUX_GATE_FLAGS(CLK_TOP_AXI_SEL, "axi_sel", axi_parents, 0x040, 0, 3,
++		7, CLK_IS_CRITICAL),
++	MUX_GATE_FLAGS(CLK_TOP_MEM_SEL, "mem_sel", mem_parents, 0x040, 8, 1,
++		15, CLK_IS_CRITICAL),
++	MUX_GATE(CLK_TOP_MM_SEL, "mm_sel",
++		mm_parents, 0x040, 24, 3, 31),
++	/* CLK_CFG_1 */
++	MUX_GATE(CLK_TOP_PWM_SEL, "pwm_sel",
++		pwm_parents, 0x050, 0, 2, 7),
++	MUX_GATE(CLK_TOP_VDEC_SEL, "vdec_sel",
++		vdec_parents, 0x050, 8, 4, 15),
++	MUX_GATE(CLK_TOP_VENC_SEL, "venc_sel",
++		venc_parents, 0x050, 16, 4, 23),
++	MUX_GATE(CLK_TOP_MFG_SEL, "mfg_sel",
++		mfg_parents, 0x050, 24, 4, 31),
++	/* CLK_CFG_2 */
++	MUX_GATE(CLK_TOP_CAMTG_SEL, "camtg_sel",
++		camtg_parents, 0x060, 0, 4, 7),
++	MUX_GATE(CLK_TOP_UART_SEL, "uart_sel",
++		uart_parents, 0x060, 8, 1, 15),
++	MUX_GATE(CLK_TOP_SPI_SEL, "spi_sel",
++		spi_parents, 0x060, 16, 3, 23),
++	MUX_GATE(CLK_TOP_USB20_SEL, "usb20_sel",
++		usb20_parents, 0x060, 24, 2, 31),
++	/* CLK_CFG_3 */
++	MUX_GATE(CLK_TOP_USB30_SEL, "usb30_sel",
++		usb30_parents, 0x070, 0, 2, 7),
++	MUX_GATE(CLK_TOP_MSDC50_0_HCLK_SEL, "msdc50_0_h_sel",
++		msdc50_0_h_parents, 0x070, 8, 3, 15),
++	MUX_GATE(CLK_TOP_MSDC50_0_SEL, "msdc50_0_sel",
++		msdc50_0_parents, 0x070, 16, 4, 23),
++	MUX_GATE(CLK_TOP_MSDC30_1_SEL, "msdc30_1_sel",
++		msdc30_1_parents, 0x070, 24, 3, 31),
++	/* CLK_CFG_4 */
++	MUX_GATE(CLK_TOP_MSDC30_2_SEL, "msdc30_2_sel",
++		msdc30_1_parents, 0x080, 0, 3, 7),
++	MUX_GATE(CLK_TOP_MSDC30_3_SEL, "msdc30_3_sel",
++		msdc30_3_parents, 0x080, 8, 4, 15),
++	MUX_GATE(CLK_TOP_AUDIO_SEL, "audio_sel",
++		audio_parents, 0x080, 16, 2, 23),
++	MUX_GATE(CLK_TOP_AUD_INTBUS_SEL, "aud_intbus_sel",
++		aud_intbus_parents, 0x080, 24, 3, 31),
++	/* CLK_CFG_5 */
++	MUX_GATE(CLK_TOP_PMICSPI_SEL, "pmicspi_sel",
++		pmicspi_parents, 0x090, 0, 3, 7),
++	MUX_GATE(CLK_TOP_DPILVDS1_SEL, "dpilvds1_sel",
++		dpilvds1_parents, 0x090, 8, 3, 15),
++	MUX_GATE(CLK_TOP_ATB_SEL, "atb_sel",
++		atb_parents, 0x090, 16, 2, 23),
++	MUX_GATE(CLK_TOP_NR_SEL, "nr_sel",
++		nr_parents, 0x090, 24, 3, 31),
++	/* CLK_CFG_6 */
++	MUX_GATE(CLK_TOP_NFI2X_SEL, "nfi2x_sel",
++		nfi2x_parents, 0x0a0, 0, 4, 7),
++	MUX_GATE(CLK_TOP_IRDA_SEL, "irda_sel",
++		irda_parents, 0x0a0, 8, 2, 15),
++	MUX_GATE(CLK_TOP_CCI400_SEL, "cci400_sel",
++		cci400_parents, 0x0a0, 16, 3, 23),
++	MUX_GATE(CLK_TOP_AUD_1_SEL, "aud_1_sel",
++		aud_1_parents, 0x0a0, 24, 2, 31),
++	/* CLK_CFG_7 */
++	MUX_GATE(CLK_TOP_AUD_2_SEL, "aud_2_sel",
++		aud_2_parents, 0x0b0, 0, 2, 7),
++	MUX_GATE(CLK_TOP_MEM_MFG_IN_AS_SEL, "mem_mfg_sel",
++		mem_mfg_parents, 0x0b0, 8, 2, 15),
++	MUX_GATE(CLK_TOP_AXI_MFG_IN_AS_SEL, "axi_mfg_sel",
++		axi_mfg_parents, 0x0b0, 16, 2, 23),
++	MUX_GATE(CLK_TOP_SCAM_SEL, "scam_sel",
++		scam_parents, 0x0b0, 24, 2, 31),
++	/* CLK_CFG_8 */
++	MUX_GATE(CLK_TOP_NFIECC_SEL, "nfiecc_sel",
++		nfiecc_parents, 0x0c0, 0, 3, 7),
++	MUX_GATE(CLK_TOP_PE2_MAC_P0_SEL, "pe2_mac_p0_sel",
++		pe2_mac_p0_parents, 0x0c0, 8, 3, 15),
++	MUX_GATE(CLK_TOP_PE2_MAC_P1_SEL, "pe2_mac_p1_sel",
++		pe2_mac_p0_parents, 0x0c0, 16, 3, 23),
++	MUX_GATE(CLK_TOP_DPILVDS_SEL, "dpilvds_sel",
++		dpilvds_parents, 0x0c0, 24, 3, 31),
++	/* CLK_CFG_9 */
++	MUX_GATE(CLK_TOP_MSDC50_3_HCLK_SEL, "msdc50_3_h_sel",
++		msdc50_0_h_parents, 0x0d0, 0, 3, 7),
++	MUX_GATE(CLK_TOP_HDCP_SEL, "hdcp_sel",
++		hdcp_parents, 0x0d0, 8, 2, 15),
++	MUX_GATE(CLK_TOP_HDCP_24M_SEL, "hdcp_24m_sel",
++		hdcp_24m_parents, 0x0d0, 16, 2, 23),
++	MUX_GATE_FLAGS(CLK_TOP_RTC_SEL, "rtc_sel", rtc_parents, 0x0d0, 24, 2,
++		31, CLK_IS_CRITICAL),
++	/* CLK_CFG_10 */
++	MUX_GATE(CLK_TOP_SPINOR_SEL, "spinor_sel",
++		spinor_parents, 0x500, 0, 4, 7),
++	MUX_GATE(CLK_TOP_APLL_SEL, "apll_sel",
++		apll_parents, 0x500, 8, 4, 15),
++	MUX_GATE(CLK_TOP_APLL2_SEL, "apll2_sel",
++		apll_parents, 0x500, 16, 4, 23),
++	MUX_GATE(CLK_TOP_A1SYS_HP_SEL, "a1sys_hp_sel",
++		a1sys_hp_parents, 0x500, 24, 3, 31),
++	/* CLK_CFG_11 */
++	MUX_GATE(CLK_TOP_A2SYS_HP_SEL, "a2sys_hp_sel",
++		a2sys_hp_parents, 0x510, 0, 3, 7),
++	MUX_GATE(CLK_TOP_ASM_L_SEL, "asm_l_sel",
++		asm_l_parents, 0x510, 8, 2, 15),
++	MUX_GATE(CLK_TOP_ASM_M_SEL, "asm_m_sel",
++		asm_l_parents, 0x510, 16, 2, 23),
++	MUX_GATE(CLK_TOP_ASM_H_SEL, "asm_h_sel",
++		asm_l_parents, 0x510, 24, 2, 31),
++	/* CLK_CFG_12 */
++	MUX_GATE(CLK_TOP_I2SO1_SEL, "i2so1_sel",
++		i2so1_parents, 0x520, 0, 2, 7),
++	MUX_GATE(CLK_TOP_I2SO2_SEL, "i2so2_sel",
++		i2so1_parents, 0x520, 8, 2, 15),
++	MUX_GATE(CLK_TOP_I2SO3_SEL, "i2so3_sel",
++		i2so1_parents, 0x520, 16, 2, 23),
++	MUX_GATE(CLK_TOP_TDMO0_SEL, "tdmo0_sel",
++		i2so1_parents, 0x520, 24, 2, 31),
++	/* CLK_CFG_13 */
++	MUX_GATE(CLK_TOP_TDMO1_SEL, "tdmo1_sel",
++		i2so1_parents, 0x530, 0, 2, 7),
++	MUX_GATE(CLK_TOP_I2SI1_SEL, "i2si1_sel",
++		i2so1_parents, 0x530, 8, 2, 15),
++	MUX_GATE(CLK_TOP_I2SI2_SEL, "i2si2_sel",
++		i2so1_parents, 0x530, 16, 2, 23),
++	MUX_GATE(CLK_TOP_I2SI3_SEL, "i2si3_sel",
++		i2so1_parents, 0x530, 24, 2, 31),
++	/* CLK_CFG_14 */
++	MUX_GATE(CLK_TOP_ETHER_125M_SEL, "ether_125m_sel",
++		ether_125m_parents, 0x540, 0, 2, 7),
++	MUX_GATE(CLK_TOP_ETHER_50M_SEL, "ether_50m_sel",
++		ether_50m_parents, 0x540, 8, 2, 15),
++	MUX_GATE(CLK_TOP_JPGDEC_SEL, "jpgdec_sel",
++		jpgdec_parents, 0x540, 16, 4, 23),
++	MUX_GATE(CLK_TOP_SPISLV_SEL, "spislv_sel",
++		spislv_parents, 0x540, 24, 3, 31),
++	/* CLK_CFG_15 */
++	MUX_GATE(CLK_TOP_ETHER_50M_RMII_SEL, "ether_sel",
++		ether_parents, 0x550, 0, 2, 7),
++	MUX_GATE(CLK_TOP_CAM2TG_SEL, "cam2tg_sel",
++		camtg_parents, 0x550, 8, 4, 15),
++	MUX_GATE(CLK_TOP_DI_SEL, "di_sel",
++		di_parents, 0x550, 16, 3, 23),
++	MUX_GATE(CLK_TOP_TVD_SEL, "tvd_sel",
++		tvd_parents, 0x550, 24, 2, 31),
++	/* CLK_CFG_16 */
++	MUX_GATE(CLK_TOP_I2C_SEL, "i2c_sel",
++		i2c_parents, 0x560, 0, 3, 7),
++	MUX_GATE(CLK_TOP_PWM_INFRA_SEL, "pwm_infra_sel",
++		pwm_parents, 0x560, 8, 2, 15),
++	MUX_GATE(CLK_TOP_MSDC0P_AES_SEL, "msdc0p_aes_sel",
++		msdc0p_aes_parents, 0x560, 16, 2, 23),
++	MUX_GATE(CLK_TOP_CMSYS_SEL, "cmsys_sel",
++		cmsys_parents, 0x560, 24, 3, 31),
++	/* CLK_CFG_17 */
++	MUX_GATE(CLK_TOP_GCPU_SEL, "gcpu_sel",
++		gcpu_parents, 0x570, 0, 3, 7),
++	/* CLK_AUDDIV_4 */
++	MUX(CLK_TOP_AUD_APLL1_SEL, "aud_apll1_sel",
++		aud_apll1_parents, 0x134, 0, 1),
++	MUX(CLK_TOP_AUD_APLL2_SEL, "aud_apll2_sel",
++		aud_apll2_parents, 0x134, 1, 1),
++	MUX(CLK_TOP_DA_AUDULL_VTX_6P5M_SEL, "audull_vtx_sel",
++		audull_vtx_parents, 0x134, 31, 1),
++};
++
++static const char * const mcu_mp0_parents[] = {
++	"clk26m",
++	"armca35pll_ck",
++	"f_mp0_pll1_ck",
++	"f_mp0_pll2_ck"
++};
++
++static const char * const mcu_mp2_parents[] = {
++	"clk26m",
++	"armca72pll_ck",
++	"f_big_pll1_ck",
++	"f_big_pll2_ck"
++};
++
++static const char * const mcu_bus_parents[] = {
++	"clk26m",
++	"cci400_sel",
++	"f_bus_pll1_ck",
++	"f_bus_pll2_ck"
++};
++
++static struct mtk_composite mcu_muxes[] = {
++	/* mp0_pll_divider_cfg */
++	MUX_GATE_FLAGS(CLK_MCU_MP0_SEL, "mcu_mp0_sel", mcu_mp0_parents, 0x7A0,
++		9, 2, -1, CLK_IS_CRITICAL),
++	/* mp2_pll_divider_cfg */
++	MUX_GATE_FLAGS(CLK_MCU_MP2_SEL, "mcu_mp2_sel", mcu_mp2_parents, 0x7A8,
++		9, 2, -1, CLK_IS_CRITICAL),
++	/* bus_pll_divider_cfg */
++	MUX_GATE_FLAGS(CLK_MCU_BUS_SEL, "mcu_bus_sel", mcu_bus_parents, 0x7C0,
++		9, 2, -1, CLK_IS_CRITICAL),
++};
++
++static const struct mtk_clk_divider top_adj_divs[] = {
++	DIV_ADJ(CLK_TOP_APLL_DIV0, "apll_div0", "i2so1_sel", 0x124, 0, 8),
++	DIV_ADJ(CLK_TOP_APLL_DIV1, "apll_div1", "i2so2_sel", 0x124, 8, 8),
++	DIV_ADJ(CLK_TOP_APLL_DIV2, "apll_div2", "i2so3_sel", 0x124, 16, 8),
++	DIV_ADJ(CLK_TOP_APLL_DIV3, "apll_div3", "tdmo0_sel", 0x124, 24, 8),
++	DIV_ADJ(CLK_TOP_APLL_DIV4, "apll_div4", "tdmo1_sel", 0x128, 0, 8),
++	DIV_ADJ(CLK_TOP_APLL_DIV5, "apll_div5", "i2si1_sel", 0x128, 8, 8),
++	DIV_ADJ(CLK_TOP_APLL_DIV6, "apll_div6", "i2si2_sel", 0x128, 16, 8),
++	DIV_ADJ(CLK_TOP_APLL_DIV7, "apll_div7", "i2si3_sel", 0x128, 24, 8),
++};
++
++static const struct mtk_gate_regs top_cg_regs = {
++	.set_ofs = 0x120,
++	.clr_ofs = 0x120,
++	.sta_ofs = 0x120,
++};
++
++#define GATE_TOP(_id, _name, _parent, _shift) {	\
++		.id = _id,				\
++		.name = _name,				\
++		.parent_name = _parent,			\
++		.regs = &top_cg_regs,			\
++		.shift = _shift,			\
++		.ops = &mtk_clk_gate_ops_no_setclr,	\
++	}
++
++static const struct mtk_gate top_clks[] = {
++	GATE_TOP(CLK_TOP_APLL_DIV_PDN0, "apll_div_pdn0", "i2so1_sel", 0),
++	GATE_TOP(CLK_TOP_APLL_DIV_PDN1, "apll_div_pdn1", "i2so2_sel", 1),
++	GATE_TOP(CLK_TOP_APLL_DIV_PDN2, "apll_div_pdn2", "i2so3_sel", 2),
++	GATE_TOP(CLK_TOP_APLL_DIV_PDN3, "apll_div_pdn3", "tdmo0_sel", 3),
++	GATE_TOP(CLK_TOP_APLL_DIV_PDN4, "apll_div_pdn4", "tdmo1_sel", 4),
++	GATE_TOP(CLK_TOP_APLL_DIV_PDN5, "apll_div_pdn5", "i2si1_sel", 5),
++	GATE_TOP(CLK_TOP_APLL_DIV_PDN6, "apll_div_pdn6", "i2si2_sel", 6),
++	GATE_TOP(CLK_TOP_APLL_DIV_PDN7, "apll_div_pdn7", "i2si3_sel", 7),
++};
++
++static const struct mtk_gate_regs infra_cg_regs = {
++	.set_ofs = 0x40,
++	.clr_ofs = 0x44,
++	.sta_ofs = 0x40,
++};
++
++#define GATE_INFRA(_id, _name, _parent, _shift) {	\
++		.id = _id,				\
++		.name = _name,				\
++		.parent_name = _parent,			\
++		.regs = &infra_cg_regs,			\
++		.shift = _shift,			\
++		.ops = &mtk_clk_gate_ops_setclr,	\
++	}
++
++static const struct mtk_gate infra_clks[] = {
++	GATE_INFRA(CLK_INFRA_DBGCLK, "infra_dbgclk", "axi_sel", 0),
++	GATE_INFRA(CLK_INFRA_GCE, "infra_gce", "axi_sel", 6),
++	GATE_INFRA(CLK_INFRA_M4U, "infra_m4u", "mem_sel", 8),
++	GATE_INFRA(CLK_INFRA_KP, "infra_kp", "axi_sel", 16),
++	GATE_INFRA(CLK_INFRA_AO_SPI0, "infra_ao_spi0", "spi_sel", 24),
++	GATE_INFRA(CLK_INFRA_AO_SPI1, "infra_ao_spi1", "spislv_sel", 25),
++	GATE_INFRA(CLK_INFRA_AO_UART5, "infra_ao_uart5", "axi_sel", 26),
++};
++
++static const struct mtk_gate_regs peri0_cg_regs = {
++	.set_ofs = 0x8,
++	.clr_ofs = 0x10,
++	.sta_ofs = 0x18,
++};
++
++static const struct mtk_gate_regs peri1_cg_regs = {
++	.set_ofs = 0xc,
++	.clr_ofs = 0x14,
++	.sta_ofs = 0x1c,
++};
++
++static const struct mtk_gate_regs peri2_cg_regs = {
++	.set_ofs = 0x42c,
++	.clr_ofs = 0x42c,
++	.sta_ofs = 0x42c,
++};
++
++#define GATE_PERI0(_id, _name, _parent, _shift) {	\
++		.id = _id,				\
++		.name = _name,				\
++		.parent_name = _parent,			\
++		.regs = &peri0_cg_regs,			\
++		.shift = _shift,			\
++		.ops = &mtk_clk_gate_ops_setclr,	\
++	}
++
++#define GATE_PERI1(_id, _name, _parent, _shift) {	\
++		.id = _id,				\
++		.name = _name,				\
++		.parent_name = _parent,			\
++		.regs = &peri1_cg_regs,			\
++		.shift = _shift,			\
++		.ops = &mtk_clk_gate_ops_setclr,	\
++	}
++
++#define GATE_PERI2(_id, _name, _parent, _shift) {	\
++		.id = _id,				\
++		.name = _name,				\
++		.parent_name = _parent,			\
++		.regs = &peri2_cg_regs,			\
++		.shift = _shift,			\
++		.ops = &mtk_clk_gate_ops_no_setclr_inv,	\
++	}
++
++static const struct mtk_gate peri_clks[] = {
++	/* PERI0 */
++	GATE_PERI0(CLK_PERI_NFI, "per_nfi",
++		"axi_sel", 0),
++	GATE_PERI0(CLK_PERI_THERM, "per_therm",
++		"axi_sel", 1),
++	GATE_PERI0(CLK_PERI_PWM0, "per_pwm0",
++		"pwm_sel", 2),
++	GATE_PERI0(CLK_PERI_PWM1, "per_pwm1",
++		"pwm_sel", 3),
++	GATE_PERI0(CLK_PERI_PWM2, "per_pwm2",
++		"pwm_sel", 4),
++	GATE_PERI0(CLK_PERI_PWM3, "per_pwm3",
++		"pwm_sel", 5),
++	GATE_PERI0(CLK_PERI_PWM4, "per_pwm4",
++		"pwm_sel", 6),
++	GATE_PERI0(CLK_PERI_PWM5, "per_pwm5",
++		"pwm_sel", 7),
++	GATE_PERI0(CLK_PERI_PWM6, "per_pwm6",
++		"pwm_sel", 8),
++	GATE_PERI0(CLK_PERI_PWM7, "per_pwm7",
++		"pwm_sel", 9),
++	GATE_PERI0(CLK_PERI_PWM, "per_pwm",
++		"pwm_sel", 10),
++	GATE_PERI0(CLK_PERI_AP_DMA, "per_ap_dma",
++		"axi_sel", 13),
++	GATE_PERI0(CLK_PERI_MSDC30_0, "per_msdc30_0",
++		"msdc50_0_sel", 14),
++	GATE_PERI0(CLK_PERI_MSDC30_1, "per_msdc30_1",
++		"msdc30_1_sel", 15),
++	GATE_PERI0(CLK_PERI_MSDC30_2, "per_msdc30_2",
++		"msdc30_2_sel", 16),
++	GATE_PERI0(CLK_PERI_MSDC30_3, "per_msdc30_3",
++		"msdc30_3_sel", 17),
++	GATE_PERI0(CLK_PERI_UART0, "per_uart0",
++		"uart_sel", 20),
++	GATE_PERI0(CLK_PERI_UART1, "per_uart1",
++		"uart_sel", 21),
++	GATE_PERI0(CLK_PERI_UART2, "per_uart2",
++		"uart_sel", 22),
++	GATE_PERI0(CLK_PERI_UART3, "per_uart3",
++		"uart_sel", 23),
++	GATE_PERI0(CLK_PERI_I2C0, "per_i2c0",
++		"axi_sel", 24),
++	GATE_PERI0(CLK_PERI_I2C1, "per_i2c1",
++		"axi_sel", 25),
++	GATE_PERI0(CLK_PERI_I2C2, "per_i2c2",
++		"axi_sel", 26),
++	GATE_PERI0(CLK_PERI_I2C3, "per_i2c3",
++		"axi_sel", 27),
++	GATE_PERI0(CLK_PERI_I2C4, "per_i2c4",
++		"axi_sel", 28),
++	GATE_PERI0(CLK_PERI_AUXADC, "per_auxadc",
++		"ltepll_fs26m", 29),
++	GATE_PERI0(CLK_PERI_SPI0, "per_spi0",
++		"spi_sel", 30),
++	/* PERI1 */
++	GATE_PERI1(CLK_PERI_SPI, "per_spi",
++		"spinor_sel", 1),
++	GATE_PERI1(CLK_PERI_I2C5, "per_i2c5",
++		"axi_sel", 3),
++	GATE_PERI1(CLK_PERI_SPI2, "per_spi2",
++		"spi_sel", 5),
++	GATE_PERI1(CLK_PERI_SPI3, "per_spi3",
++		"spi_sel", 6),
++	GATE_PERI1(CLK_PERI_SPI5, "per_spi5",
++		"spi_sel", 8),
++	GATE_PERI1(CLK_PERI_UART4, "per_uart4",
++		"uart_sel", 9),
++	GATE_PERI1(CLK_PERI_SFLASH, "per_sflash",
++		"uart_sel", 11),
++	GATE_PERI1(CLK_PERI_GMAC, "per_gmac",
++		"uart_sel", 12),
++	GATE_PERI1(CLK_PERI_PCIE0, "per_pcie0",
++		"uart_sel", 14),
++	GATE_PERI1(CLK_PERI_PCIE1, "per_pcie1",
++		"uart_sel", 15),
++	GATE_PERI1(CLK_PERI_GMAC_PCLK, "per_gmac_pclk",
++		"uart_sel", 16),
++	/* PERI2 */
++	GATE_PERI2(CLK_PERI_MSDC50_0_EN, "per_msdc50_0_en",
++		"msdc50_0_sel", 0),
++	GATE_PERI2(CLK_PERI_MSDC30_1_EN, "per_msdc30_1_en",
++		"msdc30_1_sel", 1),
++	GATE_PERI2(CLK_PERI_MSDC30_2_EN, "per_msdc30_2_en",
++		"msdc30_2_sel", 2),
++	GATE_PERI2(CLK_PERI_MSDC30_3_EN, "per_msdc30_3_en",
++		"msdc30_3_sel", 3),
++	GATE_PERI2(CLK_PERI_MSDC50_0_HCLK_EN, "per_msdc50_0_h",
++		"msdc50_0_h_sel", 4),
++	GATE_PERI2(CLK_PERI_MSDC50_3_HCLK_EN, "per_msdc50_3_h",
++		"msdc50_3_h_sel", 5),
++};
++
++#define MT2712_PLL_FMAX		(3000UL * MHZ)
++
++#define CON0_MT2712_RST_BAR	BIT(24)
++
++#define PLL_B(_id, _name, _reg, _pwr_reg, _en_mask, _flags, _pcwbits,	\
++			_pd_reg, _pd_shift, _tuner_reg, _tuner_en_reg,	\
++			_tuner_en_bit, _pcw_reg, _pcw_shift,		\
++			_div_table) {					\
++		.id = _id,						\
++		.name = _name,						\
++		.reg = _reg,						\
++		.pwr_reg = _pwr_reg,					\
++		.en_mask = _en_mask,					\
++		.flags = _flags,					\
++		.rst_bar_mask = CON0_MT2712_RST_BAR,			\
++		.fmax = MT2712_PLL_FMAX,				\
++		.pcwbits = _pcwbits,					\
++		.pd_reg = _pd_reg,					\
++		.pd_shift = _pd_shift,					\
++		.tuner_reg = _tuner_reg,				\
++		.tuner_en_reg = _tuner_en_reg,				\
++		.tuner_en_bit = _tuner_en_bit,				\
++		.pcw_reg = _pcw_reg,					\
++		.pcw_shift = _pcw_shift,				\
++		.div_table = _div_table,				\
++	}
++
++#define PLL(_id, _name, _reg, _pwr_reg, _en_mask, _flags, _pcwbits,	\
++			_pd_reg, _pd_shift, _tuner_reg, _tuner_en_reg,	\
++			_tuner_en_bit, _pcw_reg, _pcw_shift)		\
++		PLL_B(_id, _name, _reg, _pwr_reg, _en_mask, _flags,	\
++			_pcwbits, _pd_reg, _pd_shift, _tuner_reg,	\
++			_tuner_en_reg, _tuner_en_bit, _pcw_reg,		\
++			_pcw_shift, NULL)
++
++static const struct mtk_pll_div_table armca35pll_div_table[] = {
++	{ .div = 0, .freq = MT2712_PLL_FMAX },
++	{ .div = 1, .freq = 1202500000 },
++	{ .div = 2, .freq = 500500000 },
++	{ .div = 3, .freq = 315250000 },
++	{ .div = 4, .freq = 157625000 },
++	{ } /* sentinel */
++};
++
++static const struct mtk_pll_div_table armca72pll_div_table[] = {
++	{ .div = 0, .freq = MT2712_PLL_FMAX },
++	{ .div = 1, .freq = 994500000 },
++	{ .div = 2, .freq = 520000000 },
++	{ .div = 3, .freq = 315250000 },
++	{ .div = 4, .freq = 157625000 },
++	{ } /* sentinel */
++};
++
++static const struct mtk_pll_div_table mmpll_div_table[] = {
++	{ .div = 0, .freq = MT2712_PLL_FMAX },
++	{ .div = 1, .freq = 1001000000 },
++	{ .div = 2, .freq = 601250000 },
++	{ .div = 3, .freq = 250250000 },
++	{ .div = 4, .freq = 125125000 },
++	{ } /* sentinel */
++};
++
++static const struct mtk_pll_data plls[] = {
++	PLL(CLK_APMIXED_MAINPLL, "mainpll", 0x0230, 0x023C, 0xf0000101,
++		HAVE_RST_BAR, 31, 0x0230, 4, 0, 0, 0, 0x0234, 0),
++	PLL(CLK_APMIXED_UNIVPLL, "univpll", 0x0240, 0x024C, 0xfe000101,
++		HAVE_RST_BAR, 31, 0x0240, 4, 0, 0, 0, 0x0244, 0),
++	PLL(CLK_APMIXED_VCODECPLL, "vcodecpll", 0x0320, 0x032C, 0xc0000101,
++		0, 31, 0x0320, 4, 0, 0, 0, 0x0324, 0),
++	PLL(CLK_APMIXED_VENCPLL, "vencpll", 0x0280, 0x028C, 0x00000101,
++		0, 31, 0x0280, 4, 0, 0, 0, 0x0284, 0),
++	PLL(CLK_APMIXED_APLL1, "apll1", 0x0330, 0x0340, 0x00000101,
++		0, 31, 0x0330, 4, 0x0338, 0x0014, 0, 0x0334, 0),
++	PLL(CLK_APMIXED_APLL2, "apll2", 0x0350, 0x0360, 0x00000101,
++		0, 31, 0x0350, 4, 0x0358, 0x0014, 1, 0x0354, 0),
++	PLL(CLK_APMIXED_LVDSPLL, "lvdspll", 0x0370, 0x037c, 0x00000101,
++		0, 31, 0x0370, 4, 0, 0, 0, 0x0374, 0),
++	PLL(CLK_APMIXED_LVDSPLL2, "lvdspll2", 0x0390, 0x039C, 0x00000101,
++		0, 31, 0x0390, 4, 0, 0, 0, 0x0394, 0),
++	PLL(CLK_APMIXED_MSDCPLL, "msdcpll", 0x0270, 0x027C, 0x00000101,
++		0, 31, 0x0270, 4, 0, 0, 0, 0x0274, 0),
++	PLL(CLK_APMIXED_MSDCPLL2, "msdcpll2", 0x0410, 0x041C, 0x00000101,
++		0, 31, 0x0410, 4, 0, 0, 0, 0x0414, 0),
++	PLL(CLK_APMIXED_TVDPLL, "tvdpll", 0x0290, 0x029C, 0xc0000101,
++		0, 31, 0x0290, 4, 0, 0, 0, 0x0294, 0),
++	PLL_B(CLK_APMIXED_MMPLL, "mmpll", 0x0250, 0x0260, 0x00000101,
++		0, 31, 0x0250, 4, 0, 0, 0, 0x0254, 0,
++		mmpll_div_table),
++	PLL_B(CLK_APMIXED_ARMCA35PLL, "armca35pll", 0x0100, 0x0110, 0xf0000101,
++		HAVE_RST_BAR, 31, 0x0100, 4, 0, 0, 0, 0x0104, 0,
++		armca35pll_div_table),
++	PLL_B(CLK_APMIXED_ARMCA72PLL, "armca72pll", 0x0210, 0x0220, 0x00000101,
++		0, 31, 0x0210, 4, 0, 0, 0, 0x0214, 0,
++		armca72pll_div_table),
++	PLL(CLK_APMIXED_ETHERPLL, "etherpll", 0x0300, 0x030C, 0xc0000101,
++		0, 31, 0x0300, 4, 0, 0, 0, 0x0304, 0),
++};
++
++static int clk_mt2712_apmixed_probe(struct platform_device *pdev)
++{
++	struct clk_onecell_data *clk_data;
++	int r;
++	struct device_node *node = pdev->dev.of_node;
++
++	clk_data = mtk_alloc_clk_data(CLK_APMIXED_NR_CLK);
++
++	mtk_clk_register_plls(node, plls, ARRAY_SIZE(plls), clk_data);
++
++	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
++
++	if (r != 0)
++		pr_err("%s(): could not register clock provider: %d\n",
++			__func__, r);
++
++	return r;
++}
++
++static struct clk_onecell_data *top_clk_data;
++
++static void clk_mt2712_top_init_early(struct device_node *node)
++{
++	int r, i;
++
++	if (!top_clk_data) {
++		top_clk_data = mtk_alloc_clk_data(CLK_TOP_NR_CLK);
++
++		for (i = 0; i < CLK_TOP_NR_CLK; i++)
++			top_clk_data->clks[i] = ERR_PTR(-EPROBE_DEFER);
++	}
++
++	mtk_clk_register_factors(top_early_divs, ARRAY_SIZE(top_early_divs),
++			top_clk_data);
++
++	r = of_clk_add_provider(node, of_clk_src_onecell_get, top_clk_data);
++	if (r)
++		pr_err("%s(): could not register clock provider: %d\n",
++			__func__, r);
++}
++
++CLK_OF_DECLARE_DRIVER(mt2712_topckgen, "mediatek,mt2712-topckgen",
++			clk_mt2712_top_init_early);
++
++static int clk_mt2712_top_probe(struct platform_device *pdev)
++{
++	int r, i;
++	struct device_node *node = pdev->dev.of_node;
++	void __iomem *base;
++	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++
++	base = devm_ioremap_resource(&pdev->dev, res);
++	if (IS_ERR(base)) {
++		pr_err("%s(): ioremap failed\n", __func__);
++		return PTR_ERR(base);
++	}
++
++	if (!top_clk_data) {
++		top_clk_data = mtk_alloc_clk_data(CLK_TOP_NR_CLK);
++	} else {
++		for (i = 0; i < CLK_TOP_NR_CLK; i++) {
++			if (top_clk_data->clks[i] == ERR_PTR(-EPROBE_DEFER))
++				top_clk_data->clks[i] = ERR_PTR(-ENOENT);
++		}
++	}
++
++	mtk_clk_register_fixed_clks(top_fixed_clks, ARRAY_SIZE(top_fixed_clks),
++			top_clk_data);
++	mtk_clk_register_factors(top_early_divs, ARRAY_SIZE(top_early_divs),
++			top_clk_data);
++	mtk_clk_register_factors(top_divs, ARRAY_SIZE(top_divs), top_clk_data);
++	mtk_clk_register_composites(top_muxes, ARRAY_SIZE(top_muxes), base,
++			&mt2712_clk_lock, top_clk_data);
++	mtk_clk_register_dividers(top_adj_divs, ARRAY_SIZE(top_adj_divs), base,
++			&mt2712_clk_lock, top_clk_data);
++	mtk_clk_register_gates(node, top_clks, ARRAY_SIZE(top_clks),
++			top_clk_data);
++
++	r = of_clk_add_provider(node, of_clk_src_onecell_get, top_clk_data);
++
++	if (r != 0)
++		pr_err("%s(): could not register clock provider: %d\n",
++			__func__, r);
++
++	return r;
++}
++
++static int clk_mt2712_infra_probe(struct platform_device *pdev)
++{
++	struct clk_onecell_data *clk_data;
++	int r;
++	struct device_node *node = pdev->dev.of_node;
++
++	clk_data = mtk_alloc_clk_data(CLK_INFRA_NR_CLK);
++
++	mtk_clk_register_gates(node, infra_clks, ARRAY_SIZE(infra_clks),
++			clk_data);
++
++	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
++
++	if (r != 0)
++		pr_err("%s(): could not register clock provider: %d\n",
++			__func__, r);
++
++	mtk_register_reset_controller(node, 2, 0x30);
++
++	return r;
++}
++
++static int clk_mt2712_peri_probe(struct platform_device *pdev)
++{
++	struct clk_onecell_data *clk_data;
++	int r;
++	struct device_node *node = pdev->dev.of_node;
++
++	clk_data = mtk_alloc_clk_data(CLK_PERI_NR_CLK);
++
++	mtk_clk_register_gates(node, peri_clks, ARRAY_SIZE(peri_clks),
++			clk_data);
++
++	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
++
++	if (r != 0)
++		pr_err("%s(): could not register clock provider: %d\n",
++			__func__, r);
++
++	mtk_register_reset_controller(node, 2, 0);
++
++	return r;
++}
++
++static int clk_mt2712_mcu_probe(struct platform_device *pdev)
++{
++	struct clk_onecell_data *clk_data;
++	int r;
++	struct device_node *node = pdev->dev.of_node;
++	void __iomem *base;
++	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++
++	base = devm_ioremap_resource(&pdev->dev, res);
++	if (IS_ERR(base)) {
++		pr_err("%s(): ioremap failed\n", __func__);
++		return PTR_ERR(base);
++	}
++
++	clk_data = mtk_alloc_clk_data(CLK_MCU_NR_CLK);
++
++	mtk_clk_register_composites(mcu_muxes, ARRAY_SIZE(mcu_muxes), base,
++			&mt2712_clk_lock, clk_data);
++
++	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
++
++	if (r != 0)
++		pr_err("%s(): could not register clock provider: %d\n",
++			__func__, r);
++
++	return r;
++}
++
++static const struct of_device_id of_match_clk_mt2712[] = {
++	{
++		.compatible = "mediatek,mt2712-apmixedsys",
++		.data = clk_mt2712_apmixed_probe,
++	}, {
++		.compatible = "mediatek,mt2712-topckgen",
++		.data = clk_mt2712_top_probe,
++	}, {
++		.compatible = "mediatek,mt2712-infracfg",
++		.data = clk_mt2712_infra_probe,
++	}, {
++		.compatible = "mediatek,mt2712-pericfg",
++		.data = clk_mt2712_peri_probe,
++	}, {
++		.compatible = "mediatek,mt2712-mcucfg",
++		.data = clk_mt2712_mcu_probe,
++	}, {
++		/* sentinel */
++	}
++};
++
++static int clk_mt2712_probe(struct platform_device *pdev)
++{
++	int (*clk_probe)(struct platform_device *);
++	int r;
++
++	clk_probe = of_device_get_match_data(&pdev->dev);
++	if (!clk_probe)
++		return -EINVAL;
++
++	r = clk_probe(pdev);
++	if (r != 0)
++		dev_err(&pdev->dev,
++			"could not register clock provider: %s: %d\n",
++			pdev->name, r);
++
++	return r;
++}
++
++static struct platform_driver clk_mt2712_drv = {
++	.probe = clk_mt2712_probe,
++	.driver = {
++		.name = "clk-mt2712",
++		.owner = THIS_MODULE,
++		.of_match_table = of_match_clk_mt2712,
++	},
++};
++
++static int __init clk_mt2712_init(void)
++{
++	return platform_driver_register(&clk_mt2712_drv);
++}
++
++arch_initcall(clk_mt2712_init);
+diff --git a/drivers/clk/mediatek/clk-mt7622-aud.c b/drivers/clk/mediatek/clk-mt7622-aud.c
+new file mode 100644
+index 000000000000..0a1109ff65b9
+--- /dev/null
++++ b/drivers/clk/mediatek/clk-mt7622-aud.c
+@@ -0,0 +1,200 @@
++/*
++ * Copyright (c) 2017 MediaTek Inc.
++ * Author: Chen Zhong <chen.zhong@mediatek.com>
++ *	   Sean Wang <sean.wang@mediatek.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#include <linux/clk-provider.h>
++#include <linux/of.h>
++#include <linux/of_address.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++
++#include "clk-mtk.h"
++#include "clk-gate.h"
++
++#include <dt-bindings/clock/mt7622-clk.h>
++
++#define GATE_AUDIO0(_id, _name, _parent, _shift) {	\
++		.id = _id,				\
++		.name = _name,				\
++		.parent_name = _parent,			\
++		.regs = &audio0_cg_regs,			\
++		.shift = _shift,			\
++		.ops = &mtk_clk_gate_ops_no_setclr,	\
++	}
++
++#define GATE_AUDIO1(_id, _name, _parent, _shift) {	\
++		.id = _id,				\
++		.name = _name,				\
++		.parent_name = _parent,			\
++		.regs = &audio1_cg_regs,			\
++		.shift = _shift,			\
++		.ops = &mtk_clk_gate_ops_no_setclr,	\
++	}
++
++#define GATE_AUDIO2(_id, _name, _parent, _shift) {	\
++		.id = _id,				\
++		.name = _name,				\
++		.parent_name = _parent,			\
++		.regs = &audio2_cg_regs,			\
++		.shift = _shift,			\
++		.ops = &mtk_clk_gate_ops_no_setclr,	\
++	}
++
++#define GATE_AUDIO3(_id, _name, _parent, _shift) {	\
++		.id = _id,				\
++		.name = _name,				\
++		.parent_name = _parent,			\
++		.regs = &audio3_cg_regs,			\
++		.shift = _shift,			\
++		.ops = &mtk_clk_gate_ops_no_setclr,	\
++	}
++
++static const struct mtk_gate_regs audio0_cg_regs = {
++	.set_ofs = 0x0,
++	.clr_ofs = 0x0,
++	.sta_ofs = 0x0,
++};
++
++static const struct mtk_gate_regs audio1_cg_regs = {
++	.set_ofs = 0x10,
++	.clr_ofs = 0x10,
++	.sta_ofs = 0x10,
++};
++
++static const struct mtk_gate_regs audio2_cg_regs = {
++	.set_ofs = 0x14,
++	.clr_ofs = 0x14,
++	.sta_ofs = 0x14,
++};
++
++static const struct mtk_gate_regs audio3_cg_regs = {
++	.set_ofs = 0x634,
++	.clr_ofs = 0x634,
++	.sta_ofs = 0x634,
++};
++
++static const struct mtk_gate audio_clks[] = {
++	/* AUDIO0 */
++	GATE_AUDIO0(CLK_AUDIO_AFE, "audio_afe", "rtc", 2),
++	GATE_AUDIO0(CLK_AUDIO_HDMI, "audio_hdmi", "apll1_ck_sel", 20),
++	GATE_AUDIO0(CLK_AUDIO_SPDF, "audio_spdf", "apll1_ck_sel", 21),
++	GATE_AUDIO0(CLK_AUDIO_APLL, "audio_apll", "apll1_ck_sel", 23),
++	/* AUDIO1 */
++	GATE_AUDIO1(CLK_AUDIO_I2SIN1, "audio_i2sin1", "a1sys_hp_sel", 0),
++	GATE_AUDIO1(CLK_AUDIO_I2SIN2, "audio_i2sin2", "a1sys_hp_sel", 1),
++	GATE_AUDIO1(CLK_AUDIO_I2SIN3, "audio_i2sin3", "a1sys_hp_sel", 2),
++	GATE_AUDIO1(CLK_AUDIO_I2SIN4, "audio_i2sin4", "a1sys_hp_sel", 3),
++	GATE_AUDIO1(CLK_AUDIO_I2SO1, "audio_i2so1", "a1sys_hp_sel", 6),
++	GATE_AUDIO1(CLK_AUDIO_I2SO2, "audio_i2so2", "a1sys_hp_sel", 7),
++	GATE_AUDIO1(CLK_AUDIO_I2SO3, "audio_i2so3", "a1sys_hp_sel", 8),
++	GATE_AUDIO1(CLK_AUDIO_I2SO4, "audio_i2so4", "a1sys_hp_sel", 9),
++	GATE_AUDIO1(CLK_AUDIO_ASRCI1, "audio_asrci1", "asm_h_sel", 12),
++	GATE_AUDIO1(CLK_AUDIO_ASRCI2, "audio_asrci2", "asm_h_sel", 13),
++	GATE_AUDIO1(CLK_AUDIO_ASRCO1, "audio_asrco1", "asm_h_sel", 14),
++	GATE_AUDIO1(CLK_AUDIO_ASRCO2, "audio_asrco2", "asm_h_sel", 15),
++	GATE_AUDIO1(CLK_AUDIO_INTDIR, "audio_intdir", "intdir_sel", 20),
++	GATE_AUDIO1(CLK_AUDIO_A1SYS, "audio_a1sys", "a1sys_hp_sel", 21),
++	GATE_AUDIO1(CLK_AUDIO_A2SYS, "audio_a2sys", "a2sys_hp_sel", 22),
++	GATE_AUDIO1(CLK_AUDIO_AFE_CONN, "audio_afe_conn", "a1sys_hp_sel", 23),
++	/* AUDIO2 */
++	GATE_AUDIO2(CLK_AUDIO_UL1, "audio_ul1", "a1sys_hp_sel", 0),
++	GATE_AUDIO2(CLK_AUDIO_UL2, "audio_ul2", "a1sys_hp_sel", 1),
++	GATE_AUDIO2(CLK_AUDIO_UL3, "audio_ul3", "a1sys_hp_sel", 2),
++	GATE_AUDIO2(CLK_AUDIO_UL4, "audio_ul4", "a1sys_hp_sel", 3),
++	GATE_AUDIO2(CLK_AUDIO_UL5, "audio_ul5", "a1sys_hp_sel", 4),
++	GATE_AUDIO2(CLK_AUDIO_UL6, "audio_ul6", "a1sys_hp_sel", 5),
++	GATE_AUDIO2(CLK_AUDIO_DL1, "audio_dl1", "a1sys_hp_sel", 6),
++	GATE_AUDIO2(CLK_AUDIO_DL2, "audio_dl2", "a1sys_hp_sel", 7),
++	GATE_AUDIO2(CLK_AUDIO_DL3, "audio_dl3", "a1sys_hp_sel", 8),
++	GATE_AUDIO2(CLK_AUDIO_DL4, "audio_dl4", "a1sys_hp_sel", 9),
++	GATE_AUDIO2(CLK_AUDIO_DL5, "audio_dl5", "a1sys_hp_sel", 10),
++	GATE_AUDIO2(CLK_AUDIO_DL6, "audio_dl6", "a1sys_hp_sel", 11),
++	GATE_AUDIO2(CLK_AUDIO_DLMCH, "audio_dlmch", "a1sys_hp_sel", 12),
++	GATE_AUDIO2(CLK_AUDIO_ARB1, "audio_arb1", "a1sys_hp_sel", 13),
++	GATE_AUDIO2(CLK_AUDIO_AWB, "audio_awb", "a1sys_hp_sel", 14),
++	GATE_AUDIO2(CLK_AUDIO_AWB2, "audio_awb2", "a1sys_hp_sel", 15),
++	GATE_AUDIO2(CLK_AUDIO_DAI, "audio_dai", "a1sys_hp_sel", 16),
++	GATE_AUDIO2(CLK_AUDIO_MOD, "audio_mod", "a1sys_hp_sel", 17),
++	/* AUDIO3 */
++	GATE_AUDIO3(CLK_AUDIO_ASRCI3, "audio_asrci3", "asm_h_sel", 2),
++	GATE_AUDIO3(CLK_AUDIO_ASRCI4, "audio_asrci4", "asm_h_sel", 3),
++	GATE_AUDIO3(CLK_AUDIO_ASRCO3, "audio_asrco3", "asm_h_sel", 6),
++	GATE_AUDIO3(CLK_AUDIO_ASRCO4, "audio_asrco4", "asm_h_sel", 7),
++	GATE_AUDIO3(CLK_AUDIO_MEM_ASRC1, "audio_mem_asrc1", "asm_h_sel", 10),
++	GATE_AUDIO3(CLK_AUDIO_MEM_ASRC2, "audio_mem_asrc2", "asm_h_sel", 11),
++	GATE_AUDIO3(CLK_AUDIO_MEM_ASRC3, "audio_mem_asrc3", "asm_h_sel", 12),
++	GATE_AUDIO3(CLK_AUDIO_MEM_ASRC4, "audio_mem_asrc4", "asm_h_sel", 13),
++	GATE_AUDIO3(CLK_AUDIO_MEM_ASRC5, "audio_mem_asrc5", "asm_h_sel", 14),
++};
++
++static int clk_mt7622_audiosys_init(struct platform_device *pdev)
++{
++	struct clk_onecell_data *clk_data;
++	struct device_node *node = pdev->dev.of_node;
++
++	int r;
++
++	clk_data = mtk_alloc_clk_data(CLK_AUDIO_NR_CLK);
++
++	mtk_clk_register_gates(node, audio_clks, ARRAY_SIZE(audio_clks),
++			       clk_data);
++
++	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
++	if (r) {
++		dev_err(&pdev->dev,
++			"could not register clock provider: %s: %d\n",
++			pdev->name, r);
++
++		return r;
++	}
++
++	return devm_of_platform_populate(&pdev->dev);
++}
++
++static const struct of_device_id of_match_clk_mt7622_aud[] = {
++	{
++		.compatible = "mediatek,mt7622-audsys",
++		.data = clk_mt7622_audiosys_init,
++	}, {
++		/* sentinel */
++	}
++};
++
++static int clk_mt7622_aud_probe(struct platform_device *pdev)
++{
++	int (*clk_init)(struct platform_device *);
++	int r;
++
++	clk_init = of_device_get_match_data(&pdev->dev);
++	if (!clk_init)
++		return -EINVAL;
++
++	r = clk_init(pdev);
++	if (r)
++		dev_err(&pdev->dev,
++			"could not register clock provider: %s: %d\n",
++			pdev->name, r);
++
++	return r;
++}
++
++static struct platform_driver clk_mt7622_aud_drv = {
++	.probe = clk_mt7622_aud_probe,
++	.driver = {
++		.name = "clk-mt7622-aud",
++		.of_match_table = of_match_clk_mt7622_aud,
++	},
++};
++
++builtin_platform_driver(clk_mt7622_aud_drv);
+diff --git a/drivers/clk/mediatek/clk-mt7622-eth.c b/drivers/clk/mediatek/clk-mt7622-eth.c
+new file mode 100644
+index 000000000000..6328127bbb3c
+--- /dev/null
++++ b/drivers/clk/mediatek/clk-mt7622-eth.c
+@@ -0,0 +1,156 @@
++/*
++ * Copyright (c) 2017 MediaTek Inc.
++ * Author: Chen Zhong <chen.zhong@mediatek.com>
++ *	   Sean Wang <sean.wang@mediatek.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#include <linux/clk-provider.h>
++#include <linux/of.h>
++#include <linux/of_address.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++
++#include "clk-mtk.h"
++#include "clk-gate.h"
++
++#include <dt-bindings/clock/mt7622-clk.h>
++
++#define GATE_ETH(_id, _name, _parent, _shift) {	\
++		.id = _id,				\
++		.name = _name,				\
++		.parent_name = _parent,			\
++		.regs = &eth_cg_regs,			\
++		.shift = _shift,			\
++		.ops = &mtk_clk_gate_ops_no_setclr_inv,	\
++	}
++
++static const struct mtk_gate_regs eth_cg_regs = {
++	.set_ofs = 0x30,
++	.clr_ofs = 0x30,
++	.sta_ofs = 0x30,
++};
++
++static const struct mtk_gate eth_clks[] = {
++	GATE_ETH(CLK_ETH_HSDMA_EN, "eth_hsdma_en", "eth_sel", 5),
++	GATE_ETH(CLK_ETH_ESW_EN, "eth_esw_en", "eth_500m", 6),
++	GATE_ETH(CLK_ETH_GP2_EN, "eth_gp2_en", "txclk_src_pre", 7),
++	GATE_ETH(CLK_ETH_GP1_EN, "eth_gp1_en", "txclk_src_pre", 8),
++	GATE_ETH(CLK_ETH_GP0_EN, "eth_gp0_en", "txclk_src_pre", 9),
++};
++
++static const struct mtk_gate_regs sgmii_cg_regs = {
++	.set_ofs = 0xE4,
++	.clr_ofs = 0xE4,
++	.sta_ofs = 0xE4,
++};
++
++#define GATE_SGMII(_id, _name, _parent, _shift) {	\
++		.id = _id,				\
++		.name = _name,				\
++		.parent_name = _parent,			\
++		.regs = &sgmii_cg_regs,			\
++		.shift = _shift,			\
++		.ops = &mtk_clk_gate_ops_no_setclr_inv,	\
++	}
++
++static const struct mtk_gate sgmii_clks[] = {
++	GATE_SGMII(CLK_SGMII_TX250M_EN, "sgmii_tx250m_en",
++		   "ssusb_tx250m", 2),
++	GATE_SGMII(CLK_SGMII_RX250M_EN, "sgmii_rx250m_en",
++		   "ssusb_eq_rx250m", 3),
++	GATE_SGMII(CLK_SGMII_CDR_REF, "sgmii_cdr_ref",
++		   "ssusb_cdr_ref", 4),
++	GATE_SGMII(CLK_SGMII_CDR_FB, "sgmii_cdr_fb",
++		   "ssusb_cdr_fb", 5),
++};
++
++static int clk_mt7622_ethsys_init(struct platform_device *pdev)
++{
++	struct clk_onecell_data *clk_data;
++	struct device_node *node = pdev->dev.of_node;
++	int r;
++
++	clk_data = mtk_alloc_clk_data(CLK_ETH_NR_CLK);
++
++	mtk_clk_register_gates(node, eth_clks, ARRAY_SIZE(eth_clks),
++			       clk_data);
++
++	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
++	if (r)
++		dev_err(&pdev->dev,
++			"could not register clock provider: %s: %d\n",
++			pdev->name, r);
++
++	mtk_register_reset_controller(node, 1, 0x34);
++
++	return r;
++}
++
++static int clk_mt7622_sgmiisys_init(struct platform_device *pdev)
++{
++	struct clk_onecell_data *clk_data;
++	struct device_node *node = pdev->dev.of_node;
++	int r;
++
++	clk_data = mtk_alloc_clk_data(CLK_SGMII_NR_CLK);
++
++	mtk_clk_register_gates(node, sgmii_clks, ARRAY_SIZE(sgmii_clks),
++			       clk_data);
++
++	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
++	if (r)
++		dev_err(&pdev->dev,
++			"could not register clock provider: %s: %d\n",
++			pdev->name, r);
++
++	return r;
++}
++
++static const struct of_device_id of_match_clk_mt7622_eth[] = {
++	{
++		.compatible = "mediatek,mt7622-ethsys",
++		.data = clk_mt7622_ethsys_init,
++	}, {
++		.compatible = "mediatek,mt7622-sgmiisys",
++		.data = clk_mt7622_sgmiisys_init,
++	}, {
++		/* sentinel */
++	}
++};
++
++static int clk_mt7622_eth_probe(struct platform_device *pdev)
++{
++	int (*clk_init)(struct platform_device *);
++	int r;
++
++	clk_init = of_device_get_match_data(&pdev->dev);
++	if (!clk_init)
++		return -EINVAL;
++
++	r = clk_init(pdev);
++	if (r)
++		dev_err(&pdev->dev,
++			"could not register clock provider: %s: %d\n",
++			pdev->name, r);
++
++	return r;
++}
++
++static struct platform_driver clk_mt7622_eth_drv = {
++	.probe = clk_mt7622_eth_probe,
++	.driver = {
++		.name = "clk-mt7622-eth",
++		.of_match_table = of_match_clk_mt7622_eth,
++	},
++};
++
++builtin_platform_driver(clk_mt7622_eth_drv);
+diff --git a/drivers/clk/mediatek/clk-mt7622-hif.c b/drivers/clk/mediatek/clk-mt7622-hif.c
+new file mode 100644
+index 000000000000..a6e8534276c6
+--- /dev/null
++++ b/drivers/clk/mediatek/clk-mt7622-hif.c
+@@ -0,0 +1,169 @@
++/*
++ * Copyright (c) 2017 MediaTek Inc.
++ * Author: Chen Zhong <chen.zhong@mediatek.com>
++ *	   Sean Wang <sean.wang@mediatek.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#include <linux/clk-provider.h>
++#include <linux/of.h>
++#include <linux/of_address.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++
++#include "clk-mtk.h"
++#include "clk-gate.h"
++
++#include <dt-bindings/clock/mt7622-clk.h>
++
++#define GATE_PCIE(_id, _name, _parent, _shift) {	\
++		.id = _id,				\
++		.name = _name,				\
++		.parent_name = _parent,			\
++		.regs = &pcie_cg_regs,			\
++		.shift = _shift,			\
++		.ops = &mtk_clk_gate_ops_no_setclr_inv,	\
++	}
++
++#define GATE_SSUSB(_id, _name, _parent, _shift) {	\
++		.id = _id,				\
++		.name = _name,				\
++		.parent_name = _parent,			\
++		.regs = &ssusb_cg_regs,			\
++		.shift = _shift,			\
++		.ops = &mtk_clk_gate_ops_no_setclr_inv,	\
++	}
++
++static const struct mtk_gate_regs pcie_cg_regs = {
++	.set_ofs = 0x30,
++	.clr_ofs = 0x30,
++	.sta_ofs = 0x30,
++};
++
++static const struct mtk_gate_regs ssusb_cg_regs = {
++	.set_ofs = 0x30,
++	.clr_ofs = 0x30,
++	.sta_ofs = 0x30,
++};
++
++static const struct mtk_gate ssusb_clks[] = {
++	GATE_SSUSB(CLK_SSUSB_U2_PHY_1P_EN, "ssusb_u2_phy_1p",
++		   "to_u2_phy_1p", 0),
++	GATE_SSUSB(CLK_SSUSB_U2_PHY_EN, "ssusb_u2_phy_en", "to_u2_phy", 1),
++	GATE_SSUSB(CLK_SSUSB_REF_EN, "ssusb_ref_en", "to_usb3_ref", 5),
++	GATE_SSUSB(CLK_SSUSB_SYS_EN, "ssusb_sys_en", "to_usb3_sys", 6),
++	GATE_SSUSB(CLK_SSUSB_MCU_EN, "ssusb_mcu_en", "axi_sel", 7),
++	GATE_SSUSB(CLK_SSUSB_DMA_EN, "ssusb_dma_en", "hif_sel", 8),
++};
++
++static const struct mtk_gate pcie_clks[] = {
++	GATE_PCIE(CLK_PCIE_P1_AUX_EN, "pcie_p1_aux_en", "p1_1mhz", 12),
++	GATE_PCIE(CLK_PCIE_P1_OBFF_EN, "pcie_p1_obff_en", "free_run_4mhz", 13),
++	GATE_PCIE(CLK_PCIE_P1_AHB_EN, "pcie_p1_ahb_en", "axi_sel", 14),
++	GATE_PCIE(CLK_PCIE_P1_AXI_EN, "pcie_p1_axi_en", "hif_sel", 15),
++	GATE_PCIE(CLK_PCIE_P1_MAC_EN, "pcie_p1_mac_en", "pcie1_mac_en", 16),
++	GATE_PCIE(CLK_PCIE_P1_PIPE_EN, "pcie_p1_pipe_en", "pcie1_pipe_en", 17),
++	GATE_PCIE(CLK_PCIE_P0_AUX_EN, "pcie_p0_aux_en", "p0_1mhz", 18),
++	GATE_PCIE(CLK_PCIE_P0_OBFF_EN, "pcie_p0_obff_en", "free_run_4mhz", 19),
++	GATE_PCIE(CLK_PCIE_P0_AHB_EN, "pcie_p0_ahb_en", "axi_sel", 20),
++	GATE_PCIE(CLK_PCIE_P0_AXI_EN, "pcie_p0_axi_en", "hif_sel", 21),
++	GATE_PCIE(CLK_PCIE_P0_MAC_EN, "pcie_p0_mac_en", "pcie0_mac_en", 22),
++	GATE_PCIE(CLK_PCIE_P0_PIPE_EN, "pcie_p0_pipe_en", "pcie0_pipe_en", 23),
++	GATE_PCIE(CLK_SATA_AHB_EN, "sata_ahb_en", "axi_sel", 26),
++	GATE_PCIE(CLK_SATA_AXI_EN, "sata_axi_en", "hif_sel", 27),
++	GATE_PCIE(CLK_SATA_ASIC_EN, "sata_asic_en", "sata_asic", 28),
++	GATE_PCIE(CLK_SATA_RBC_EN, "sata_rbc_en", "sata_rbc", 29),
++	GATE_PCIE(CLK_SATA_PM_EN, "sata_pm_en", "univpll2_d4", 30),
++};
++
++static int clk_mt7622_ssusbsys_init(struct platform_device *pdev)
++{
++	struct clk_onecell_data *clk_data;
++	struct device_node *node = pdev->dev.of_node;
++	int r;
++
++	clk_data = mtk_alloc_clk_data(CLK_SSUSB_NR_CLK);
++
++	mtk_clk_register_gates(node, ssusb_clks, ARRAY_SIZE(ssusb_clks),
++			       clk_data);
++
++	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
++	if (r)
++		dev_err(&pdev->dev,
++			"could not register clock provider: %s: %d\n",
++			pdev->name, r);
++
++	mtk_register_reset_controller(node, 1, 0x34);
++
++	return r;
++}
++
++static int clk_mt7622_pciesys_init(struct platform_device *pdev)
++{
++	struct clk_onecell_data *clk_data;
++	struct device_node *node = pdev->dev.of_node;
++	int r;
++
++	clk_data = mtk_alloc_clk_data(CLK_PCIE_NR_CLK);
++
++	mtk_clk_register_gates(node, pcie_clks, ARRAY_SIZE(pcie_clks),
++			       clk_data);
++
++	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
++	if (r)
++		dev_err(&pdev->dev,
++			"could not register clock provider: %s: %d\n",
++			pdev->name, r);
++
++	mtk_register_reset_controller(node, 1, 0x34);
++
++	return r;
++}
++
++static const struct of_device_id of_match_clk_mt7622_hif[] = {
++	{
++		.compatible = "mediatek,mt7622-pciesys",
++		.data = clk_mt7622_pciesys_init,
++	}, {
++		.compatible = "mediatek,mt7622-ssusbsys",
++		.data = clk_mt7622_ssusbsys_init,
++	}, {
++		/* sentinel */
++	}
++};
++
++static int clk_mt7622_hif_probe(struct platform_device *pdev)
++{
++	int (*clk_init)(struct platform_device *);
++	int r;
++
++	clk_init = of_device_get_match_data(&pdev->dev);
++	if (!clk_init)
++		return -EINVAL;
++
++	r = clk_init(pdev);
++	if (r)
++		dev_err(&pdev->dev,
++			"could not register clock provider: %s: %d\n",
++			pdev->name, r);
++
++	return r;
++}
++
++static struct platform_driver clk_mt7622_hif_drv = {
++	.probe = clk_mt7622_hif_probe,
++	.driver = {
++		.name = "clk-mt7622-hif",
++		.of_match_table = of_match_clk_mt7622_hif,
++	},
++};
++
++builtin_platform_driver(clk_mt7622_hif_drv);
+diff --git a/drivers/clk/mediatek/clk-mt7622.c b/drivers/clk/mediatek/clk-mt7622.c
+new file mode 100644
+index 000000000000..92f7e32770c6
+--- /dev/null
++++ b/drivers/clk/mediatek/clk-mt7622.c
+@@ -0,0 +1,780 @@
++/*
++ * Copyright (c) 2017 MediaTek Inc.
++ * Author: Chen Zhong <chen.zhong@mediatek.com>
++ *	   Sean Wang <sean.wang@mediatek.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#include <linux/clk-provider.h>
++#include <linux/of.h>
++#include <linux/of_address.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++
++#include "clk-mtk.h"
++#include "clk-gate.h"
++#include "clk-cpumux.h"
++
++#include <dt-bindings/clock/mt7622-clk.h>
++#include <linux/clk.h> /* for consumer */
++
++#define MT7622_PLL_FMAX		(2500UL * MHZ)
++#define CON0_MT7622_RST_BAR	BIT(27)
++
++#define PLL_xtal(_id, _name, _reg, _pwr_reg, _en_mask, _flags, _pcwbits,\
++			_pd_reg, _pd_shift, _tuner_reg, _pcw_reg,	\
++			_pcw_shift, _div_table, _parent_name) {		\
++		.id = _id,						\
++		.name = _name,						\
++		.reg = _reg,						\
++		.pwr_reg = _pwr_reg,					\
++		.en_mask = _en_mask,					\
++		.flags = _flags,					\
++		.rst_bar_mask = CON0_MT7622_RST_BAR,			\
++		.fmax = MT7622_PLL_FMAX,				\
++		.pcwbits = _pcwbits,					\
++		.pd_reg = _pd_reg,					\
++		.pd_shift = _pd_shift,					\
++		.tuner_reg = _tuner_reg,				\
++		.pcw_reg = _pcw_reg,					\
++		.pcw_shift = _pcw_shift,				\
++		.div_table = _div_table,				\
++		.parent_name = _parent_name,				\
++	}
++
++#define PLL(_id, _name, _reg, _pwr_reg, _en_mask, _flags, _pcwbits,	\
++			_pd_reg, _pd_shift, _tuner_reg, _pcw_reg,	\
++			_pcw_shift)					\
++	PLL_xtal(_id, _name, _reg, _pwr_reg, _en_mask, _flags, _pcwbits,\
++		 _pd_reg, _pd_shift, _tuner_reg, _pcw_reg, _pcw_shift,  \
++		 NULL, "clkxtal")
++
++#define GATE_APMIXED(_id, _name, _parent, _shift) {			\
++		.id = _id,						\
++		.name = _name,						\
++		.parent_name = _parent,					\
++		.regs = &apmixed_cg_regs,				\
++		.shift = _shift,					\
++		.ops = &mtk_clk_gate_ops_no_setclr_inv,			\
++	}
++
++#define GATE_INFRA(_id, _name, _parent, _shift) {			\
++		.id = _id,						\
++		.name = _name,						\
++		.parent_name = _parent,					\
++		.regs = &infra_cg_regs,					\
++		.shift = _shift,					\
++		.ops = &mtk_clk_gate_ops_setclr,			\
++	}
++
++#define GATE_TOP0(_id, _name, _parent, _shift) {			\
++		.id = _id,						\
++		.name = _name,						\
++		.parent_name = _parent,					\
++		.regs = &top0_cg_regs,					\
++		.shift = _shift,					\
++		.ops = &mtk_clk_gate_ops_no_setclr,			\
++	}
++
++#define GATE_TOP1(_id, _name, _parent, _shift) {			\
++		.id = _id,						\
++		.name = _name,						\
++		.parent_name = _parent,					\
++		.regs = &top1_cg_regs,					\
++		.shift = _shift,					\
++		.ops = &mtk_clk_gate_ops_no_setclr,			\
++	}
++
++#define GATE_PERI0(_id, _name, _parent, _shift) {			\
++		.id = _id,						\
++		.name = _name,						\
++		.parent_name = _parent,					\
++		.regs = &peri0_cg_regs,					\
++		.shift = _shift,					\
++		.ops = &mtk_clk_gate_ops_setclr,			\
++	}
++
++#define GATE_PERI1(_id, _name, _parent, _shift) {			\
++		.id = _id,						\
++		.name = _name,						\
++		.parent_name = _parent,					\
++		.regs = &peri1_cg_regs,					\
++		.shift = _shift,					\
++		.ops = &mtk_clk_gate_ops_setclr,			\
++	}
++
++static DEFINE_SPINLOCK(mt7622_clk_lock);
++
++static const char * const infra_mux1_parents[] = {
++	"clkxtal",
++	"armpll",
++	"main_core_en",
++	"armpll"
++};
++
++static const char * const axi_parents[] = {
++	"clkxtal",
++	"syspll1_d2",
++	"syspll_d5",
++	"syspll1_d4",
++	"univpll_d5",
++	"univpll2_d2",
++	"univpll_d7"
++};
++
++static const char * const mem_parents[] = {
++	"clkxtal",
++	"dmpll_ck"
++};
++
++static const char * const ddrphycfg_parents[] = {
++	"clkxtal",
++	"syspll1_d8"
++};
++
++static const char * const eth_parents[] = {
++	"clkxtal",
++	"syspll1_d2",
++	"univpll1_d2",
++	"syspll1_d4",
++	"univpll_d5",
++	"clk_null",
++	"univpll_d7"
++};
++
++static const char * const pwm_parents[] = {
++	"clkxtal",
++	"univpll2_d4"
++};
++
++static const char * const f10m_ref_parents[] = {
++	"clkxtal",
++	"syspll4_d16"
++};
++
++static const char * const nfi_infra_parents[] = {
++	"clkxtal",
++	"clkxtal",
++	"clkxtal",
++	"clkxtal",
++	"clkxtal",
++	"clkxtal",
++	"clkxtal",
++	"clkxtal",
++	"univpll2_d8",
++	"syspll1_d8",
++	"univpll1_d8",
++	"syspll4_d2",
++	"univpll2_d4",
++	"univpll3_d2",
++	"syspll1_d4"
++};
++
++static const char * const flash_parents[] = {
++	"clkxtal",
++	"univpll_d80_d4",
++	"syspll2_d8",
++	"syspll3_d4",
++	"univpll3_d4",
++	"univpll1_d8",
++	"syspll2_d4",
++	"univpll2_d4"
++};
++
++static const char * const uart_parents[] = {
++	"clkxtal",
++	"univpll2_d8"
++};
++
++static const char * const spi0_parents[] = {
++	"clkxtal",
++	"syspll3_d2",
++	"clkxtal",
++	"syspll2_d4",
++	"syspll4_d2",
++	"univpll2_d4",
++	"univpll1_d8",
++	"clkxtal"
++};
++
++static const char * const spi1_parents[] = {
++	"clkxtal",
++	"syspll3_d2",
++	"clkxtal",
++	"syspll4_d4",
++	"syspll4_d2",
++	"univpll2_d4",
++	"univpll1_d8",
++	"clkxtal"
++};
++
++static const char * const msdc30_0_parents[] = {
++	"clkxtal",
++	"univpll2_d16",
++	"univ48m"
++};
++
++static const char * const a1sys_hp_parents[] = {
++	"clkxtal",
++	"aud1pll_ck",
++	"aud2pll_ck",
++	"clkxtal"
++};
++
++static const char * const intdir_parents[] = {
++	"clkxtal",
++	"syspll_d2",
++	"univpll_d2",
++	"sgmiipll_ck"
++};
++
++static const char * const aud_intbus_parents[] = {
++	"clkxtal",
++	"syspll1_d4",
++	"syspll4_d2",
++	"syspll3_d2"
++};
++
++static const char * const pmicspi_parents[] = {
++	"clkxtal",
++	"clk_null",
++	"clk_null",
++	"clk_null",
++	"clk_null",
++	"univpll2_d16"
++};
++
++static const char * const atb_parents[] = {
++	"clkxtal",
++	"syspll1_d2",
++	"syspll_d5"
++};
++
++static const char * const audio_parents[] = {
++	"clkxtal",
++	"syspll3_d4",
++	"syspll4_d4",
++	"univpll1_d16"
++};
++
++static const char * const usb20_parents[] = {
++	"clkxtal",
++	"univpll3_d4",
++	"syspll1_d8",
++	"clkxtal"
++};
++
++static const char * const aud1_parents[] = {
++	"clkxtal",
++	"aud1pll_ck"
++};
++
++static const char * const aud2_parents[] = {
++	"clkxtal",
++	"aud2pll_ck"
++};
++
++static const char * const asm_l_parents[] = {
++	"clkxtal",
++	"syspll_d5",
++	"univpll2_d2",
++	"univpll2_d4"
++};
++
++static const char * const apll1_ck_parents[] = {
++	"aud1_sel",
++	"aud2_sel"
++};
++
++static const char * const peribus_ck_parents[] = {
++	"syspll1_d8",
++	"syspll1_d4"
++};
++
++static const struct mtk_gate_regs apmixed_cg_regs = {
++	.set_ofs = 0x8,
++	.clr_ofs = 0x8,
++	.sta_ofs = 0x8,
++};
++
++static const struct mtk_gate_regs infra_cg_regs = {
++	.set_ofs = 0x40,
++	.clr_ofs = 0x44,
++	.sta_ofs = 0x48,
++};
++
++static const struct mtk_gate_regs top0_cg_regs = {
++	.set_ofs = 0x120,
++	.clr_ofs = 0x120,
++	.sta_ofs = 0x120,
++};
++
++static const struct mtk_gate_regs top1_cg_regs = {
++	.set_ofs = 0x128,
++	.clr_ofs = 0x128,
++	.sta_ofs = 0x128,
++};
++
++static const struct mtk_gate_regs peri0_cg_regs = {
++	.set_ofs = 0x8,
++	.clr_ofs = 0x10,
++	.sta_ofs = 0x18,
++};
++
++static const struct mtk_gate_regs peri1_cg_regs = {
++	.set_ofs = 0xC,
++	.clr_ofs = 0x14,
++	.sta_ofs = 0x1C,
++};
++
++static const struct mtk_pll_data plls[] = {
++	PLL(CLK_APMIXED_ARMPLL, "armpll", 0x0200, 0x020C, 0x00000001,
++	    PLL_AO, 21, 0x0204, 24, 0, 0x0204, 0),
++	PLL(CLK_APMIXED_MAINPLL, "mainpll", 0x0210, 0x021C, 0x00000001,
++	    HAVE_RST_BAR, 21, 0x0214, 24, 0, 0x0214, 0),
++	PLL(CLK_APMIXED_UNIV2PLL, "univ2pll", 0x0220, 0x022C, 0x00000001,
++	    HAVE_RST_BAR, 7, 0x0224, 24, 0, 0x0224, 14),
++	PLL(CLK_APMIXED_ETH1PLL, "eth1pll", 0x0300, 0x0310, 0x00000001,
++	    0, 21, 0x0300, 1, 0, 0x0304, 0),
++	PLL(CLK_APMIXED_ETH2PLL, "eth2pll", 0x0314, 0x0320, 0x00000001,
++	    0, 21, 0x0314, 1, 0, 0x0318, 0),
++	PLL(CLK_APMIXED_AUD1PLL, "aud1pll", 0x0324, 0x0330, 0x00000001,
++	    0, 31, 0x0324, 1, 0, 0x0328, 0),
++	PLL(CLK_APMIXED_AUD2PLL, "aud2pll", 0x0334, 0x0340, 0x00000001,
++	    0, 31, 0x0334, 1, 0, 0x0338, 0),
++	PLL(CLK_APMIXED_TRGPLL, "trgpll", 0x0344, 0x0354, 0x00000001,
++	    0, 21, 0x0344, 1, 0, 0x0348, 0),
++	PLL(CLK_APMIXED_SGMIPLL, "sgmipll", 0x0358, 0x0368, 0x00000001,
++	    0, 21, 0x0358, 1, 0, 0x035C, 0),
++};
++
++static const struct mtk_gate apmixed_clks[] = {
++	GATE_APMIXED(CLK_APMIXED_MAIN_CORE_EN, "main_core_en", "mainpll", 5),
++};
++
++static const struct mtk_gate infra_clks[] = {
++	GATE_INFRA(CLK_INFRA_DBGCLK_PD, "infra_dbgclk_pd", "axi_sel", 0),
++	GATE_INFRA(CLK_INFRA_TRNG, "trng_ck", "axi_sel", 2),
++	GATE_INFRA(CLK_INFRA_AUDIO_PD, "infra_audio_pd", "aud_intbus_sel", 5),
++	GATE_INFRA(CLK_INFRA_IRRX_PD, "infra_irrx_pd", "irrx_sel", 16),
++	GATE_INFRA(CLK_INFRA_APXGPT_PD, "infra_apxgpt_pd", "f10m_ref_sel", 18),
++	GATE_INFRA(CLK_INFRA_PMIC_PD, "infra_pmic_pd", "pmicspi_sel", 22),
++};
++
++static const struct mtk_fixed_clk top_fixed_clks[] = {
++	FIXED_CLK(CLK_TOP_TO_U2_PHY, "to_u2_phy", "clkxtal",
++		  31250000),
++	FIXED_CLK(CLK_TOP_TO_U2_PHY_1P, "to_u2_phy_1p", "clkxtal",
++		  31250000),
++	FIXED_CLK(CLK_TOP_PCIE0_PIPE_EN, "pcie0_pipe_en", "clkxtal",
++		  125000000),
++	FIXED_CLK(CLK_TOP_PCIE1_PIPE_EN, "pcie1_pipe_en", "clkxtal",
++		  125000000),
++	FIXED_CLK(CLK_TOP_SSUSB_TX250M, "ssusb_tx250m", "clkxtal",
++		  250000000),
++	FIXED_CLK(CLK_TOP_SSUSB_EQ_RX250M, "ssusb_eq_rx250m", "clkxtal",
++		  250000000),
++	FIXED_CLK(CLK_TOP_SSUSB_CDR_REF, "ssusb_cdr_ref", "clkxtal",
++		  33333333),
++	FIXED_CLK(CLK_TOP_SSUSB_CDR_FB, "ssusb_cdr_fb", "clkxtal",
++		  50000000),
++	FIXED_CLK(CLK_TOP_SATA_ASIC, "sata_asic", "clkxtal",
++		  50000000),
++	FIXED_CLK(CLK_TOP_SATA_RBC, "sata_rbc", "clkxtal",
++		  50000000),
++};
++
++static const struct mtk_fixed_factor top_divs[] = {
++	FACTOR(CLK_TOP_TO_USB3_SYS, "to_usb3_sys", "eth1pll", 1, 4),
++	FACTOR(CLK_TOP_P1_1MHZ, "p1_1mhz", "eth1pll", 1, 500),
++	FACTOR(CLK_TOP_4MHZ, "free_run_4mhz", "eth1pll", 1, 125),
++	FACTOR(CLK_TOP_P0_1MHZ, "p0_1mhz", "eth1pll", 1, 500),
++	FACTOR(CLK_TOP_TXCLK_SRC_PRE, "txclk_src_pre", "sgmiipll_d2", 1, 1),
++	FACTOR(CLK_TOP_RTC, "rtc", "clkxtal", 1, 1024),
++	FACTOR(CLK_TOP_MEMPLL, "mempll", "clkxtal", 32, 1),
++	FACTOR(CLK_TOP_DMPLL, "dmpll_ck", "mempll", 1, 1),
++	FACTOR(CLK_TOP_SYSPLL_D2, "syspll_d2", "mainpll", 1, 2),
++	FACTOR(CLK_TOP_SYSPLL1_D2, "syspll1_d2", "mainpll", 1, 4),
++	FACTOR(CLK_TOP_SYSPLL1_D4, "syspll1_d4", "mainpll", 1, 8),
++	FACTOR(CLK_TOP_SYSPLL1_D8, "syspll1_d8", "mainpll", 1, 16),
++	FACTOR(CLK_TOP_SYSPLL2_D4, "syspll2_d4", "mainpll", 1, 12),
++	FACTOR(CLK_TOP_SYSPLL2_D8, "syspll2_d8", "mainpll", 1, 24),
++	FACTOR(CLK_TOP_SYSPLL_D5, "syspll_d5", "mainpll", 1, 5),
++	FACTOR(CLK_TOP_SYSPLL3_D2, "syspll3_d2", "mainpll", 1, 10),
++	FACTOR(CLK_TOP_SYSPLL3_D4, "syspll3_d4", "mainpll", 1, 20),
++	FACTOR(CLK_TOP_SYSPLL4_D2, "syspll4_d2", "mainpll", 1, 14),
++	FACTOR(CLK_TOP_SYSPLL4_D4, "syspll4_d4", "mainpll", 1, 28),
++	FACTOR(CLK_TOP_SYSPLL4_D16, "syspll4_d16", "mainpll", 1, 112),
++	FACTOR(CLK_TOP_UNIVPLL, "univpll", "univ2pll", 1, 2),
++	FACTOR(CLK_TOP_UNIVPLL_D2, "univpll_d2", "univpll", 1, 2),
++	FACTOR(CLK_TOP_UNIVPLL1_D2, "univpll1_d2", "univpll", 1, 4),
++	FACTOR(CLK_TOP_UNIVPLL1_D4, "univpll1_d4", "univpll", 1, 8),
++	FACTOR(CLK_TOP_UNIVPLL1_D8, "univpll1_d8", "univpll", 1, 16),
++	FACTOR(CLK_TOP_UNIVPLL1_D16, "univpll1_d16", "univpll", 1, 32),
++	FACTOR(CLK_TOP_UNIVPLL2_D2, "univpll2_d2", "univpll", 1, 6),
++	FACTOR(CLK_TOP_UNIVPLL2_D4, "univpll2_d4", "univpll", 1, 12),
++	FACTOR(CLK_TOP_UNIVPLL2_D8, "univpll2_d8", "univpll", 1, 24),
++	FACTOR(CLK_TOP_UNIVPLL2_D16, "univpll2_d16", "univpll", 1, 48),
++	FACTOR(CLK_TOP_UNIVPLL_D5, "univpll_d5", "univpll", 1, 5),
++	FACTOR(CLK_TOP_UNIVPLL3_D2, "univpll3_d2", "univpll", 1, 10),
++	FACTOR(CLK_TOP_UNIVPLL3_D4, "univpll3_d4", "univpll", 1, 20),
++	FACTOR(CLK_TOP_UNIVPLL3_D16, "univpll3_d16", "univpll", 1, 80),
++	FACTOR(CLK_TOP_UNIVPLL_D7, "univpll_d7", "univpll", 1, 7),
++	FACTOR(CLK_TOP_UNIVPLL_D80_D4, "univpll_d80_d4", "univpll", 1, 320),
++	FACTOR(CLK_TOP_UNIV48M, "univ48m", "univpll", 1, 25),
++	FACTOR(CLK_TOP_SGMIIPLL, "sgmiipll_ck", "sgmipll", 1, 1),
++	FACTOR(CLK_TOP_SGMIIPLL_D2, "sgmiipll_d2", "sgmipll", 1, 2),
++	FACTOR(CLK_TOP_AUD1PLL, "aud1pll_ck", "aud1pll", 1, 1),
++	FACTOR(CLK_TOP_AUD2PLL, "aud2pll_ck", "aud2pll", 1, 1),
++	FACTOR(CLK_TOP_AUD_I2S2_MCK, "aud_i2s2_mck", "i2s2_mck_sel", 1, 2),
++	FACTOR(CLK_TOP_TO_USB3_REF, "to_usb3_ref", "univpll2_d4", 1, 4),
++	FACTOR(CLK_TOP_PCIE1_MAC_EN, "pcie1_mac_en", "univpll1_d4", 1, 1),
++	FACTOR(CLK_TOP_PCIE0_MAC_EN, "pcie0_mac_en", "univpll1_d4", 1, 1),
++	FACTOR(CLK_TOP_ETH_500M, "eth_500m", "eth1pll", 1, 1),
++};
++
++static const struct mtk_gate top_clks[] = {
++	/* TOP0 */
++	GATE_TOP0(CLK_TOP_APLL1_DIV_PD, "apll1_ck_div_pd", "apll1_ck_div", 0),
++	GATE_TOP0(CLK_TOP_APLL2_DIV_PD, "apll2_ck_div_pd", "apll2_ck_div", 1),
++	GATE_TOP0(CLK_TOP_I2S0_MCK_DIV_PD, "i2s0_mck_div_pd", "i2s0_mck_div",
++		  2),
++	GATE_TOP0(CLK_TOP_I2S1_MCK_DIV_PD, "i2s1_mck_div_pd", "i2s1_mck_div",
++		  3),
++	GATE_TOP0(CLK_TOP_I2S2_MCK_DIV_PD, "i2s2_mck_div_pd", "i2s2_mck_div",
++		  4),
++	GATE_TOP0(CLK_TOP_I2S3_MCK_DIV_PD, "i2s3_mck_div_pd", "i2s3_mck_div",
++		  5),
++
++	/* TOP1 */
++	GATE_TOP1(CLK_TOP_A1SYS_HP_DIV_PD, "a1sys_div_pd", "a1sys_div", 0),
++	GATE_TOP1(CLK_TOP_A2SYS_HP_DIV_PD, "a2sys_div_pd", "a2sys_div", 16),
++};
++
++static const struct mtk_clk_divider top_adj_divs[] = {
++	DIV_ADJ(CLK_TOP_APLL1_DIV, "apll1_ck_div", "apll1_ck_sel",
++		0x120, 24, 3),
++	DIV_ADJ(CLK_TOP_APLL2_DIV, "apll2_ck_div", "apll2_ck_sel",
++		0x120, 28, 3),
++	DIV_ADJ(CLK_TOP_I2S0_MCK_DIV, "i2s0_mck_div", "i2s0_mck_sel",
++		0x124, 0, 7),
++	DIV_ADJ(CLK_TOP_I2S1_MCK_DIV, "i2s1_mck_div", "i2s1_mck_sel",
++		0x124, 8, 7),
++	DIV_ADJ(CLK_TOP_I2S2_MCK_DIV, "i2s2_mck_div", "aud_i2s2_mck",
++		0x124, 16, 7),
++	DIV_ADJ(CLK_TOP_I2S3_MCK_DIV, "i2s3_mck_div", "i2s3_mck_sel",
++		0x124, 24, 7),
++	DIV_ADJ(CLK_TOP_A1SYS_HP_DIV, "a1sys_div", "a1sys_hp_sel",
++		0x128, 8, 7),
++	DIV_ADJ(CLK_TOP_A2SYS_HP_DIV, "a2sys_div", "a2sys_hp_sel",
++		0x128, 24, 7),
++};
++
++static const struct mtk_gate peri_clks[] = {
++	/* PERI0 */
++	GATE_PERI0(CLK_PERI_THERM_PD, "peri_therm_pd", "axi_sel", 1),
++	GATE_PERI0(CLK_PERI_PWM1_PD, "peri_pwm1_pd", "clkxtal", 2),
++	GATE_PERI0(CLK_PERI_PWM2_PD, "peri_pwm2_pd", "clkxtal", 3),
++	GATE_PERI0(CLK_PERI_PWM3_PD, "peri_pwm3_pd", "clkxtal", 4),
++	GATE_PERI0(CLK_PERI_PWM4_PD, "peri_pwm4_pd", "clkxtal", 5),
++	GATE_PERI0(CLK_PERI_PWM5_PD, "peri_pwm5_pd", "clkxtal", 6),
++	GATE_PERI0(CLK_PERI_PWM6_PD, "peri_pwm6_pd", "clkxtal", 7),
++	GATE_PERI0(CLK_PERI_PWM7_PD, "peri_pwm7_pd", "clkxtal", 8),
++	GATE_PERI0(CLK_PERI_PWM_PD, "peri_pwm_pd", "clkxtal", 9),
++	GATE_PERI0(CLK_PERI_AP_DMA_PD, "peri_ap_dma_pd", "axi_sel", 12),
++	GATE_PERI0(CLK_PERI_MSDC30_0_PD, "peri_msdc30_0", "msdc30_0_sel", 13),
++	GATE_PERI0(CLK_PERI_MSDC30_1_PD, "peri_msdc30_1", "msdc30_1_sel", 14),
++	GATE_PERI0(CLK_PERI_UART0_PD, "peri_uart0_pd", "axi_sel", 17),
++	GATE_PERI0(CLK_PERI_UART1_PD, "peri_uart1_pd", "axi_sel", 18),
++	GATE_PERI0(CLK_PERI_UART2_PD, "peri_uart2_pd", "axi_sel", 19),
++	GATE_PERI0(CLK_PERI_UART3_PD, "peri_uart3_pd", "axi_sel", 20),
++	GATE_PERI0(CLK_PERI_UART4_PD, "peri_uart4_pd", "axi_sel", 21),
++	GATE_PERI0(CLK_PERI_BTIF_PD, "peri_btif_pd", "axi_sel", 22),
++	GATE_PERI0(CLK_PERI_I2C0_PD, "peri_i2c0_pd", "axi_sel", 23),
++	GATE_PERI0(CLK_PERI_I2C1_PD, "peri_i2c1_pd", "axi_sel", 24),
++	GATE_PERI0(CLK_PERI_I2C2_PD, "peri_i2c2_pd", "axi_sel", 25),
++	GATE_PERI0(CLK_PERI_SPI1_PD, "peri_spi1_pd", "spi1_sel", 26),
++	GATE_PERI0(CLK_PERI_AUXADC_PD, "peri_auxadc_pd", "clkxtal", 27),
++	GATE_PERI0(CLK_PERI_SPI0_PD, "peri_spi0_pd", "spi0_sel", 28),
++	GATE_PERI0(CLK_PERI_SNFI_PD, "peri_snfi_pd", "nfi_infra_sel", 29),
++	GATE_PERI0(CLK_PERI_NFI_PD, "peri_nfi_pd", "axi_sel", 30),
++	GATE_PERI0(CLK_PERI_NFIECC_PD, "peri_nfiecc_pd", "axi_sel", 31),
++
++	/* PERI1 */
++	GATE_PERI1(CLK_PERI_FLASH_PD, "peri_flash_pd", "flash_sel", 1),
++	GATE_PERI1(CLK_PERI_IRTX_PD, "peri_irtx_pd", "irtx_sel", 2),
++};
++
++static struct mtk_composite infra_muxes[] __initdata = {
++	MUX(CLK_INFRA_MUX1_SEL, "infra_mux1_sel", infra_mux1_parents,
++	    0x000, 2, 2),
++};
++
++static struct mtk_composite top_muxes[] = {
++	/* CLK_CFG_0 */
++	MUX_GATE(CLK_TOP_AXI_SEL, "axi_sel", axi_parents,
++		 0x040, 0, 3, 7),
++	MUX_GATE(CLK_TOP_MEM_SEL, "mem_sel", mem_parents,
++		 0x040, 8, 1, 15),
++	MUX_GATE(CLK_TOP_DDRPHYCFG_SEL, "ddrphycfg_sel", ddrphycfg_parents,
++		 0x040, 16, 1, 23),
++	MUX_GATE(CLK_TOP_ETH_SEL, "eth_sel", eth_parents,
++		 0x040, 24, 3, 31),
++
++	/* CLK_CFG_1 */
++	MUX_GATE(CLK_TOP_PWM_SEL, "pwm_sel", pwm_parents,
++		 0x050, 0, 2, 7),
++	MUX_GATE(CLK_TOP_F10M_REF_SEL, "f10m_ref_sel", f10m_ref_parents,
++		 0x050, 8, 1, 15),
++	MUX_GATE(CLK_TOP_NFI_INFRA_SEL, "nfi_infra_sel", nfi_infra_parents,
++		 0x050, 16, 4, 23),
++	MUX_GATE(CLK_TOP_FLASH_SEL, "flash_sel", flash_parents,
++		 0x050, 24, 3, 31),
++
++	/* CLK_CFG_2 */
++	MUX_GATE(CLK_TOP_UART_SEL, "uart_sel", uart_parents,
++		 0x060, 0, 1, 7),
++	MUX_GATE(CLK_TOP_SPI0_SEL, "spi0_sel", spi0_parents,
++		 0x060, 8, 3, 15),
++	MUX_GATE(CLK_TOP_SPI1_SEL, "spi1_sel", spi1_parents,
++		 0x060, 16, 3, 23),
++	MUX_GATE(CLK_TOP_MSDC50_0_SEL, "msdc50_0_sel", uart_parents,
++		 0x060, 24, 3, 31),
++
++	/* CLK_CFG_3 */
++	MUX_GATE(CLK_TOP_MSDC30_0_SEL, "msdc30_0_sel", msdc30_0_parents,
++		 0x070, 0, 3, 7),
++	MUX_GATE(CLK_TOP_MSDC30_1_SEL, "msdc30_1_sel", msdc30_0_parents,
++		 0x070, 8, 3, 15),
++	MUX_GATE(CLK_TOP_A1SYS_HP_SEL, "a1sys_hp_sel", a1sys_hp_parents,
++		 0x070, 16, 2, 23),
++	MUX_GATE(CLK_TOP_A2SYS_HP_SEL, "a2sys_hp_sel", a1sys_hp_parents,
++		 0x070, 24, 2, 31),
++
++	/* CLK_CFG_4 */
++	MUX_GATE(CLK_TOP_INTDIR_SEL, "intdir_sel", intdir_parents,
++		 0x080, 0, 2, 7),
++	MUX_GATE(CLK_TOP_AUD_INTBUS_SEL, "aud_intbus_sel", aud_intbus_parents,
++		 0x080, 8, 2, 15),
++	MUX_GATE(CLK_TOP_PMICSPI_SEL, "pmicspi_sel", pmicspi_parents,
++		 0x080, 16, 3, 23),
++	MUX_GATE(CLK_TOP_SCP_SEL, "scp_sel", ddrphycfg_parents,
++		 0x080, 24, 2, 31),
++
++	/* CLK_CFG_5 */
++	MUX_GATE(CLK_TOP_ATB_SEL, "atb_sel", atb_parents,
++		 0x090, 0, 2, 7),
++	MUX_GATE(CLK_TOP_HIF_SEL, "hif_sel", eth_parents,
++		 0x090, 8, 3, 15),
++	MUX_GATE(CLK_TOP_AUDIO_SEL, "audio_sel", audio_parents,
++		 0x090, 16, 2, 23),
++	MUX_GATE(CLK_TOP_U2_SEL, "usb20_sel", usb20_parents,
++		 0x090, 24, 2, 31),
++
++	/* CLK_CFG_6 */
++	MUX_GATE(CLK_TOP_AUD1_SEL, "aud1_sel", aud1_parents,
++		 0x0A0, 0, 1, 7),
++	MUX_GATE(CLK_TOP_AUD2_SEL, "aud2_sel", aud2_parents,
++		 0x0A0, 8, 1, 15),
++	MUX_GATE(CLK_TOP_IRRX_SEL, "irrx_sel", f10m_ref_parents,
++		 0x0A0, 16, 1, 23),
++	MUX_GATE(CLK_TOP_IRTX_SEL, "irtx_sel", f10m_ref_parents,
++		 0x0A0, 24, 1, 31),
++
++	/* CLK_CFG_7 */
++	MUX_GATE(CLK_TOP_ASM_L_SEL, "asm_l_sel", asm_l_parents,
++		 0x0B0, 0, 2, 7),
++	MUX_GATE(CLK_TOP_ASM_M_SEL, "asm_m_sel", asm_l_parents,
++		 0x0B0, 8, 2, 15),
++	MUX_GATE(CLK_TOP_ASM_H_SEL, "asm_h_sel", asm_l_parents,
++		 0x0B0, 16, 2, 23),
++
++	/* CLK_AUDDIV_0 */
++	MUX(CLK_TOP_APLL1_SEL, "apll1_ck_sel", apll1_ck_parents,
++	    0x120, 6, 1),
++	MUX(CLK_TOP_APLL2_SEL, "apll2_ck_sel", apll1_ck_parents,
++	    0x120, 7, 1),
++	MUX(CLK_TOP_I2S0_MCK_SEL, "i2s0_mck_sel", apll1_ck_parents,
++	    0x120, 8, 1),
++	MUX(CLK_TOP_I2S1_MCK_SEL, "i2s1_mck_sel", apll1_ck_parents,
++	    0x120, 9, 1),
++	MUX(CLK_TOP_I2S2_MCK_SEL, "i2s2_mck_sel", apll1_ck_parents,
++	    0x120, 10, 1),
++	MUX(CLK_TOP_I2S3_MCK_SEL, "i2s3_mck_sel", apll1_ck_parents,
++	    0x120, 11, 1),
++};
++
++static struct mtk_composite peri_muxes[] = {
++	/* PERI_GLOBALCON_CKSEL */
++	MUX(CLK_PERIBUS_SEL, "peribus_ck_sel", peribus_ck_parents, 0x05C, 0, 1),
++};
++
++static int mtk_topckgen_init(struct platform_device *pdev)
++{
++	struct clk_onecell_data *clk_data;
++	void __iomem *base;
++	struct device_node *node = pdev->dev.of_node;
++	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++
++	base = devm_ioremap_resource(&pdev->dev, res);
++	if (IS_ERR(base))
++		return PTR_ERR(base);
++
++	clk_data = mtk_alloc_clk_data(CLK_TOP_NR_CLK);
++
++	mtk_clk_register_fixed_clks(top_fixed_clks, ARRAY_SIZE(top_fixed_clks),
++				    clk_data);
++
++	mtk_clk_register_factors(top_divs, ARRAY_SIZE(top_divs),
++				 clk_data);
++
++	mtk_clk_register_composites(top_muxes, ARRAY_SIZE(top_muxes),
++				    base, &mt7622_clk_lock, clk_data);
++
++	mtk_clk_register_dividers(top_adj_divs, ARRAY_SIZE(top_adj_divs),
++				  base, &mt7622_clk_lock, clk_data);
++
++	mtk_clk_register_gates(node, top_clks, ARRAY_SIZE(top_clks),
++			       clk_data);
++
++	clk_prepare_enable(clk_data->clks[CLK_TOP_AXI_SEL]);
++	clk_prepare_enable(clk_data->clks[CLK_TOP_MEM_SEL]);
++	clk_prepare_enable(clk_data->clks[CLK_TOP_DDRPHYCFG_SEL]);
++
++	return of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
++}
++
++static int __init mtk_infrasys_init(struct platform_device *pdev)
++{
++	struct device_node *node = pdev->dev.of_node;
++	struct clk_onecell_data *clk_data;
++	int r;
++
++	clk_data = mtk_alloc_clk_data(CLK_INFRA_NR_CLK);
++
++	mtk_clk_register_gates(node, infra_clks, ARRAY_SIZE(infra_clks),
++			       clk_data);
++
++	mtk_clk_register_cpumuxes(node, infra_muxes, ARRAY_SIZE(infra_muxes),
++				  clk_data);
++
++	r = of_clk_add_provider(node, of_clk_src_onecell_get,
++				clk_data);
++	if (r)
++		return r;
++
++	mtk_register_reset_controller(node, 1, 0x30);
++
++	return 0;
++}
++
++static int mtk_apmixedsys_init(struct platform_device *pdev)
++{
++	struct clk_onecell_data *clk_data;
++	struct device_node *node = pdev->dev.of_node;
++
++	clk_data = mtk_alloc_clk_data(CLK_APMIXED_NR_CLK);
++	if (!clk_data)
++		return -ENOMEM;
++
++	mtk_clk_register_plls(node, plls, ARRAY_SIZE(plls),
++			      clk_data);
++
++	mtk_clk_register_gates(node, apmixed_clks,
++			       ARRAY_SIZE(apmixed_clks), clk_data);
++
++	clk_prepare_enable(clk_data->clks[CLK_APMIXED_ARMPLL]);
++	clk_prepare_enable(clk_data->clks[CLK_APMIXED_MAIN_CORE_EN]);
++
++	return of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
++}
++
++static int mtk_pericfg_init(struct platform_device *pdev)
++{
++	struct clk_onecell_data *clk_data;
++	void __iomem *base;
++	int r;
++	struct device_node *node = pdev->dev.of_node;
++	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++
++	base = devm_ioremap_resource(&pdev->dev, res);
++	if (IS_ERR(base))
++		return PTR_ERR(base);
++
++	clk_data = mtk_alloc_clk_data(CLK_PERI_NR_CLK);
++
++	mtk_clk_register_gates(node, peri_clks, ARRAY_SIZE(peri_clks),
++			       clk_data);
++
++	mtk_clk_register_composites(peri_muxes, ARRAY_SIZE(peri_muxes), base,
++				    &mt7622_clk_lock, clk_data);
++
++	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
++	if (r)
++		return r;
++
++	clk_prepare_enable(clk_data->clks[CLK_PERI_UART0_PD]);
++
++	mtk_register_reset_controller(node, 2, 0x0);
++
++	return 0;
++}
++
++static const struct of_device_id of_match_clk_mt7622[] = {
++	{
++		.compatible = "mediatek,mt7622-apmixedsys",
++		.data = mtk_apmixedsys_init,
++	}, {
++		.compatible = "mediatek,mt7622-infracfg",
++		.data = mtk_infrasys_init,
++	}, {
++		.compatible = "mediatek,mt7622-topckgen",
++		.data = mtk_topckgen_init,
++	}, {
++		.compatible = "mediatek,mt7622-pericfg",
++		.data = mtk_pericfg_init,
++	}, {
++		/* sentinel */
++	}
++};
++
++static int clk_mt7622_probe(struct platform_device *pdev)
++{
++	int (*clk_init)(struct platform_device *);
++	int r;
++
++	clk_init = of_device_get_match_data(&pdev->dev);
++	if (!clk_init)
++		return -EINVAL;
++
++	r = clk_init(pdev);
++	if (r)
++		dev_err(&pdev->dev,
++			"could not register clock provider: %s: %d\n",
++			pdev->name, r);
++
++	return r;
++}
++
++static struct platform_driver clk_mt7622_drv = {
++	.probe = clk_mt7622_probe,
++	.driver = {
++		.name = "clk-mt7622",
++		.of_match_table = of_match_clk_mt7622,
++	},
++};
++
++static int clk_mt7622_init(void)
++{
++	return platform_driver_register(&clk_mt7622_drv);
++}
++
++arch_initcall(clk_mt7622_init);
+diff --git a/drivers/clk/mediatek/clk-mtk.h b/drivers/clk/mediatek/clk-mtk.h
+index 210ce8e8025e..f83c2bbb677e 100644
+--- a/drivers/clk/mediatek/clk-mtk.h
++++ b/drivers/clk/mediatek/clk-mtk.h
+@@ -20,6 +20,7 @@
+ #include <linux/clk-provider.h>
+ 
+ struct clk;
++struct clk_onecell_data;
+ 
+ #define MAX_MUX_GATE_BIT	31
+ #define INVALID_MUX_GATE_BIT	(MAX_MUX_GATE_BIT + 1)
+@@ -207,6 +208,8 @@ struct mtk_pll_data {
+ 	uint32_t en_mask;
+ 	uint32_t pd_reg;
+ 	uint32_t tuner_reg;
++	uint32_t tuner_en_reg;
++	uint8_t tuner_en_bit;
+ 	int pd_shift;
+ 	unsigned int flags;
+ 	const struct clk_ops *ops;
+@@ -226,14 +229,7 @@ void mtk_clk_register_plls(struct device_node *node,
+ struct clk *mtk_clk_register_ref2usb_tx(const char *name,
+ 			const char *parent_name, void __iomem *reg);
+ 
+-#ifdef CONFIG_RESET_CONTROLLER
+ void mtk_register_reset_controller(struct device_node *np,
+ 			unsigned int num_regs, int regofs);
+-#else
+-static inline void mtk_register_reset_controller(struct device_node *np,
+-			unsigned int num_regs, int regofs)
+-{
+-}
+-#endif
+ 
+ #endif /* __DRV_CLK_MTK_H */
+diff --git a/drivers/clk/mediatek/clk-pll.c b/drivers/clk/mediatek/clk-pll.c
+index 7598477ff60f..f54e4015b0b1 100644
+--- a/drivers/clk/mediatek/clk-pll.c
++++ b/drivers/clk/mediatek/clk-pll.c
+@@ -47,6 +47,7 @@ struct mtk_clk_pll {
+ 	void __iomem	*pd_addr;
+ 	void __iomem	*pwr_addr;
+ 	void __iomem	*tuner_addr;
++	void __iomem	*tuner_en_addr;
+ 	void __iomem	*pcw_addr;
+ 	const struct mtk_pll_data *data;
+ };
+@@ -227,7 +228,10 @@ static int mtk_pll_prepare(struct clk_hw *hw)
+ 	r |= pll->data->en_mask;
+ 	writel(r, pll->base_addr + REG_CON0);
+ 
+-	if (pll->tuner_addr) {
++	if (pll->tuner_en_addr) {
++		r = readl(pll->tuner_en_addr) | BIT(pll->data->tuner_en_bit);
++		writel(r, pll->tuner_en_addr);
++	} else if (pll->tuner_addr) {
+ 		r = readl(pll->tuner_addr) | AUDPLL_TUNER_EN;
+ 		writel(r, pll->tuner_addr);
+ 	}
+@@ -254,7 +258,10 @@ static void mtk_pll_unprepare(struct clk_hw *hw)
+ 		writel(r, pll->base_addr + REG_CON0);
+ 	}
+ 
+-	if (pll->tuner_addr) {
++	if (pll->tuner_en_addr) {
++		r = readl(pll->tuner_en_addr) & ~BIT(pll->data->tuner_en_bit);
++		writel(r, pll->tuner_en_addr);
++	} else if (pll->tuner_addr) {
+ 		r = readl(pll->tuner_addr) & ~AUDPLL_TUNER_EN;
+ 		writel(r, pll->tuner_addr);
+ 	}
+@@ -297,6 +304,8 @@ static struct clk *mtk_clk_register_pll(const struct mtk_pll_data *data,
+ 	pll->pcw_addr = base + data->pcw_reg;
+ 	if (data->tuner_reg)
+ 		pll->tuner_addr = base + data->tuner_reg;
++	if (data->tuner_en_reg)
++		pll->tuner_en_addr = base + data->tuner_en_reg;
+ 	pll->hw.init = &init;
+ 	pll->data = data;
+ 
+diff --git a/drivers/net/dsa/mt7530.c b/drivers/net/dsa/mt7530.c
+index 3b073e152237..d8407a72d676 100644
+--- a/drivers/net/dsa/mt7530.c
++++ b/drivers/net/dsa/mt7530.c
+@@ -670,10 +670,18 @@ static int
+ mt7530_cpu_port_enable(struct mt7530_priv *priv,
+ 		       int port)
+ {
++	u8 port_mask = 0;
++	int i;
++
+ 	/* Enable Mediatek header mode on the cpu port */
+ 	mt7530_write(priv, MT7530_PVC_P(port),
+ 		     PORT_SPEC_TAG);
+ 
++	/* Enable Mediatek header mode on the GMAC that the cpu port
++	 * connects to */
++	regmap_write_bits(priv->ethernet, MTK_GDMA_FWD_CFG(port),
++			  GDMA_SPEC_TAG, GDMA_SPEC_TAG);
++
+ 	/* Setup the MAC by default for the cpu port */
+ 	mt7530_write(priv, MT7530_PMCR_P(port), PMCR_CPUP_LINK);
+ 
+@@ -686,8 +694,12 @@ mt7530_cpu_port_enable(struct mt7530_priv *priv,
+ 	/* CPU port gets connected to all user ports of
+ 	 * the switch
+ 	 */
++	for (i = 0; i < MT7530_NUM_PORTS; i++)
++		if ((priv->ds->enabled_port_mask & BIT(i)) &&
++		    (dsa_port_upstream_port(priv->ds, i) == port))
++			port_mask |= BIT(i);
+ 	mt7530_write(priv, MT7530_PCR_P(port),
+-		     PCR_MATRIX(priv->ds->enabled_port_mask));
++		     PCR_MATRIX(port_mask));
+ 
+ 	return 0;
+ }
+@@ -697,6 +709,7 @@ mt7530_port_enable(struct dsa_switch *ds, int port,
+ 		   struct phy_device *phy)
+ {
+ 	struct mt7530_priv *priv = ds->priv;
++	u8 upstream = dsa_port_upstream_port(ds, port);
+ 
+ 	mutex_lock(&priv->reg_mutex);
+ 
+@@ -707,7 +720,7 @@ mt7530_port_enable(struct dsa_switch *ds, int port,
+ 	 * restore the port matrix if the port is the member of a certain
+ 	 * bridge.
+ 	 */
+-	priv->ports[port].pm |= PCR_MATRIX(BIT(MT7530_CPU_PORT));
++	priv->ports[port].pm |= PCR_MATRIX(BIT(upstream));
+ 	priv->ports[port].enable = true;
+ 	mt7530_rmw(priv, MT7530_PCR_P(port), PCR_MATRIX_MASK,
+ 		   priv->ports[port].pm);
+@@ -770,7 +783,8 @@ mt7530_port_bridge_join(struct dsa_switch *ds, int port,
+ 			struct net_device *bridge)
+ {
+ 	struct mt7530_priv *priv = ds->priv;
+-	u32 port_bitmap = BIT(MT7530_CPU_PORT);
++	u8 upstream = dsa_port_upstream_port(ds, port);
++	u32 port_bitmap = BIT(upstream);
+ 	int i;
+ 
+ 	mutex_lock(&priv->reg_mutex);
+@@ -808,6 +822,7 @@ mt7530_port_bridge_leave(struct dsa_switch *ds, int port,
+ 			 struct net_device *bridge)
+ {
+ 	struct mt7530_priv *priv = ds->priv;
++	u8 upstream = dsa_port_upstream_port(ds, port);
+ 	int i;
+ 
+ 	mutex_lock(&priv->reg_mutex);
+@@ -832,8 +847,8 @@ mt7530_port_bridge_leave(struct dsa_switch *ds, int port,
+ 	 */
+ 	if (priv->ports[port].enable)
+ 		mt7530_rmw(priv, MT7530_PCR_P(port), PCR_MATRIX_MASK,
+-			   PCR_MATRIX(BIT(MT7530_CPU_PORT)));
+-	priv->ports[port].pm = PCR_MATRIX(BIT(MT7530_CPU_PORT));
++			   PCR_MATRIX(BIT(upstream)));
++	priv->ports[port].pm = PCR_MATRIX(BIT(upstream));
+ 
+ 	mutex_unlock(&priv->reg_mutex);
+ }
+@@ -908,15 +923,7 @@ mt7530_port_fdb_dump(struct dsa_switch *ds, int port,
+ static enum dsa_tag_protocol
+ mtk_get_tag_protocol(struct dsa_switch *ds)
+ {
+-	struct mt7530_priv *priv = ds->priv;
+-
+-	if (!dsa_is_cpu_port(ds, MT7530_CPU_PORT)) {
+-		dev_warn(priv->dev,
+-			 "port not matched with tagging CPU port\n");
+-		return DSA_TAG_PROTO_NONE;
+-	} else {
+-		return DSA_TAG_PROTO_MTK;
+-	}
++	return DSA_TAG_PROTO_MTK;
+ }
+ 
+ static int
+@@ -989,8 +996,13 @@ mt7530_setup(struct dsa_switch *ds)
+ 
+ 	/* Enable Port 6 only; P5 as GMAC5 which currently is not supported */
+ 	val = mt7530_read(priv, MT7530_MHWTRAP);
+-	val &= ~MHWTRAP_P6_DIS & ~MHWTRAP_PHY_ACCESS;
++	val &= ~MHWTRAP_P5_DIS & ~MHWTRAP_P6_DIS & ~MHWTRAP_PHY_ACCESS;
+ 	val |= MHWTRAP_MANUAL;
++	if (!dsa_is_cpu_port(ds, 5)) {
++		val |= MHWTRAP_P5_DIS;
++		val |= MHWTRAP_P5_MAC_SEL;
++		val |= MHWTRAP_P5_RGMII_MODE;
++	}
+ 	mt7530_write(priv, MT7530_MHWTRAP, val);
+ 
+ 	/* Enable and reset MIB counters */
+@@ -1037,10 +1049,10 @@ static const struct dsa_switch_ops mt7530_switch_ops = {
+ };
+ 
+ static int
+-mt7530_probe(struct mdio_device *mdiodev)
++mt7530_probe(struct platform_device *mdiodev)
+ {
+ 	struct mt7530_priv *priv;
+-	struct device_node *dn;
++	struct device_node *dn, *mdio;
+ 
+ 	dn = mdiodev->dev.of_node;
+ 
+@@ -1088,7 +1100,12 @@ mt7530_probe(struct mdio_device *mdiodev)
+ 		}
+ 	}
+ 
+-	priv->bus = mdiodev->bus;
++	mdio = of_parse_phandle(dn, "dsa,mii-bus", 0);
++	if (!mdio)
++		return -EINVAL;
++	priv->bus = of_mdio_find_bus(mdio);
++	if (!priv->bus)
++		return -EPROBE_DEFER;
+ 	priv->dev = &mdiodev->dev;
+ 	priv->ds->priv = priv;
+ 	priv->ds->ops = &mt7530_switch_ops;
+@@ -1098,8 +1115,8 @@ mt7530_probe(struct mdio_device *mdiodev)
+ 	return dsa_register_switch(priv->ds);
+ }
+ 
+-static void
+-mt7530_remove(struct mdio_device *mdiodev)
++static int
++mt7530_remove(struct platform_device *mdiodev)
+ {
+ 	struct mt7530_priv *priv = dev_get_drvdata(&mdiodev->dev);
+ 	int ret = 0;
+@@ -1116,6 +1133,8 @@ mt7530_remove(struct mdio_device *mdiodev)
+ 
+ 	dsa_unregister_switch(priv->ds);
+ 	mutex_destroy(&priv->reg_mutex);
++
++	return 0;
+ }
+ 
+ static const struct of_device_id mt7530_of_match[] = {
+@@ -1124,16 +1143,16 @@ static const struct of_device_id mt7530_of_match[] = {
+ };
+ MODULE_DEVICE_TABLE(of, mt7530_of_match);
+ 
+-static struct mdio_driver mt7530_mdio_driver = {
++static struct platform_driver mtk_mt7530_driver = {
+ 	.probe  = mt7530_probe,
+ 	.remove = mt7530_remove,
+-	.mdiodrv.driver = {
++	.driver = {
+ 		.name = "mt7530",
+ 		.of_match_table = mt7530_of_match,
+ 	},
+ };
++module_platform_driver(mtk_mt7530_driver);
+ 
+-mdio_module_driver(mt7530_mdio_driver);
+ 
+ MODULE_AUTHOR("Sean Wang <sean.wang@mediatek.com>");
+ MODULE_DESCRIPTION("Driver for Mediatek MT7530 Switch");
+diff --git a/drivers/net/dsa/mt7530.h b/drivers/net/dsa/mt7530.h
+index 74db9822eb40..8fd7d78d785a 100644
+--- a/drivers/net/dsa/mt7530.h
++++ b/drivers/net/dsa/mt7530.h
+@@ -22,6 +22,10 @@
+ 
+ #define TRGMII_BASE(x)			(0x10000 + (x))
+ 
++/* Registers for GDMA configuration access */
++#define MTK_GDMA_FWD_CFG(x)		(0x500 + (x * 0x1000))
++#define GDMA_SPEC_TAG			BIT(24)
++
+ /* Registers to ethsys access */
+ #define ETHSYS_CLKCFG0			0x2c
+ #define  ETHSYS_TRGMII_CLK_SEL362_5	BIT(11)
+diff --git a/drivers/net/ethernet/mtk/Kconfig b/drivers/net/ethernet/mtk/Kconfig
+index 822806fd856f..f9149d2a4694 100644
+--- a/drivers/net/ethernet/mtk/Kconfig
++++ b/drivers/net/ethernet/mtk/Kconfig
+@@ -1,70 +1,17 @@
+ config NET_VENDOR_MEDIATEK
+-	tristate "Mediatek/Ralink ethernet driver"
+-	depends on RALINK
+-	help
+-	  This driver supports the ethernet mac inside the Mediatek and Ralink WiSoCs
++	bool "MediaTek ethernet driver"
++	depends on ARCH_MEDIATEK
++	---help---
++	  If you have a Mediatek SoC with ethernet, say Y.
+ 
+-config NET_MEDIATEK_SOC
+-	def_tristate NET_VENDOR_MEDIATEK
+-
+-if NET_MEDIATEK_SOC
+-choice
+-	prompt "MAC type"
+-
+-config NET_MEDIATEK_RT2880
+-	bool "RT2882"
+-	depends on MIPS && SOC_RT288X
+-
+-config NET_MEDIATEK_RT3050
+-	bool "RT3050/MT7628"
+-	depends on MIPS && (SOC_RT305X || SOC_MT7620)
+-
+-config NET_MEDIATEK_RT3883
+-	bool "RT3883"
+-	depends on MIPS && SOC_RT3883
+-
+-config NET_MEDIATEK_MT7620
+-	bool "MT7620"
+-	depends on MIPS && SOC_MT7620
+-
+-config NET_MEDIATEK_MT7621
+-	bool "MT7621"
+-	depends on MIPS && SOC_MT7621
+-
+-endchoice
++if NET_VENDOR_MEDIATEK
+ 
+-config NET_MEDIATEK_OFFLOAD
+-	def_bool NET_MEDIATEK_SOC
+-	depends on NET_MEDIATEK_MT7621
+-
+-config NET_MEDIATEK_HW_QOS
+-	def_bool NET_MEDIATEK_SOC
+-	depends on NET_MEDIATEK_MT7623
+-
+-config NET_MEDIATEK_MDIO
+-	def_bool NET_MEDIATEK_SOC
+-	depends on (NET_MEDIATEK_RT2880 || NET_MEDIATEK_RT3883 || NET_MEDIATEK_MT7620 || NET_MEDIATEK_MT7621)
++config NET_MEDIATEK_SOC
++	tristate "MediaTek SoC Gigabit Ethernet support"
++	depends on NET_VENDOR_MEDIATEK
+ 	select PHYLIB
++	---help---
++	  This driver supports the gigabit ethernet MACs in the
++	  MediaTek SoC family.
+ 
+-config NET_MEDIATEK_MDIO_RT2880
+-	def_bool NET_MEDIATEK_SOC
+-	depends on (NET_MEDIATEK_RT2880 || NET_MEDIATEK_RT3883)
+-	select NET_MEDIATEK_MDIO
+-
+-config NET_MEDIATEK_MDIO_MT7620
+-	def_bool NET_MEDIATEK_SOC
+-	depends on (NET_MEDIATEK_MT7620 || NET_MEDIATEK_MT7621)
+-	select NET_MEDIATEK_MDIO
+-
+-config NET_MEDIATEK_ESW_RT3050
+-	def_tristate NET_MEDIATEK_SOC
+-	depends on NET_MEDIATEK_RT3050
+-
+-config NET_MEDIATEK_GSW_MT7620
+-	def_tristate NET_MEDIATEK_SOC
+-	depends on NET_MEDIATEK_MT7620
+-
+-config NET_MEDIATEK_GSW_MT7621
+-	def_tristate NET_MEDIATEK_SOC
+-	depends on NET_MEDIATEK_MT7621
+-endif
++endif #NET_VENDOR_MEDIATEK
+diff --git a/drivers/net/ethernet/mtk/Makefile b/drivers/net/ethernet/mtk/Makefile
+index b038ae369948..aa3f1c8ccd4a 100644
+--- a/drivers/net/ethernet/mtk/Makefile
++++ b/drivers/net/ethernet/mtk/Makefile
+@@ -1,22 +1,5 @@
+ #
+-# Makefile for the Ralink SoCs built-in ethernet macs
++# Makefile for the Mediatek SoCs built-in ethernet macs
+ #
+ 
+-mtk-eth-soc-y					+= mtk_eth_soc.o ethtool.o
+-
+-mtk-eth-soc-$(CONFIG_NET_MEDIATEK_MDIO)		+= mdio.o
+-mtk-eth-soc-$(CONFIG_NET_MEDIATEK_MDIO_RT2880)	+= mdio_rt2880.o
+-mtk-eth-soc-$(CONFIG_NET_MEDIATEK_MDIO_MT7620)	+= mdio_mt7620.o
+-
+-mtk-eth-soc-$(CONFIG_NET_MEDIATEK_OFFLOAD)	+= mtk_offload.o mtk_debugfs.o
+-
+-mtk-eth-soc-$(CONFIG_NET_MEDIATEK_RT2880)	+= soc_rt2880.o
+-mtk-eth-soc-$(CONFIG_NET_MEDIATEK_RT3050)	+= soc_rt3050.o
+-mtk-eth-soc-$(CONFIG_NET_MEDIATEK_RT3883)	+= soc_rt3883.o
+-mtk-eth-soc-$(CONFIG_NET_MEDIATEK_MT7620)	+= soc_mt7620.o
+-mtk-eth-soc-$(CONFIG_NET_MEDIATEK_MT7621)	+= soc_mt7621.o
+-
+-obj-$(CONFIG_NET_MEDIATEK_ESW_RT3050)		+= esw_rt3050.o
+-obj-$(CONFIG_NET_MEDIATEK_GSW_MT7620)		+= gsw_mt7620.o mt7530.o
+-obj-$(CONFIG_NET_MEDIATEK_GSW_MT7621)		+= gsw_mt7621.o mt7530.o
+-obj-$(CONFIG_NET_MEDIATEK_SOC)			+= mtk-eth-soc.o
++obj-$(CONFIG_NET_MEDIATEK_SOC)			+= mtk_eth_soc.o
+diff --git a/drivers/net/ethernet/mtk/esw_rt3050.c b/drivers/net/ethernet/mtk/esw_rt3050.c
+deleted file mode 100644
+index 816c588dd7f2..000000000000
+--- a/drivers/net/ethernet/mtk/esw_rt3050.c
++++ /dev/null
+@@ -1,1461 +0,0 @@
+-/*   This program is free software; you can redistribute it and/or modify
+- *   it under the terms of the GNU General Public License as published by
+- *   the Free Software Foundation; version 2 of the License
+- *
+- *   This program is distributed in the hope that it will be useful,
+- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+- *   GNU General Public License for more details.
+- *
+- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
+- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
+- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
+- *   Copyright (C) 2016 Vittorio Gambaletta <openwrt@vittgam.net>
+- */
+-
+-#include <linux/module.h>
+-#include <linux/kernel.h>
+-#include <linux/platform_device.h>
+-#include <asm/mach-ralink/ralink_regs.h>
+-#include <linux/of_irq.h>
+-
+-#include <linux/switch.h>
+-
+-#include "mtk_eth_soc.h"
+-
+-/* HW limitations for this switch:
+- * - No large frame support (PKT_MAX_LEN at most 1536)
+- * - Can't have untagged vlan and tagged vlan on one port at the same time,
+- *   though this might be possible using the undocumented PPE.
+- */
+-
+-#define RT305X_ESW_REG_ISR		0x00
+-#define RT305X_ESW_REG_IMR		0x04
+-#define RT305X_ESW_REG_FCT0		0x08
+-#define RT305X_ESW_REG_PFC1		0x14
+-#define RT305X_ESW_REG_ATS		0x24
+-#define RT305X_ESW_REG_ATS0		0x28
+-#define RT305X_ESW_REG_ATS1		0x2c
+-#define RT305X_ESW_REG_ATS2		0x30
+-#define RT305X_ESW_REG_PVIDC(_n)	(0x40 + 4 * (_n))
+-#define RT305X_ESW_REG_VLANI(_n)	(0x50 + 4 * (_n))
+-#define RT305X_ESW_REG_VMSC(_n)		(0x70 + 4 * (_n))
+-#define RT305X_ESW_REG_POA		0x80
+-#define RT305X_ESW_REG_FPA		0x84
+-#define RT305X_ESW_REG_SOCPC		0x8c
+-#define RT305X_ESW_REG_POC0		0x90
+-#define RT305X_ESW_REG_POC1		0x94
+-#define RT305X_ESW_REG_POC2		0x98
+-#define RT305X_ESW_REG_SGC		0x9c
+-#define RT305X_ESW_REG_STRT		0xa0
+-#define RT305X_ESW_REG_PCR0		0xc0
+-#define RT305X_ESW_REG_PCR1		0xc4
+-#define RT305X_ESW_REG_FPA2		0xc8
+-#define RT305X_ESW_REG_FCT2		0xcc
+-#define RT305X_ESW_REG_SGC2		0xe4
+-#define RT305X_ESW_REG_P0LED		0xa4
+-#define RT305X_ESW_REG_P1LED		0xa8
+-#define RT305X_ESW_REG_P2LED		0xac
+-#define RT305X_ESW_REG_P3LED		0xb0
+-#define RT305X_ESW_REG_P4LED		0xb4
+-#define RT305X_ESW_REG_PXPC(_x)		(0xe8 + (4 * _x))
+-#define RT305X_ESW_REG_P1PC		0xec
+-#define RT305X_ESW_REG_P2PC		0xf0
+-#define RT305X_ESW_REG_P3PC		0xf4
+-#define RT305X_ESW_REG_P4PC		0xf8
+-#define RT305X_ESW_REG_P5PC		0xfc
+-
+-#define RT305X_ESW_LED_LINK		0
+-#define RT305X_ESW_LED_100M		1
+-#define RT305X_ESW_LED_DUPLEX		2
+-#define RT305X_ESW_LED_ACTIVITY		3
+-#define RT305X_ESW_LED_COLLISION	4
+-#define RT305X_ESW_LED_LINKACT		5
+-#define RT305X_ESW_LED_DUPLCOLL		6
+-#define RT305X_ESW_LED_10MACT		7
+-#define RT305X_ESW_LED_100MACT		8
+-/* Additional led states not in datasheet: */
+-#define RT305X_ESW_LED_BLINK		10
+-#define RT305X_ESW_LED_ON		12
+-
+-#define RT305X_ESW_LINK_S		25
+-#define RT305X_ESW_DUPLEX_S		9
+-#define RT305X_ESW_SPD_S		0
+-
+-#define RT305X_ESW_PCR0_WT_NWAY_DATA_S	16
+-#define RT305X_ESW_PCR0_WT_PHY_CMD	BIT(13)
+-#define RT305X_ESW_PCR0_CPU_PHY_REG_S	8
+-
+-#define RT305X_ESW_PCR1_WT_DONE		BIT(0)
+-
+-#define RT305X_ESW_ATS_TIMEOUT		(5 * HZ)
+-#define RT305X_ESW_PHY_TIMEOUT		(5 * HZ)
+-
+-#define RT305X_ESW_PVIDC_PVID_M		0xfff
+-#define RT305X_ESW_PVIDC_PVID_S		12
+-
+-#define RT305X_ESW_VLANI_VID_M		0xfff
+-#define RT305X_ESW_VLANI_VID_S		12
+-
+-#define RT305X_ESW_VMSC_MSC_M		0xff
+-#define RT305X_ESW_VMSC_MSC_S		8
+-
+-#define RT305X_ESW_SOCPC_DISUN2CPU_S	0
+-#define RT305X_ESW_SOCPC_DISMC2CPU_S	8
+-#define RT305X_ESW_SOCPC_DISBC2CPU_S	16
+-#define RT305X_ESW_SOCPC_CRC_PADDING	BIT(25)
+-
+-#define RT305X_ESW_POC0_EN_BP_S		0
+-#define RT305X_ESW_POC0_EN_FC_S		8
+-#define RT305X_ESW_POC0_DIS_RMC2CPU_S	16
+-#define RT305X_ESW_POC0_DIS_PORT_M	0x7f
+-#define RT305X_ESW_POC0_DIS_PORT_S	23
+-
+-#define RT305X_ESW_POC2_UNTAG_EN_M	0xff
+-#define RT305X_ESW_POC2_UNTAG_EN_S	0
+-#define RT305X_ESW_POC2_ENAGING_S	8
+-#define RT305X_ESW_POC2_DIS_UC_PAUSE_S	16
+-
+-#define RT305X_ESW_SGC2_DOUBLE_TAG_M	0x7f
+-#define RT305X_ESW_SGC2_DOUBLE_TAG_S	0
+-#define RT305X_ESW_SGC2_LAN_PMAP_M	0x3f
+-#define RT305X_ESW_SGC2_LAN_PMAP_S	24
+-
+-#define RT305X_ESW_PFC1_EN_VLAN_M	0xff
+-#define RT305X_ESW_PFC1_EN_VLAN_S	16
+-#define RT305X_ESW_PFC1_EN_TOS_S	24
+-
+-#define RT305X_ESW_VLAN_NONE		0xfff
+-
+-#define RT305X_ESW_GSC_BC_STROM_MASK	0x3
+-#define RT305X_ESW_GSC_BC_STROM_SHIFT	4
+-
+-#define RT305X_ESW_GSC_LED_FREQ_MASK	0x3
+-#define RT305X_ESW_GSC_LED_FREQ_SHIFT	23
+-
+-#define RT305X_ESW_POA_LINK_MASK	0x1f
+-#define RT305X_ESW_POA_LINK_SHIFT	25
+-
+-#define RT305X_ESW_PORT_ST_CHG		BIT(26)
+-#define RT305X_ESW_PORT0		0
+-#define RT305X_ESW_PORT1		1
+-#define RT305X_ESW_PORT2		2
+-#define RT305X_ESW_PORT3		3
+-#define RT305X_ESW_PORT4		4
+-#define RT305X_ESW_PORT5		5
+-#define RT305X_ESW_PORT6		6
+-
+-#define RT305X_ESW_PORTS_NONE		0
+-
+-#define RT305X_ESW_PMAP_LLLLLL		0x3f
+-#define RT305X_ESW_PMAP_LLLLWL		0x2f
+-#define RT305X_ESW_PMAP_WLLLLL		0x3e
+-
+-#define RT305X_ESW_PORTS_INTERNAL					\
+-		(BIT(RT305X_ESW_PORT0) | BIT(RT305X_ESW_PORT1) |	\
+-		 BIT(RT305X_ESW_PORT2) | BIT(RT305X_ESW_PORT3) |	\
+-		 BIT(RT305X_ESW_PORT4))
+-
+-#define RT305X_ESW_PORTS_NOCPU						\
+-		(RT305X_ESW_PORTS_INTERNAL | BIT(RT305X_ESW_PORT5))
+-
+-#define RT305X_ESW_PORTS_CPU	BIT(RT305X_ESW_PORT6)
+-
+-#define RT305X_ESW_PORTS_ALL						\
+-		(RT305X_ESW_PORTS_NOCPU | RT305X_ESW_PORTS_CPU)
+-
+-#define RT305X_ESW_NUM_VLANS		16
+-#define RT305X_ESW_NUM_VIDS		4096
+-#define RT305X_ESW_NUM_PORTS		7
+-#define RT305X_ESW_NUM_LANWAN		6
+-#define RT305X_ESW_NUM_LEDS		5
+-
+-#define RT5350_ESW_REG_PXTPC(_x)	(0x150 + (4 * _x))
+-#define RT5350_EWS_REG_LED_POLARITY	0x168
+-#define RT5350_RESET_EPHY		BIT(24)
+-
+-enum {
+-	/* Global attributes. */
+-	RT305X_ESW_ATTR_ENABLE_VLAN,
+-	RT305X_ESW_ATTR_ALT_VLAN_DISABLE,
+-	RT305X_ESW_ATTR_BC_STATUS,
+-	RT305X_ESW_ATTR_LED_FREQ,
+-	/* Port attributes. */
+-	RT305X_ESW_ATTR_PORT_DISABLE,
+-	RT305X_ESW_ATTR_PORT_DOUBLETAG,
+-	RT305X_ESW_ATTR_PORT_UNTAG,
+-	RT305X_ESW_ATTR_PORT_LED,
+-	RT305X_ESW_ATTR_PORT_LAN,
+-	RT305X_ESW_ATTR_PORT_RECV_BAD,
+-	RT305X_ESW_ATTR_PORT_RECV_GOOD,
+-	RT5350_ESW_ATTR_PORT_TR_BAD,
+-	RT5350_ESW_ATTR_PORT_TR_GOOD,
+-};
+-
+-struct esw_port {
+-	bool	disable;
+-	bool	doubletag;
+-	bool	untag;
+-	u8	led;
+-	u16	pvid;
+-};
+-
+-struct esw_vlan {
+-	u8	ports;
+-	u16	vid;
+-};
+-
+-enum {
+-	RT305X_ESW_VLAN_CONFIG_NONE = 0,
+-	RT305X_ESW_VLAN_CONFIG_LLLLW,
+-	RT305X_ESW_VLAN_CONFIG_WLLLL,
+-};
+-
+-struct rt305x_esw {
+-	struct device		*dev;
+-	void __iomem		*base;
+-	int			irq;
+-
+-	/* Protects against concurrent register r/w operations. */
+-	spinlock_t		reg_rw_lock;
+-
+-	unsigned char		port_map;
+-	unsigned char		port_disable;
+-	unsigned int		reg_initval_fct2;
+-	unsigned int		reg_initval_fpa2;
+-	unsigned int		reg_led_polarity;
+-
+-	struct switch_dev	swdev;
+-	bool			global_vlan_enable;
+-	bool			alt_vlan_disable;
+-	int			bc_storm_protect;
+-	int			led_frequency;
+-	struct esw_vlan vlans[RT305X_ESW_NUM_VLANS];
+-	struct esw_port ports[RT305X_ESW_NUM_PORTS];
+-
+-};
+-
+-static inline void esw_w32(struct rt305x_esw *esw, u32 val, unsigned reg)
+-{
+-	__raw_writel(val, esw->base + reg);
+-}
+-
+-static inline u32 esw_r32(struct rt305x_esw *esw, unsigned reg)
+-{
+-	return __raw_readl(esw->base + reg);
+-}
+-
+-static inline void esw_rmw_raw(struct rt305x_esw *esw, unsigned reg,
+-			       unsigned long mask, unsigned long val)
+-{
+-	unsigned long t;
+-
+-	t = __raw_readl(esw->base + reg) & ~mask;
+-	__raw_writel(t | val, esw->base + reg);
+-}
+-
+-static void esw_rmw(struct rt305x_esw *esw, unsigned reg,
+-		    unsigned long mask, unsigned long val)
+-{
+-	unsigned long flags;
+-
+-	spin_lock_irqsave(&esw->reg_rw_lock, flags);
+-	esw_rmw_raw(esw, reg, mask, val);
+-	spin_unlock_irqrestore(&esw->reg_rw_lock, flags);
+-}
+-
+-static u32 rt305x_mii_write(struct rt305x_esw *esw, u32 phy_addr,
+-			    u32 phy_register, u32 write_data)
+-{
+-	unsigned long t_start = jiffies;
+-	int ret = 0;
+-
+-	while (1) {
+-		if (!(esw_r32(esw, RT305X_ESW_REG_PCR1) &
+-		      RT305X_ESW_PCR1_WT_DONE))
+-			break;
+-		if (time_after(jiffies, t_start + RT305X_ESW_PHY_TIMEOUT)) {
+-			ret = 1;
+-			goto out;
+-		}
+-	}
+-
+-	write_data &= 0xffff;
+-	esw_w32(esw, (write_data << RT305X_ESW_PCR0_WT_NWAY_DATA_S) |
+-		      (phy_register << RT305X_ESW_PCR0_CPU_PHY_REG_S) |
+-		      (phy_addr) | RT305X_ESW_PCR0_WT_PHY_CMD,
+-		RT305X_ESW_REG_PCR0);
+-
+-	t_start = jiffies;
+-	while (1) {
+-		if (esw_r32(esw, RT305X_ESW_REG_PCR1) &
+-			    RT305X_ESW_PCR1_WT_DONE)
+-			break;
+-
+-		if (time_after(jiffies, t_start + RT305X_ESW_PHY_TIMEOUT)) {
+-			ret = 1;
+-			break;
+-		}
+-	}
+-out:
+-	if (ret)
+-		dev_err(esw->dev, "ramips_eth: MDIO timeout\n");
+-	return ret;
+-}
+-
+-static unsigned esw_get_vlan_id(struct rt305x_esw *esw, unsigned vlan)
+-{
+-	unsigned s;
+-	unsigned val;
+-
+-	s = RT305X_ESW_VLANI_VID_S * (vlan % 2);
+-	val = esw_r32(esw, RT305X_ESW_REG_VLANI(vlan / 2));
+-	val = (val >> s) & RT305X_ESW_VLANI_VID_M;
+-
+-	return val;
+-}
+-
+-static void esw_set_vlan_id(struct rt305x_esw *esw, unsigned vlan, unsigned vid)
+-{
+-	unsigned s;
+-
+-	s = RT305X_ESW_VLANI_VID_S * (vlan % 2);
+-	esw_rmw(esw,
+-		       RT305X_ESW_REG_VLANI(vlan / 2),
+-		       RT305X_ESW_VLANI_VID_M << s,
+-		       (vid & RT305X_ESW_VLANI_VID_M) << s);
+-}
+-
+-static unsigned esw_get_pvid(struct rt305x_esw *esw, unsigned port)
+-{
+-	unsigned s, val;
+-
+-	s = RT305X_ESW_PVIDC_PVID_S * (port % 2);
+-	val = esw_r32(esw, RT305X_ESW_REG_PVIDC(port / 2));
+-	return (val >> s) & RT305X_ESW_PVIDC_PVID_M;
+-}
+-
+-static void esw_set_pvid(struct rt305x_esw *esw, unsigned port, unsigned pvid)
+-{
+-	unsigned s;
+-
+-	s = RT305X_ESW_PVIDC_PVID_S * (port % 2);
+-	esw_rmw(esw,
+-		       RT305X_ESW_REG_PVIDC(port / 2),
+-		       RT305X_ESW_PVIDC_PVID_M << s,
+-		       (pvid & RT305X_ESW_PVIDC_PVID_M) << s);
+-}
+-
+-static unsigned esw_get_vmsc(struct rt305x_esw *esw, unsigned vlan)
+-{
+-	unsigned s, val;
+-
+-	s = RT305X_ESW_VMSC_MSC_S * (vlan % 4);
+-	val = esw_r32(esw, RT305X_ESW_REG_VMSC(vlan / 4));
+-	val = (val >> s) & RT305X_ESW_VMSC_MSC_M;
+-
+-	return val;
+-}
+-
+-static void esw_set_vmsc(struct rt305x_esw *esw, unsigned vlan, unsigned msc)
+-{
+-	unsigned s;
+-
+-	s = RT305X_ESW_VMSC_MSC_S * (vlan % 4);
+-	esw_rmw(esw,
+-		       RT305X_ESW_REG_VMSC(vlan / 4),
+-		       RT305X_ESW_VMSC_MSC_M << s,
+-		       (msc & RT305X_ESW_VMSC_MSC_M) << s);
+-}
+-
+-static unsigned esw_get_port_disable(struct rt305x_esw *esw)
+-{
+-	unsigned reg;
+-
+-	reg = esw_r32(esw, RT305X_ESW_REG_POC0);
+-	return (reg >> RT305X_ESW_POC0_DIS_PORT_S) &
+-	       RT305X_ESW_POC0_DIS_PORT_M;
+-}
+-
+-static void esw_set_port_disable(struct rt305x_esw *esw, unsigned disable_mask)
+-{
+-	unsigned old_mask;
+-	unsigned enable_mask;
+-	unsigned changed;
+-	int i;
+-
+-	old_mask = esw_get_port_disable(esw);
+-	changed = old_mask ^ disable_mask;
+-	enable_mask = old_mask & disable_mask;
+-
+-	/* enable before writing to MII */
+-	esw_rmw(esw, RT305X_ESW_REG_POC0,
+-		       (RT305X_ESW_POC0_DIS_PORT_M <<
+-			RT305X_ESW_POC0_DIS_PORT_S),
+-		       enable_mask << RT305X_ESW_POC0_DIS_PORT_S);
+-
+-	for (i = 0; i < RT305X_ESW_NUM_LEDS; i++) {
+-		if (!(changed & (1 << i)))
+-			continue;
+-		if (disable_mask & (1 << i)) {
+-			/* disable */
+-			rt305x_mii_write(esw, i, MII_BMCR,
+-					 BMCR_PDOWN);
+-		} else {
+-			/* enable */
+-			rt305x_mii_write(esw, i, MII_BMCR,
+-					 BMCR_FULLDPLX |
+-					 BMCR_ANENABLE |
+-					 BMCR_ANRESTART |
+-					 BMCR_SPEED100);
+-		}
+-	}
+-
+-	/* disable after writing to MII */
+-	esw_rmw(esw, RT305X_ESW_REG_POC0,
+-		       (RT305X_ESW_POC0_DIS_PORT_M <<
+-			RT305X_ESW_POC0_DIS_PORT_S),
+-		       disable_mask << RT305X_ESW_POC0_DIS_PORT_S);
+-}
+-
+-static void esw_set_gsc(struct rt305x_esw *esw)
+-{
+-	esw_rmw(esw, RT305X_ESW_REG_SGC,
+-		RT305X_ESW_GSC_BC_STROM_MASK << RT305X_ESW_GSC_BC_STROM_SHIFT,
+-		esw->bc_storm_protect << RT305X_ESW_GSC_BC_STROM_SHIFT);
+-	esw_rmw(esw, RT305X_ESW_REG_SGC,
+-		RT305X_ESW_GSC_LED_FREQ_MASK << RT305X_ESW_GSC_LED_FREQ_SHIFT,
+-		esw->led_frequency << RT305X_ESW_GSC_LED_FREQ_SHIFT);
+-}
+-
+-static int esw_apply_config(struct switch_dev *dev);
+-
+-static void esw_hw_init(struct rt305x_esw *esw)
+-{
+-	int i;
+-	u8 port_disable = 0;
+-	u8 port_map = RT305X_ESW_PMAP_LLLLLL;
+-
+-	/* vodoo from original driver */
+-	esw_w32(esw, 0xC8A07850, RT305X_ESW_REG_FCT0);
+-	esw_w32(esw, 0x00000000, RT305X_ESW_REG_SGC2);
+-	/* Port priority 1 for all ports, vlan enabled. */
+-	esw_w32(esw, 0x00005555 |
+-		     (RT305X_ESW_PORTS_ALL << RT305X_ESW_PFC1_EN_VLAN_S),
+-		RT305X_ESW_REG_PFC1);
+-
+-	/* Enable all ports, Back Pressure and Flow Control */
+-	esw_w32(esw, ((RT305X_ESW_PORTS_ALL << RT305X_ESW_POC0_EN_BP_S) |
+-		      (RT305X_ESW_PORTS_ALL << RT305X_ESW_POC0_EN_FC_S)),
+-		RT305X_ESW_REG_POC0);
+-
+-	/* Enable Aging, and VLAN TAG removal */
+-	esw_w32(esw, ((RT305X_ESW_PORTS_ALL << RT305X_ESW_POC2_ENAGING_S) |
+-		      (RT305X_ESW_PORTS_NOCPU << RT305X_ESW_POC2_UNTAG_EN_S)),
+-		RT305X_ESW_REG_POC2);
+-
+-	if (esw->reg_initval_fct2)
+-		esw_w32(esw, esw->reg_initval_fct2, RT305X_ESW_REG_FCT2);
+-	else
+-		esw_w32(esw, 0x0002500c, RT305X_ESW_REG_FCT2);
+-
+-	/* 300s aging timer, max packet len 1536, broadcast storm prevention
+-	 * disabled, disable collision abort, mac xor48 hash, 10 packet back
+-	 * pressure jam, GMII disable was_transmit, back pressure disabled,
+-	 * 30ms led flash, unmatched IGMP as broadcast, rmc tb fault to all
+-	 * ports.
+-	 */
+-	esw_w32(esw, 0x0008a301, RT305X_ESW_REG_SGC);
+-
+-	/* Setup SoC Port control register */
+-	esw_w32(esw,
+-		(RT305X_ESW_SOCPC_CRC_PADDING |
+-		(RT305X_ESW_PORTS_CPU << RT305X_ESW_SOCPC_DISUN2CPU_S) |
+-		(RT305X_ESW_PORTS_CPU << RT305X_ESW_SOCPC_DISMC2CPU_S) |
+-		(RT305X_ESW_PORTS_CPU << RT305X_ESW_SOCPC_DISBC2CPU_S)),
+-		RT305X_ESW_REG_SOCPC);
+-
+-	/* ext phy base addr 31, enable port 5 polling, rx/tx clock skew 1,
+-	 * turbo mii off, rgmi 3.3v off
+-	 * port5: disabled
+-	 * port6: enabled, gige, full-duplex, rx/tx-flow-control
+-	 */
+-	if (esw->reg_initval_fpa2)
+-		esw_w32(esw, esw->reg_initval_fpa2, RT305X_ESW_REG_FPA2);
+-	else
+-		esw_w32(esw, 0x3f502b28, RT305X_ESW_REG_FPA2);
+-	esw_w32(esw, 0x00000000, RT305X_ESW_REG_FPA);
+-
+-	/* Force Link/Activity on ports */
+-	esw_w32(esw, 0x00000005, RT305X_ESW_REG_P0LED);
+-	esw_w32(esw, 0x00000005, RT305X_ESW_REG_P1LED);
+-	esw_w32(esw, 0x00000005, RT305X_ESW_REG_P2LED);
+-	esw_w32(esw, 0x00000005, RT305X_ESW_REG_P3LED);
+-	esw_w32(esw, 0x00000005, RT305X_ESW_REG_P4LED);
+-
+-	/* Copy disabled port configuration from device tree setup */
+-	port_disable = esw->port_disable;
+-
+-	/* Disable nonexistent ports by reading the switch config
+-	 * after having enabled all possible ports above
+-	 */
+-	port_disable |= esw_get_port_disable(esw);
+-
+-	for (i = 0; i < 6; i++)
+-		esw->ports[i].disable = (port_disable & (1 << i)) != 0;
+-
+-	if (ralink_soc == RT305X_SOC_RT3352) {
+-		/* reset EPHY */
+-		fe_reset(RT5350_RESET_EPHY);
+-
+-		rt305x_mii_write(esw, 0, 31, 0x8000);
+-		for (i = 0; i < 5; i++) {
+-			if (esw->ports[i].disable) {
+-				rt305x_mii_write(esw, i, MII_BMCR, BMCR_PDOWN);
+-			} else {
+-				rt305x_mii_write(esw, i, MII_BMCR,
+-						 BMCR_FULLDPLX |
+-						 BMCR_ANENABLE |
+-						 BMCR_SPEED100);
+-			}
+-			/* TX10 waveform coefficient LSB=0 disable PHY */
+-			rt305x_mii_write(esw, i, 26, 0x1601);
+-			/* TX100/TX10 AD/DA current bias */
+-			rt305x_mii_write(esw, i, 29, 0x7016);
+-			/* TX100 slew rate control */
+-			rt305x_mii_write(esw, i, 30, 0x0038);
+-		}
+-
+-		/* select global register */
+-		rt305x_mii_write(esw, 0, 31, 0x0);
+-		/* enlarge agcsel threshold 3 and threshold 2 */
+-		rt305x_mii_write(esw, 0, 1, 0x4a40);
+-		/* enlarge agcsel threshold 5 and threshold 4 */
+-		rt305x_mii_write(esw, 0, 2, 0x6254);
+-		/* enlarge agcsel threshold  */
+-		rt305x_mii_write(esw, 0, 3, 0xa17f);
+-		rt305x_mii_write(esw, 0, 12, 0x7eaa);
+-		/* longer TP_IDL tail length */
+-		rt305x_mii_write(esw, 0, 14, 0x65);
+-		/* increased squelch pulse count threshold. */
+-		rt305x_mii_write(esw, 0, 16, 0x0684);
+-		/* set TX10 signal amplitude threshold to minimum */
+-		rt305x_mii_write(esw, 0, 17, 0x0fe0);
+-		/* set squelch amplitude to higher threshold */
+-		rt305x_mii_write(esw, 0, 18, 0x40ba);
+-		/* tune TP_IDL tail and head waveform, enable power
+-		 * down slew rate control
+-		 */
+-		rt305x_mii_write(esw, 0, 22, 0x253f);
+-		/* set PLL/Receive bias current are calibrated */
+-		rt305x_mii_write(esw, 0, 27, 0x2fda);
+-		/* change PLL/Receive bias current to internal(RT3350) */
+-		rt305x_mii_write(esw, 0, 28, 0xc410);
+-		/* change PLL bias current to internal(RT3052_MP3) */
+-		rt305x_mii_write(esw, 0, 29, 0x598b);
+-		/* select local register */
+-		rt305x_mii_write(esw, 0, 31, 0x8000);
+-	} else if (ralink_soc == RT305X_SOC_RT5350) {
+-		/* reset EPHY */
+-		fe_reset(RT5350_RESET_EPHY);
+-
+-		/* set the led polarity */
+-		esw_w32(esw, esw->reg_led_polarity & 0x1F,
+-			RT5350_EWS_REG_LED_POLARITY);
+-
+-		/* local registers */
+-		rt305x_mii_write(esw, 0, 31, 0x8000);
+-		for (i = 0; i < 5; i++) {
+-			if (esw->ports[i].disable) {
+-				rt305x_mii_write(esw, i, MII_BMCR, BMCR_PDOWN);
+-			} else {
+-				rt305x_mii_write(esw, i, MII_BMCR,
+-						 BMCR_FULLDPLX |
+-						 BMCR_ANENABLE |
+-						 BMCR_SPEED100);
+-			}
+-			/* TX10 waveform coefficient LSB=0 disable PHY */
+-			rt305x_mii_write(esw, i, 26, 0x1601);
+-			/* TX100/TX10 AD/DA current bias */
+-			rt305x_mii_write(esw, i, 29, 0x7015);
+-			/* TX100 slew rate control */
+-			rt305x_mii_write(esw, i, 30, 0x0038);
+-		}
+-
+-		/* global registers */
+-		rt305x_mii_write(esw, 0, 31, 0x0);
+-		/* enlarge agcsel threshold 3 and threshold 2 */
+-		rt305x_mii_write(esw, 0, 1, 0x4a40);
+-		/* enlarge agcsel threshold 5 and threshold 4 */
+-		rt305x_mii_write(esw, 0, 2, 0x6254);
+-		/* enlarge agcsel threshold 6 */
+-		rt305x_mii_write(esw, 0, 3, 0xa17f);
+-		rt305x_mii_write(esw, 0, 12, 0x7eaa);
+-		/* longer TP_IDL tail length */
+-		rt305x_mii_write(esw, 0, 14, 0x65);
+-		/* increased squelch pulse count threshold. */
+-		rt305x_mii_write(esw, 0, 16, 0x0684);
+-		/* set TX10 signal amplitude threshold to minimum */
+-		rt305x_mii_write(esw, 0, 17, 0x0fe0);
+-		/* set squelch amplitude to higher threshold */
+-		rt305x_mii_write(esw, 0, 18, 0x40ba);
+-		/* tune TP_IDL tail and head waveform, enable power
+-		 * down slew rate control
+-		 */
+-		rt305x_mii_write(esw, 0, 22, 0x253f);
+-		/* set PLL/Receive bias current are calibrated */
+-		rt305x_mii_write(esw, 0, 27, 0x2fda);
+-		/* change PLL/Receive bias current to internal(RT3350) */
+-		rt305x_mii_write(esw, 0, 28, 0xc410);
+-		/* change PLL bias current to internal(RT3052_MP3) */
+-		rt305x_mii_write(esw, 0, 29, 0x598b);
+-		/* select local register */
+-		rt305x_mii_write(esw, 0, 31, 0x8000);
+-	} else if (ralink_soc == MT762X_SOC_MT7628AN || ralink_soc == MT762X_SOC_MT7688) {
+-		int i;
+-
+-		/* reset EPHY */
+-		fe_reset(RT5350_RESET_EPHY);
+-
+-		rt305x_mii_write(esw, 0, 31, 0x2000); /* change G2 page */
+-		rt305x_mii_write(esw, 0, 26, 0x0020);
+-
+-		for (i = 0; i < 5; i++) {
+-			rt305x_mii_write(esw, i, 31, 0x8000);
+-			rt305x_mii_write(esw, i,  0, 0x3100);
+-			rt305x_mii_write(esw, i, 30, 0xa000);
+-			rt305x_mii_write(esw, i, 31, 0xa000);
+-			rt305x_mii_write(esw, i, 16, 0x0606);
+-			rt305x_mii_write(esw, i, 23, 0x0f0e);
+-			rt305x_mii_write(esw, i, 24, 0x1610);
+-			rt305x_mii_write(esw, i, 30, 0x1f15);
+-			rt305x_mii_write(esw, i, 28, 0x6111);
+-			rt305x_mii_write(esw, i, 31, 0x2000);
+-			rt305x_mii_write(esw, i, 26, 0x0000);
+-		}
+-
+-		/* 100Base AOI setting */
+-		rt305x_mii_write(esw, 0, 31, 0x5000);
+-		rt305x_mii_write(esw, 0, 19, 0x004a);
+-		rt305x_mii_write(esw, 0, 20, 0x015a);
+-		rt305x_mii_write(esw, 0, 21, 0x00ee);
+-		rt305x_mii_write(esw, 0, 22, 0x0033);
+-		rt305x_mii_write(esw, 0, 23, 0x020a);
+-		rt305x_mii_write(esw, 0, 24, 0x0000);
+-		rt305x_mii_write(esw, 0, 25, 0x024a);
+-		rt305x_mii_write(esw, 0, 26, 0x035a);
+-		rt305x_mii_write(esw, 0, 27, 0x02ee);
+-		rt305x_mii_write(esw, 0, 28, 0x0233);
+-		rt305x_mii_write(esw, 0, 29, 0x000a);
+-		rt305x_mii_write(esw, 0, 30, 0x0000);
+-	} else {
+-		rt305x_mii_write(esw, 0, 31, 0x8000);
+-		for (i = 0; i < 5; i++) {
+-			if (esw->ports[i].disable) {
+-				rt305x_mii_write(esw, i, MII_BMCR, BMCR_PDOWN);
+-			} else {
+-				rt305x_mii_write(esw, i, MII_BMCR,
+-						 BMCR_FULLDPLX |
+-						 BMCR_ANENABLE |
+-						 BMCR_SPEED100);
+-			}
+-			/* TX10 waveform coefficient */
+-			rt305x_mii_write(esw, i, 26, 0x1601);
+-			/* TX100/TX10 AD/DA current bias */
+-			rt305x_mii_write(esw, i, 29, 0x7058);
+-			/* TX100 slew rate control */
+-			rt305x_mii_write(esw, i, 30, 0x0018);
+-		}
+-
+-		/* PHY IOT */
+-		/* select global register */
+-		rt305x_mii_write(esw, 0, 31, 0x0);
+-		/* tune TP_IDL tail and head waveform */
+-		rt305x_mii_write(esw, 0, 22, 0x052f);
+-		/* set TX10 signal amplitude threshold to minimum */
+-		rt305x_mii_write(esw, 0, 17, 0x0fe0);
+-		/* set squelch amplitude to higher threshold */
+-		rt305x_mii_write(esw, 0, 18, 0x40ba);
+-		/* longer TP_IDL tail length */
+-		rt305x_mii_write(esw, 0, 14, 0x65);
+-		/* select local register */
+-		rt305x_mii_write(esw, 0, 31, 0x8000);
+-	}
+-
+-	if (esw->port_map)
+-		port_map = esw->port_map;
+-	else
+-		port_map = RT305X_ESW_PMAP_LLLLLL;
+-
+-	/* Unused HW feature, but still nice to be consistent here...
+-	 * This is also exported to userspace ('lan' attribute) so it's
+-	 * conveniently usable to decide which ports go into the wan vlan by
+-	 * default.
+-	 */
+-	esw_rmw(esw, RT305X_ESW_REG_SGC2,
+-		RT305X_ESW_SGC2_LAN_PMAP_M << RT305X_ESW_SGC2_LAN_PMAP_S,
+-		port_map << RT305X_ESW_SGC2_LAN_PMAP_S);
+-
+-	/* make the switch leds blink */
+-	for (i = 0; i < RT305X_ESW_NUM_LEDS; i++)
+-		esw->ports[i].led = 0x05;
+-
+-	/* Apply the empty config. */
+-	esw_apply_config(&esw->swdev);
+-
+-	/* Only unmask the port change interrupt */
+-	esw_w32(esw, ~RT305X_ESW_PORT_ST_CHG, RT305X_ESW_REG_IMR);
+-}
+-
+-static irqreturn_t esw_interrupt(int irq, void *_esw)
+-{
+-	struct rt305x_esw *esw = (struct rt305x_esw *)_esw;
+-	u32 status;
+-
+-	status = esw_r32(esw, RT305X_ESW_REG_ISR);
+-	if (status & RT305X_ESW_PORT_ST_CHG) {
+-		u32 link = esw_r32(esw, RT305X_ESW_REG_POA);
+-
+-		link >>= RT305X_ESW_POA_LINK_SHIFT;
+-		link &= RT305X_ESW_POA_LINK_MASK;
+-		dev_info(esw->dev, "link changed 0x%02X\n", link);
+-	}
+-	esw_w32(esw, status, RT305X_ESW_REG_ISR);
+-
+-	return IRQ_HANDLED;
+-}
+-
+-static int esw_apply_config(struct switch_dev *dev)
+-{
+-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
+-	int i;
+-	u8 disable = 0;
+-	u8 doubletag = 0;
+-	u8 en_vlan = 0;
+-	u8 untag = 0;
+-
+-	for (i = 0; i < RT305X_ESW_NUM_VLANS; i++) {
+-		u32 vid, vmsc;
+-		if (esw->global_vlan_enable) {
+-			vid = esw->vlans[i].vid;
+-			vmsc = esw->vlans[i].ports;
+-		} else {
+-			vid = RT305X_ESW_VLAN_NONE;
+-			vmsc = RT305X_ESW_PORTS_NONE;
+-		}
+-		esw_set_vlan_id(esw, i, vid);
+-		esw_set_vmsc(esw, i, vmsc);
+-	}
+-
+-	for (i = 0; i < RT305X_ESW_NUM_PORTS; i++) {
+-		u32 pvid;
+-		disable |= esw->ports[i].disable << i;
+-		if (esw->global_vlan_enable) {
+-			doubletag |= esw->ports[i].doubletag << i;
+-			en_vlan   |= 1                       << i;
+-			untag     |= esw->ports[i].untag     << i;
+-			pvid       = esw->ports[i].pvid;
+-		} else {
+-			int x = esw->alt_vlan_disable ? 0 : 1;
+-			doubletag |= x << i;
+-			en_vlan   |= x << i;
+-			untag     |= x << i;
+-			pvid       = 0;
+-		}
+-		esw_set_pvid(esw, i, pvid);
+-		if (i < RT305X_ESW_NUM_LEDS)
+-			esw_w32(esw, esw->ports[i].led,
+-				      RT305X_ESW_REG_P0LED + 4*i);
+-	}
+-
+-	esw_set_gsc(esw);
+-	esw_set_port_disable(esw, disable);
+-	esw_rmw(esw, RT305X_ESW_REG_SGC2,
+-		       (RT305X_ESW_SGC2_DOUBLE_TAG_M <<
+-			RT305X_ESW_SGC2_DOUBLE_TAG_S),
+-		       doubletag << RT305X_ESW_SGC2_DOUBLE_TAG_S);
+-	esw_rmw(esw, RT305X_ESW_REG_PFC1,
+-		       RT305X_ESW_PFC1_EN_VLAN_M << RT305X_ESW_PFC1_EN_VLAN_S,
+-		       en_vlan << RT305X_ESW_PFC1_EN_VLAN_S);
+-	esw_rmw(esw, RT305X_ESW_REG_POC2,
+-		       RT305X_ESW_POC2_UNTAG_EN_M << RT305X_ESW_POC2_UNTAG_EN_S,
+-		       untag << RT305X_ESW_POC2_UNTAG_EN_S);
+-
+-	if (!esw->global_vlan_enable) {
+-		/*
+-		 * Still need to put all ports into vlan 0 or they'll be
+-		 * isolated.
+-		 * NOTE: vlan 0 is special, no vlan tag is prepended
+-		 */
+-		esw_set_vlan_id(esw, 0, 0);
+-		esw_set_vmsc(esw, 0, RT305X_ESW_PORTS_ALL);
+-	}
+-
+-	return 0;
+-}
+-
+-static int esw_reset_switch(struct switch_dev *dev)
+-{
+-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
+-
+-	esw->global_vlan_enable = 0;
+-	memset(esw->ports, 0, sizeof(esw->ports));
+-	memset(esw->vlans, 0, sizeof(esw->vlans));
+-	esw_hw_init(esw);
+-
+-	return 0;
+-}
+-
+-static int esw_get_vlan_enable(struct switch_dev *dev,
+-			   const struct switch_attr *attr,
+-			   struct switch_val *val)
+-{
+-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
+-
+-	val->value.i = esw->global_vlan_enable;
+-
+-	return 0;
+-}
+-
+-static int esw_set_vlan_enable(struct switch_dev *dev,
+-			   const struct switch_attr *attr,
+-			   struct switch_val *val)
+-{
+-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
+-
+-	esw->global_vlan_enable = val->value.i != 0;
+-
+-	return 0;
+-}
+-
+-static int esw_get_alt_vlan_disable(struct switch_dev *dev,
+-				const struct switch_attr *attr,
+-				struct switch_val *val)
+-{
+-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
+-
+-	val->value.i = esw->alt_vlan_disable;
+-
+-	return 0;
+-}
+-
+-static int esw_set_alt_vlan_disable(struct switch_dev *dev,
+-				const struct switch_attr *attr,
+-				struct switch_val *val)
+-{
+-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
+-
+-	esw->alt_vlan_disable = val->value.i != 0;
+-
+-	return 0;
+-}
+-
+-static int
+-rt305x_esw_set_bc_status(struct switch_dev *dev,
+-			const struct switch_attr *attr,
+-			struct switch_val *val)
+-{
+-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
+-
+-	esw->bc_storm_protect = val->value.i & RT305X_ESW_GSC_BC_STROM_MASK;
+-
+-	return 0;
+-}
+-
+-static int
+-rt305x_esw_get_bc_status(struct switch_dev *dev,
+-			const struct switch_attr *attr,
+-			struct switch_val *val)
+-{
+-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
+-
+-	val->value.i = esw->bc_storm_protect;
+-
+-	return 0;
+-}
+-
+-static int
+-rt305x_esw_set_led_freq(struct switch_dev *dev,
+-			const struct switch_attr *attr,
+-			struct switch_val *val)
+-{
+-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
+-
+-	esw->led_frequency = val->value.i & RT305X_ESW_GSC_LED_FREQ_MASK;
+-
+-	return 0;
+-}
+-
+-static int
+-rt305x_esw_get_led_freq(struct switch_dev *dev,
+-			const struct switch_attr *attr,
+-			struct switch_val *val)
+-{
+-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
+-
+-	val->value.i = esw->led_frequency;
+-
+-	return 0;
+-}
+-
+-static int esw_get_port_link(struct switch_dev *dev,
+-			 int port,
+-			 struct switch_port_link *link)
+-{
+-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
+-	u32 speed, poa;
+-
+-	if (port < 0 || port >= RT305X_ESW_NUM_PORTS)
+-		return -EINVAL;
+-
+-	poa = esw_r32(esw, RT305X_ESW_REG_POA) >> port;
+-
+-	link->link = (poa >> RT305X_ESW_LINK_S) & 1;
+-	link->duplex = (poa >> RT305X_ESW_DUPLEX_S) & 1;
+-	if (port < RT305X_ESW_NUM_LEDS) {
+-		speed = (poa >> RT305X_ESW_SPD_S) & 1;
+-	} else {
+-		if (port == RT305X_ESW_NUM_PORTS - 1)
+-			poa >>= 1;
+-		speed = (poa >> RT305X_ESW_SPD_S) & 3;
+-	}
+-	switch (speed) {
+-	case 0:
+-		link->speed = SWITCH_PORT_SPEED_10;
+-		break;
+-	case 1:
+-		link->speed = SWITCH_PORT_SPEED_100;
+-		break;
+-	case 2:
+-	case 3: /* forced gige speed can be 2 or 3 */
+-		link->speed = SWITCH_PORT_SPEED_1000;
+-		break;
+-	default:
+-		link->speed = SWITCH_PORT_SPEED_UNKNOWN;
+-		break;
+-	}
+-
+-	return 0;
+-}
+-
+-static int esw_get_port_bool(struct switch_dev *dev,
+-			 const struct switch_attr *attr,
+-			 struct switch_val *val)
+-{
+-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
+-	int idx = val->port_vlan;
+-	u32 x, reg, shift;
+-
+-	if (idx < 0 || idx >= RT305X_ESW_NUM_PORTS)
+-		return -EINVAL;
+-
+-	switch (attr->id) {
+-	case RT305X_ESW_ATTR_PORT_DISABLE:
+-		reg = RT305X_ESW_REG_POC0;
+-		shift = RT305X_ESW_POC0_DIS_PORT_S;
+-		break;
+-	case RT305X_ESW_ATTR_PORT_DOUBLETAG:
+-		reg = RT305X_ESW_REG_SGC2;
+-		shift = RT305X_ESW_SGC2_DOUBLE_TAG_S;
+-		break;
+-	case RT305X_ESW_ATTR_PORT_UNTAG:
+-		reg = RT305X_ESW_REG_POC2;
+-		shift = RT305X_ESW_POC2_UNTAG_EN_S;
+-		break;
+-	case RT305X_ESW_ATTR_PORT_LAN:
+-		reg = RT305X_ESW_REG_SGC2;
+-		shift = RT305X_ESW_SGC2_LAN_PMAP_S;
+-		if (idx >= RT305X_ESW_NUM_LANWAN)
+-			return -EINVAL;
+-		break;
+-	default:
+-		return -EINVAL;
+-	}
+-
+-	x = esw_r32(esw, reg);
+-	val->value.i = (x >> (idx + shift)) & 1;
+-
+-	return 0;
+-}
+-
+-static int esw_set_port_bool(struct switch_dev *dev,
+-			 const struct switch_attr *attr,
+-			 struct switch_val *val)
+-{
+-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
+-	int idx = val->port_vlan;
+-
+-	if (idx < 0 || idx >= RT305X_ESW_NUM_PORTS ||
+-	    val->value.i < 0 || val->value.i > 1)
+-		return -EINVAL;
+-
+-	switch (attr->id) {
+-	case RT305X_ESW_ATTR_PORT_DISABLE:
+-		esw->ports[idx].disable = val->value.i;
+-		break;
+-	case RT305X_ESW_ATTR_PORT_DOUBLETAG:
+-		esw->ports[idx].doubletag = val->value.i;
+-		break;
+-	case RT305X_ESW_ATTR_PORT_UNTAG:
+-		esw->ports[idx].untag = val->value.i;
+-		break;
+-	default:
+-		return -EINVAL;
+-	}
+-
+-	return 0;
+-}
+-
+-static int esw_get_port_recv_badgood(struct switch_dev *dev,
+-				 const struct switch_attr *attr,
+-				 struct switch_val *val)
+-{
+-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
+-	int idx = val->port_vlan;
+-	int shift = attr->id == RT305X_ESW_ATTR_PORT_RECV_GOOD ? 0 : 16;
+-	u32 reg;
+-
+-	if (idx < 0 || idx >= RT305X_ESW_NUM_LANWAN)
+-		return -EINVAL;
+-	reg = esw_r32(esw, RT305X_ESW_REG_PXPC(idx));
+-	val->value.i = (reg >> shift) & 0xffff;
+-
+-	return 0;
+-}
+-
+-static int
+-esw_get_port_tr_badgood(struct switch_dev *dev,
+-				 const struct switch_attr *attr,
+-				 struct switch_val *val)
+-{
+-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
+-
+-	int idx = val->port_vlan;
+-	int shift = attr->id == RT5350_ESW_ATTR_PORT_TR_GOOD ? 0 : 16;
+-	u32 reg;
+-
+-	if ((ralink_soc != RT305X_SOC_RT5350) && (ralink_soc != MT762X_SOC_MT7628AN) && (ralink_soc != MT762X_SOC_MT7688))
+-		return -EINVAL;
+-
+-	if (idx < 0 || idx >= RT305X_ESW_NUM_LANWAN)
+-		return -EINVAL;
+-
+-	reg = esw_r32(esw, RT5350_ESW_REG_PXTPC(idx));
+-	val->value.i = (reg >> shift) & 0xffff;
+-
+-	return 0;
+-}
+-
+-static int esw_get_port_led(struct switch_dev *dev,
+-			const struct switch_attr *attr,
+-			struct switch_val *val)
+-{
+-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
+-	int idx = val->port_vlan;
+-
+-	if (idx < 0 || idx >= RT305X_ESW_NUM_PORTS ||
+-	    idx >= RT305X_ESW_NUM_LEDS)
+-		return -EINVAL;
+-
+-	val->value.i = esw_r32(esw, RT305X_ESW_REG_P0LED + 4*idx);
+-
+-	return 0;
+-}
+-
+-static int esw_set_port_led(struct switch_dev *dev,
+-			const struct switch_attr *attr,
+-			struct switch_val *val)
+-{
+-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
+-	int idx = val->port_vlan;
+-
+-	if (idx < 0 || idx >= RT305X_ESW_NUM_LEDS)
+-		return -EINVAL;
+-
+-	esw->ports[idx].led = val->value.i;
+-
+-	return 0;
+-}
+-
+-static int esw_get_port_pvid(struct switch_dev *dev, int port, int *val)
+-{
+-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
+-
+-	if (port >= RT305X_ESW_NUM_PORTS)
+-		return -EINVAL;
+-
+-	*val = esw_get_pvid(esw, port);
+-
+-	return 0;
+-}
+-
+-static int esw_set_port_pvid(struct switch_dev *dev, int port, int val)
+-{
+-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
+-
+-	if (port >= RT305X_ESW_NUM_PORTS)
+-		return -EINVAL;
+-
+-	esw->ports[port].pvid = val;
+-
+-	return 0;
+-}
+-
+-static int esw_get_vlan_ports(struct switch_dev *dev, struct switch_val *val)
+-{
+-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
+-	u32 vmsc, poc2;
+-	int vlan_idx = -1;
+-	int i;
+-
+-	val->len = 0;
+-
+-	if (val->port_vlan < 0 || val->port_vlan >= RT305X_ESW_NUM_VIDS)
+-		return -EINVAL;
+-
+-	/* valid vlan? */
+-	for (i = 0; i < RT305X_ESW_NUM_VLANS; i++) {
+-		if (esw_get_vlan_id(esw, i) == val->port_vlan &&
+-		    esw_get_vmsc(esw, i) != RT305X_ESW_PORTS_NONE) {
+-			vlan_idx = i;
+-			break;
+-		}
+-	}
+-
+-	if (vlan_idx == -1)
+-		return -EINVAL;
+-
+-	vmsc = esw_get_vmsc(esw, vlan_idx);
+-	poc2 = esw_r32(esw, RT305X_ESW_REG_POC2);
+-
+-	for (i = 0; i < RT305X_ESW_NUM_PORTS; i++) {
+-		struct switch_port *p;
+-		int port_mask = 1 << i;
+-
+-		if (!(vmsc & port_mask))
+-			continue;
+-
+-		p = &val->value.ports[val->len++];
+-		p->id = i;
+-		if (poc2 & (port_mask << RT305X_ESW_POC2_UNTAG_EN_S))
+-			p->flags = 0;
+-		else
+-			p->flags = 1 << SWITCH_PORT_FLAG_TAGGED;
+-	}
+-
+-	return 0;
+-}
+-
+-static int esw_set_vlan_ports(struct switch_dev *dev, struct switch_val *val)
+-{
+-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
+-	int ports;
+-	int vlan_idx = -1;
+-	int i;
+-
+-	if (val->port_vlan < 0 || val->port_vlan >= RT305X_ESW_NUM_VIDS ||
+-	    val->len > RT305X_ESW_NUM_PORTS)
+-		return -EINVAL;
+-
+-	/* one of the already defined vlans? */
+-	for (i = 0; i < RT305X_ESW_NUM_VLANS; i++) {
+-		if (esw->vlans[i].vid == val->port_vlan &&
+-		    esw->vlans[i].ports != RT305X_ESW_PORTS_NONE) {
+-			vlan_idx = i;
+-			break;
+-		}
+-	}
+-
+-	/* select a free slot */
+-	for (i = 0; vlan_idx == -1 && i < RT305X_ESW_NUM_VLANS; i++) {
+-		if (esw->vlans[i].ports == RT305X_ESW_PORTS_NONE)
+-			vlan_idx = i;
+-	}
+-
+-	/* bail if all slots are in use */
+-	if (vlan_idx == -1)
+-		return -EINVAL;
+-
+-	ports = RT305X_ESW_PORTS_NONE;
+-	for (i = 0; i < val->len; i++) {
+-		struct switch_port *p = &val->value.ports[i];
+-		int port_mask = 1 << p->id;
+-		bool untagged = !(p->flags & (1 << SWITCH_PORT_FLAG_TAGGED));
+-
+-		if (p->id >= RT305X_ESW_NUM_PORTS)
+-			return -EINVAL;
+-
+-		ports |= port_mask;
+-		esw->ports[p->id].untag = untagged;
+-	}
+-	esw->vlans[vlan_idx].ports = ports;
+-	if (ports == RT305X_ESW_PORTS_NONE)
+-		esw->vlans[vlan_idx].vid = RT305X_ESW_VLAN_NONE;
+-	else
+-		esw->vlans[vlan_idx].vid = val->port_vlan;
+-
+-	return 0;
+-}
+-
+-static const struct switch_attr esw_global[] = {
+-	{
+-		.type = SWITCH_TYPE_INT,
+-		.name = "enable_vlan",
+-		.description = "VLAN mode (1:enabled)",
+-		.max = 1,
+-		.id = RT305X_ESW_ATTR_ENABLE_VLAN,
+-		.get = esw_get_vlan_enable,
+-		.set = esw_set_vlan_enable,
+-	},
+-	{
+-		.type = SWITCH_TYPE_INT,
+-		.name = "alternate_vlan_disable",
+-		.description = "Use en_vlan instead of doubletag to disable"
+-				" VLAN mode",
+-		.max = 1,
+-		.id = RT305X_ESW_ATTR_ALT_VLAN_DISABLE,
+-		.get = esw_get_alt_vlan_disable,
+-		.set = esw_set_alt_vlan_disable,
+-	},
+-	{
+-		.type = SWITCH_TYPE_INT,
+-		.name = "bc_storm_protect",
+-		.description = "Global broadcast storm protection (0:Disable, 1:64 blocks, 2:96 blocks, 3:128 blocks)",
+-		.max = 3,
+-		.id = RT305X_ESW_ATTR_BC_STATUS,
+-		.get = rt305x_esw_get_bc_status,
+-		.set = rt305x_esw_set_bc_status,
+-	},
+-	{
+-		.type = SWITCH_TYPE_INT,
+-		.name = "led_frequency",
+-		.description = "LED Flash frequency (0:30mS, 1:60mS, 2:240mS, 3:480mS)",
+-		.max = 3,
+-		.id = RT305X_ESW_ATTR_LED_FREQ,
+-		.get = rt305x_esw_get_led_freq,
+-		.set = rt305x_esw_set_led_freq,
+-	}
+-};
+-
+-static const struct switch_attr esw_port[] = {
+-	{
+-		.type = SWITCH_TYPE_INT,
+-		.name = "disable",
+-		.description = "Port state (1:disabled)",
+-		.max = 1,
+-		.id = RT305X_ESW_ATTR_PORT_DISABLE,
+-		.get = esw_get_port_bool,
+-		.set = esw_set_port_bool,
+-	},
+-	{
+-		.type = SWITCH_TYPE_INT,
+-		.name = "doubletag",
+-		.description = "Double tagging for incoming vlan packets "
+-				"(1:enabled)",
+-		.max = 1,
+-		.id = RT305X_ESW_ATTR_PORT_DOUBLETAG,
+-		.get = esw_get_port_bool,
+-		.set = esw_set_port_bool,
+-	},
+-	{
+-		.type = SWITCH_TYPE_INT,
+-		.name = "untag",
+-		.description = "Untag (1:strip outgoing vlan tag)",
+-		.max = 1,
+-		.id = RT305X_ESW_ATTR_PORT_UNTAG,
+-		.get = esw_get_port_bool,
+-		.set = esw_set_port_bool,
+-	},
+-	{
+-		.type = SWITCH_TYPE_INT,
+-		.name = "led",
+-		.description = "LED mode (0:link, 1:100m, 2:duplex, 3:activity,"
+-				" 4:collision, 5:linkact, 6:duplcoll, 7:10mact,"
+-				" 8:100mact, 10:blink, 11:off, 12:on)",
+-		.max = 15,
+-		.id = RT305X_ESW_ATTR_PORT_LED,
+-		.get = esw_get_port_led,
+-		.set = esw_set_port_led,
+-	},
+-	{
+-		.type = SWITCH_TYPE_INT,
+-		.name = "lan",
+-		.description = "HW port group (0:wan, 1:lan)",
+-		.max = 1,
+-		.id = RT305X_ESW_ATTR_PORT_LAN,
+-		.get = esw_get_port_bool,
+-	},
+-	{
+-		.type = SWITCH_TYPE_INT,
+-		.name = "recv_bad",
+-		.description = "Receive bad packet counter",
+-		.id = RT305X_ESW_ATTR_PORT_RECV_BAD,
+-		.get = esw_get_port_recv_badgood,
+-	},
+-	{
+-		.type = SWITCH_TYPE_INT,
+-		.name = "recv_good",
+-		.description = "Receive good packet counter",
+-		.id = RT305X_ESW_ATTR_PORT_RECV_GOOD,
+-		.get = esw_get_port_recv_badgood,
+-	},
+-	{
+-		.type = SWITCH_TYPE_INT,
+-		.name = "tr_bad",
+-
+-		.description = "Transmit bad packet counter. rt5350 only",
+-		.id = RT5350_ESW_ATTR_PORT_TR_BAD,
+-		.get = esw_get_port_tr_badgood,
+-	},
+-	{
+-		.type = SWITCH_TYPE_INT,
+-		.name = "tr_good",
+-
+-		.description = "Transmit good packet counter. rt5350 only",
+-		.id = RT5350_ESW_ATTR_PORT_TR_GOOD,
+-		.get = esw_get_port_tr_badgood,
+-	},
+-};
+-
+-static const struct switch_attr esw_vlan[] = {
+-};
+-
+-static const struct switch_dev_ops esw_ops = {
+-	.attr_global = {
+-		.attr = esw_global,
+-		.n_attr = ARRAY_SIZE(esw_global),
+-	},
+-	.attr_port = {
+-		.attr = esw_port,
+-		.n_attr = ARRAY_SIZE(esw_port),
+-	},
+-	.attr_vlan = {
+-		.attr = esw_vlan,
+-		.n_attr = ARRAY_SIZE(esw_vlan),
+-	},
+-	.get_vlan_ports = esw_get_vlan_ports,
+-	.set_vlan_ports = esw_set_vlan_ports,
+-	.get_port_pvid = esw_get_port_pvid,
+-	.set_port_pvid = esw_set_port_pvid,
+-	.get_port_link = esw_get_port_link,
+-	.apply_config = esw_apply_config,
+-	.reset_switch = esw_reset_switch,
+-};
+-
+-static int esw_probe(struct platform_device *pdev)
+-{
+-	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+-	struct device_node *np = pdev->dev.of_node;
+-	const __be32 *port_map, *port_disable, *reg_init;
+-	struct switch_dev *swdev;
+-	struct rt305x_esw *esw;
+-	int ret;
+-
+-	esw = devm_kzalloc(&pdev->dev, sizeof(*esw), GFP_KERNEL);
+-	if (!esw)
+-		return -ENOMEM;
+-
+-	esw->dev = &pdev->dev;
+-	esw->irq = irq_of_parse_and_map(np, 0);
+-	esw->base = devm_ioremap_resource(&pdev->dev, res);
+-	if (IS_ERR(esw->base))
+-		return PTR_ERR(esw->base);
+-
+-	port_map = of_get_property(np, "mediatek,portmap", NULL);
+-	if (port_map)
+-		esw->port_map = be32_to_cpu(*port_map);
+-
+-	port_disable = of_get_property(np, "mediatek,portdisable", NULL);
+-	if (port_disable)
+-		esw->port_disable = be32_to_cpu(*port_disable);
+-
+-	reg_init = of_get_property(np, "ralink,fct2", NULL);
+-	if (reg_init)
+-		esw->reg_initval_fct2 = be32_to_cpu(*reg_init);
+-
+-	reg_init = of_get_property(np, "ralink,fpa2", NULL);
+-	if (reg_init)
+-		esw->reg_initval_fpa2 = be32_to_cpu(*reg_init);
+-
+-	reg_init = of_get_property(np, "mediatek,led_polarity", NULL);
+-	if (reg_init)
+-		esw->reg_led_polarity = be32_to_cpu(*reg_init);
+-
+-	swdev = &esw->swdev;
+-	swdev->of_node = pdev->dev.of_node;
+-	swdev->name = "rt305x-esw";
+-	swdev->alias = "rt305x";
+-	swdev->cpu_port = RT305X_ESW_PORT6;
+-	swdev->ports = RT305X_ESW_NUM_PORTS;
+-	swdev->vlans = RT305X_ESW_NUM_VIDS;
+-	swdev->ops = &esw_ops;
+-
+-	ret = register_switch(swdev, NULL);
+-	if (ret < 0) {
+-		dev_err(&pdev->dev, "register_switch failed\n");
+-		return ret;
+-	}
+-
+-	platform_set_drvdata(pdev, esw);
+-
+-	spin_lock_init(&esw->reg_rw_lock);
+-
+-	esw_hw_init(esw);
+-
+-	reg_init = of_get_property(np, "ralink,rgmii", NULL);
+-	if (reg_init && be32_to_cpu(*reg_init) == 1) {
+-		/* 
+-		 * External switch connected to RGMII interface. 
+-		 * Unregister the switch device after initialization. 
+-		 */
+-		dev_err(&pdev->dev, "RGMII mode, not exporting switch device.\n");
+-		unregister_switch(&esw->swdev);
+-		platform_set_drvdata(pdev, NULL);
+-		return -ENODEV;
+-	}
+-
+-	ret = devm_request_irq(&pdev->dev, esw->irq, esw_interrupt, 0, "esw",
+-			       esw);
+-
+-	if (!ret) {
+-		esw_w32(esw, RT305X_ESW_PORT_ST_CHG, RT305X_ESW_REG_ISR);
+-		esw_w32(esw, ~RT305X_ESW_PORT_ST_CHG, RT305X_ESW_REG_IMR);
+-	}
+-
+-	return ret;
+-}
+-
+-static int esw_remove(struct platform_device *pdev)
+-{
+-	struct rt305x_esw *esw = platform_get_drvdata(pdev);
+-
+-	if (esw) {
+-		esw_w32(esw, ~0, RT305X_ESW_REG_IMR);
+-		platform_set_drvdata(pdev, NULL);
+-	}
+-
+-	return 0;
+-}
+-
+-static const struct of_device_id ralink_esw_match[] = {
+-	{ .compatible = "ralink,rt3050-esw" },
+-	{},
+-};
+-MODULE_DEVICE_TABLE(of, ralink_esw_match);
+-
+-static struct platform_driver esw_driver = {
+-	.probe = esw_probe,
+-	.remove = esw_remove,
+-	.driver = {
+-		.name = "rt3050-esw",
+-		.owner = THIS_MODULE,
+-		.of_match_table = ralink_esw_match,
+-	},
+-};
+-
+-module_platform_driver(esw_driver);
+-
+-MODULE_LICENSE("GPL");
+-MODULE_AUTHOR("John Crispin <blogic@openwrt.org>");
+-MODULE_DESCRIPTION("Switch driver for RT305X SoC");
+-MODULE_VERSION(MTK_FE_DRV_VERSION);
+diff --git a/drivers/net/ethernet/mtk/esw_rt3050.h b/drivers/net/ethernet/mtk/esw_rt3050.h
+deleted file mode 100644
+index b757e5d63946..000000000000
+--- a/drivers/net/ethernet/mtk/esw_rt3050.h
++++ /dev/null
+@@ -1,29 +0,0 @@
+-/*   This program is free software; you can redistribute it and/or modify
+- *   it under the terms of the GNU General Public License as published by
+- *   the Free Software Foundation; version 2 of the License
+- *
+- *   This program is distributed in the hope that it will be useful,
+- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+- *   GNU General Public License for more details.
+- *
+- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
+- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
+- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
+- */
+-
+-#ifndef _RALINK_ESW_RT3052_H__
+-#define _RALINK_ESW_RT3052_H__
+-
+-#ifdef CONFIG_NET_MEDIATEK_ESW_RT3052
+-
+-int __init mtk_switch_init(void);
+-void mtk_switch_exit(void);
+-
+-#else
+-
+-static inline int __init mtk_switch_init(void) { return 0; }
+-static inline void mtk_switch_exit(void) { }
+-
+-#endif
+-#endif
+diff --git a/drivers/net/ethernet/mtk/ethtool.c b/drivers/net/ethernet/mtk/ethtool.c
+deleted file mode 100644
+index 5732c28536c2..000000000000
+--- a/drivers/net/ethernet/mtk/ethtool.c
++++ /dev/null
+@@ -1,230 +0,0 @@
+-/*   This program is free software; you can redistribute it and/or modify
+- *   it under the terms of the GNU General Public License as published by
+- *   the Free Software Foundation; version 2 of the License
+- *
+- *   This program is distributed in the hope that it will be useful,
+- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+- *   GNU General Public License for more details.
+- *
+- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
+- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
+- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
+- */
+-
+-#include "mtk_eth_soc.h"
+-
+-static const char fe_gdma_str[][ETH_GSTRING_LEN] = {
+-#define _FE(x...)	# x,
+-FE_STAT_REG_DECLARE
+-#undef _FE
+-};
+-
+-static int fe_get_link_ksettings(struct net_device *ndev,
+-			   struct ethtool_link_ksettings *cmd)
+-{
+-	struct fe_priv *priv = netdev_priv(ndev);
+-
+-	if (!priv->phy_dev)
+-		return -ENODEV;
+-
+-	if (priv->phy_flags == FE_PHY_FLAG_ATTACH) {
+-		if (phy_read_status(priv->phy_dev))
+-			return -ENODEV;
+-	}
+-
+-	phy_ethtool_ksettings_get(ndev->phydev, cmd);
+-
+-	return 0;
+-}
+-
+-static int fe_set_link_ksettings(struct net_device *ndev,
+-			   const struct ethtool_link_ksettings *cmd)
+-{
+-	struct fe_priv *priv = netdev_priv(ndev);
+-
+-	if (!priv->phy_dev)
+-		goto out_sset;
+-
+-	if (cmd->base.phy_address != priv->phy_dev->mdio.addr) {
+-		if (priv->phy->phy_node[cmd->base.phy_address]) {
+-			priv->phy_dev = priv->phy->phy[cmd->base.phy_address];
+-			priv->phy_flags = FE_PHY_FLAG_PORT;
+-		} else if (priv->mii_bus && mdiobus_get_phy(priv->mii_bus, cmd->base.phy_address)) {
+-			priv->phy_dev = mdiobus_get_phy(priv->mii_bus, cmd->base.phy_address);
+-			priv->phy_flags = FE_PHY_FLAG_ATTACH;
+-		} else {
+-			goto out_sset;
+-		}
+-	}
+-
+-	return phy_ethtool_ksettings_set(ndev->phydev, cmd);
+-
+-out_sset:
+-	return -ENODEV;
+-}
+-
+-static void fe_get_drvinfo(struct net_device *dev,
+-			   struct ethtool_drvinfo *info)
+-{
+-	struct fe_priv *priv = netdev_priv(dev);
+-	struct fe_soc_data *soc = priv->soc;
+-
+-	strlcpy(info->driver, priv->dev->driver->name, sizeof(info->driver));
+-	strlcpy(info->version, MTK_FE_DRV_VERSION, sizeof(info->version));
+-	strlcpy(info->bus_info, dev_name(priv->dev), sizeof(info->bus_info));
+-
+-	if (soc->reg_table[FE_REG_FE_COUNTER_BASE])
+-		info->n_stats = ARRAY_SIZE(fe_gdma_str);
+-}
+-
+-static u32 fe_get_msglevel(struct net_device *dev)
+-{
+-	struct fe_priv *priv = netdev_priv(dev);
+-
+-	return priv->msg_enable;
+-}
+-
+-static void fe_set_msglevel(struct net_device *dev, u32 value)
+-{
+-	struct fe_priv *priv = netdev_priv(dev);
+-
+-	priv->msg_enable = value;
+-}
+-
+-static int fe_nway_reset(struct net_device *dev)
+-{
+-	struct fe_priv *priv = netdev_priv(dev);
+-
+-	if (!priv->phy_dev)
+-		goto out_nway_reset;
+-
+-	return genphy_restart_aneg(priv->phy_dev);
+-
+-out_nway_reset:
+-	return -EOPNOTSUPP;
+-}
+-
+-static u32 fe_get_link(struct net_device *dev)
+-{
+-	struct fe_priv *priv = netdev_priv(dev);
+-	int err;
+-
+-	if (!priv->phy_dev)
+-		goto out_get_link;
+-
+-	if (priv->phy_flags == FE_PHY_FLAG_ATTACH) {
+-		err = genphy_update_link(priv->phy_dev);
+-		if (err)
+-			goto out_get_link;
+-	}
+-
+-	return priv->phy_dev->link;
+-
+-out_get_link:
+-	return ethtool_op_get_link(dev);
+-}
+-
+-static int fe_set_ringparam(struct net_device *dev,
+-			    struct ethtool_ringparam *ring)
+-{
+-	struct fe_priv *priv = netdev_priv(dev);
+-
+-	if ((ring->tx_pending < 2) ||
+-	    (ring->rx_pending < 2) ||
+-	    (ring->rx_pending > MAX_DMA_DESC) ||
+-	    (ring->tx_pending > MAX_DMA_DESC))
+-		return -EINVAL;
+-
+-	dev->netdev_ops->ndo_stop(dev);
+-
+-	priv->tx_ring.tx_ring_size = BIT(fls(ring->tx_pending) - 1);
+-	priv->rx_ring.rx_ring_size = BIT(fls(ring->rx_pending) - 1);
+-
+-	dev->netdev_ops->ndo_open(dev);
+-
+-	return 0;
+-}
+-
+-static void fe_get_ringparam(struct net_device *dev,
+-			     struct ethtool_ringparam *ring)
+-{
+-	struct fe_priv *priv = netdev_priv(dev);
+-
+-	ring->rx_max_pending = MAX_DMA_DESC;
+-	ring->tx_max_pending = MAX_DMA_DESC;
+-	ring->rx_pending = priv->rx_ring.rx_ring_size;
+-	ring->tx_pending = priv->tx_ring.tx_ring_size;
+-}
+-
+-static void fe_get_strings(struct net_device *dev, u32 stringset, u8 *data)
+-{
+-	switch (stringset) {
+-	case ETH_SS_STATS:
+-		memcpy(data, *fe_gdma_str, sizeof(fe_gdma_str));
+-		break;
+-	}
+-}
+-
+-static int fe_get_sset_count(struct net_device *dev, int sset)
+-{
+-	switch (sset) {
+-	case ETH_SS_STATS:
+-		return ARRAY_SIZE(fe_gdma_str);
+-	default:
+-		return -EOPNOTSUPP;
+-	}
+-}
+-
+-static void fe_get_ethtool_stats(struct net_device *dev,
+-				 struct ethtool_stats *stats, u64 *data)
+-{
+-	struct fe_priv *priv = netdev_priv(dev);
+-	struct fe_hw_stats *hwstats = priv->hw_stats;
+-	u64 *data_src, *data_dst;
+-	unsigned int start;
+-	int i;
+-
+-	if (netif_running(dev) && netif_device_present(dev)) {
+-		if (spin_trylock(&hwstats->stats_lock)) {
+-			fe_stats_update(priv);
+-			spin_unlock(&hwstats->stats_lock);
+-		}
+-	}
+-
+-	do {
+-		data_src = &hwstats->tx_bytes;
+-		data_dst = data;
+-		start = u64_stats_fetch_begin_irq(&hwstats->syncp);
+-
+-		for (i = 0; i < ARRAY_SIZE(fe_gdma_str); i++)
+-			*data_dst++ = *data_src++;
+-
+-	} while (u64_stats_fetch_retry_irq(&hwstats->syncp, start));
+-}
+-
+-static struct ethtool_ops fe_ethtool_ops = {
+-	.get_link_ksettings	= fe_get_link_ksettings,
+-	.set_link_ksettings	= fe_set_link_ksettings,
+-	.get_drvinfo		= fe_get_drvinfo,
+-	.get_msglevel		= fe_get_msglevel,
+-	.set_msglevel		= fe_set_msglevel,
+-	.nway_reset		= fe_nway_reset,
+-	.get_link		= fe_get_link,
+-	.set_ringparam		= fe_set_ringparam,
+-	.get_ringparam		= fe_get_ringparam,
+-};
+-
+-void fe_set_ethtool_ops(struct net_device *netdev)
+-{
+-	struct fe_priv *priv = netdev_priv(netdev);
+-	struct fe_soc_data *soc = priv->soc;
+-
+-	if (soc->reg_table[FE_REG_FE_COUNTER_BASE]) {
+-		fe_ethtool_ops.get_strings = fe_get_strings;
+-		fe_ethtool_ops.get_sset_count = fe_get_sset_count;
+-		fe_ethtool_ops.get_ethtool_stats = fe_get_ethtool_stats;
+-	}
+-
+-	netdev->ethtool_ops = &fe_ethtool_ops;
+-}
+diff --git a/drivers/net/ethernet/mtk/ethtool.h b/drivers/net/ethernet/mtk/ethtool.h
+deleted file mode 100644
+index 6fd16f0b663f..000000000000
+--- a/drivers/net/ethernet/mtk/ethtool.h
++++ /dev/null
+@@ -1,22 +0,0 @@
+-/*   This program is free software; you can redistribute it and/or modify
+- *   it under the terms of the GNU General Public License as published by
+- *   the Free Software Foundation; version 2 of the License
+- *
+- *   This program is distributed in the hope that it will be useful,
+- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+- *   GNU General Public License for more details.
+- *
+- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
+- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
+- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
+- */
+-
+-#ifndef FE_ETHTOOL_H
+-#define FE_ETHTOOL_H
+-
+-#include <linux/ethtool.h>
+-
+-void fe_set_ethtool_ops(struct net_device *netdev);
+-
+-#endif /* FE_ETHTOOL_H */
+diff --git a/drivers/net/ethernet/mtk/gsw_mt7620.c b/drivers/net/ethernet/mtk/gsw_mt7620.c
+deleted file mode 100644
+index a4602c45868f..000000000000
+--- a/drivers/net/ethernet/mtk/gsw_mt7620.c
++++ /dev/null
+@@ -1,260 +0,0 @@
+-/*   This program is free software; you can redistribute it and/or modify
+- *   it under the terms of the GNU General Public License as published by
+- *   the Free Software Foundation; version 2 of the License
+- *
+- *   This program is distributed in the hope that it will be useful,
+- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+- *   GNU General Public License for more details.
+- *
+- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
+- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
+- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
+- */
+-
+-#include <linux/module.h>
+-#include <linux/kernel.h>
+-#include <linux/types.h>
+-#include <linux/platform_device.h>
+-#include <linux/of_device.h>
+-#include <linux/of_irq.h>
+-
+-#include <ralink_regs.h>
+-
+-#include "mtk_eth_soc.h"
+-#include "gsw_mt7620.h"
+-
+-void mtk_switch_w32(struct mt7620_gsw *gsw, u32 val, unsigned reg)
+-{
+-	iowrite32(val, gsw->base + reg);
+-}
+-
+-u32 mtk_switch_r32(struct mt7620_gsw *gsw, unsigned reg)
+-{
+-	return ioread32(gsw->base + reg);
+-}
+-
+-static irqreturn_t gsw_interrupt_mt7620(int irq, void *_priv)
+-{
+-	struct fe_priv *priv = (struct fe_priv *)_priv;
+-	struct mt7620_gsw *gsw = (struct mt7620_gsw *)priv->soc->swpriv;
+-	u32 status;
+-	int i, max = (gsw->port4 == PORT4_EPHY) ? (4) : (3);
+-
+-	status = mtk_switch_r32(gsw, GSW_REG_ISR);
+-	if (status & PORT_IRQ_ST_CHG)
+-		for (i = 0; i <= max; i++) {
+-			u32 status = mtk_switch_r32(gsw, GSW_REG_PORT_STATUS(i));
+-			int link = status & 0x1;
+-
+-			if (link != priv->link[i])
+-				mt7620_print_link_state(priv, i, link,
+-							(status >> 2) & 3,
+-							(status & 0x2));
+-
+-			priv->link[i] = link;
+-		}
+-	mt7620_handle_carrier(priv);
+-	mtk_switch_w32(gsw, status, GSW_REG_ISR);
+-
+-	return IRQ_HANDLED;
+-}
+-
+-static void mt7620_hw_init(struct mt7620_gsw *gsw, struct device_node *np)
+-{
+-	u32 is_BGA = (rt_sysc_r32(0x0c) >> 16) & 1;
+-
+-	rt_sysc_w32(rt_sysc_r32(SYSC_REG_CFG1) | BIT(8), SYSC_REG_CFG1);
+-	mtk_switch_w32(gsw, mtk_switch_r32(gsw, GSW_REG_CKGCR) & ~(0x3 << 4), GSW_REG_CKGCR);
+-
+-	/* Enable MIB stats */
+-	mtk_switch_w32(gsw, mtk_switch_r32(gsw, GSW_REG_MIB_CNT_EN) | (1 << 1), GSW_REG_MIB_CNT_EN);
+-
+-	if (of_property_read_bool(np, "mediatek,mt7530")) {
+-		u32 val;
+-
+-		/* turn off ephy and set phy base addr to 12 */
+-		mtk_switch_w32(gsw, mtk_switch_r32(gsw, GSW_REG_GPC1) |
+-			(0x1f << 24) | (0xc << 16),
+-			GSW_REG_GPC1);
+-
+-		/* set MT7530 central align */
+-		val = mt7530_mdio_r32(gsw, 0x7830);
+-		val &= ~BIT(0);
+-		val |= BIT(1);
+-		mt7530_mdio_w32(gsw, 0x7830, val);
+-
+-		val = mt7530_mdio_r32(gsw, 0x7a40);
+-		val &= ~BIT(30);
+-		mt7530_mdio_w32(gsw, 0x7a40, val);
+-
+-		mt7530_mdio_w32(gsw, 0x7a78, 0x855);
+-	} else {
+-		/* global page 4 */
+-		_mt7620_mii_write(gsw, 1, 31, 0x4000);
+-
+-		_mt7620_mii_write(gsw, 1, 17, 0x7444);
+-		if (is_BGA)
+-			_mt7620_mii_write(gsw, 1, 19, 0x0114);
+-		else
+-			_mt7620_mii_write(gsw, 1, 19, 0x0117);
+-
+-		_mt7620_mii_write(gsw, 1, 22, 0x10cf);
+-		_mt7620_mii_write(gsw, 1, 25, 0x6212);
+-		_mt7620_mii_write(gsw, 1, 26, 0x0777);
+-		_mt7620_mii_write(gsw, 1, 29, 0x4000);
+-		_mt7620_mii_write(gsw, 1, 28, 0xc077);
+-		_mt7620_mii_write(gsw, 1, 24, 0x0000);
+-
+-		/* global page 3 */
+-		_mt7620_mii_write(gsw, 1, 31, 0x3000);
+-		_mt7620_mii_write(gsw, 1, 17, 0x4838);
+-
+-		/* global page 2 */
+-		_mt7620_mii_write(gsw, 1, 31, 0x2000);
+-		if (is_BGA) {
+-			_mt7620_mii_write(gsw, 1, 21, 0x0515);
+-			_mt7620_mii_write(gsw, 1, 22, 0x0053);
+-			_mt7620_mii_write(gsw, 1, 23, 0x00bf);
+-			_mt7620_mii_write(gsw, 1, 24, 0x0aaf);
+-			_mt7620_mii_write(gsw, 1, 25, 0x0fad);
+-			_mt7620_mii_write(gsw, 1, 26, 0x0fc1);
+-		} else {
+-			_mt7620_mii_write(gsw, 1, 21, 0x0517);
+-			_mt7620_mii_write(gsw, 1, 22, 0x0fd2);
+-			_mt7620_mii_write(gsw, 1, 23, 0x00bf);
+-			_mt7620_mii_write(gsw, 1, 24, 0x0aab);
+-			_mt7620_mii_write(gsw, 1, 25, 0x00ae);
+-			_mt7620_mii_write(gsw, 1, 26, 0x0fff);
+-		}
+-		/* global page 1 */
+-		_mt7620_mii_write(gsw, 1, 31, 0x1000);
+-		_mt7620_mii_write(gsw, 1, 17, 0xe7f8);
+-	}
+-
+-	/* global page 0 */
+-	_mt7620_mii_write(gsw, 1, 31, 0x8000);
+-	_mt7620_mii_write(gsw, 0, 30, 0xa000);
+-	_mt7620_mii_write(gsw, 1, 30, 0xa000);
+-	_mt7620_mii_write(gsw, 2, 30, 0xa000);
+-	_mt7620_mii_write(gsw, 3, 30, 0xa000);
+-
+-	_mt7620_mii_write(gsw, 0, 4, 0x05e1);
+-	_mt7620_mii_write(gsw, 1, 4, 0x05e1);
+-	_mt7620_mii_write(gsw, 2, 4, 0x05e1);
+-	_mt7620_mii_write(gsw, 3, 4, 0x05e1);
+-
+-	/* global page 2 */
+-	_mt7620_mii_write(gsw, 1, 31, 0xa000);
+-	_mt7620_mii_write(gsw, 0, 16, 0x1111);
+-	_mt7620_mii_write(gsw, 1, 16, 0x1010);
+-	_mt7620_mii_write(gsw, 2, 16, 0x1515);
+-	_mt7620_mii_write(gsw, 3, 16, 0x0f0f);
+-
+-	/* CPU Port6 Force Link 1G, FC ON */
+-	mtk_switch_w32(gsw, 0x5e33b, GSW_REG_PORT_PMCR(6));
+-
+-	/* Set Port 6 as CPU Port */
+-	mtk_switch_w32(gsw, 0x7f7f7fe0, 0x0010);
+-
+-	/* setup port 4 */
+-	if (gsw->port4 == PORT4_EPHY) {
+-		u32 val = rt_sysc_r32(SYSC_REG_CFG1);
+-
+-		val |= 3 << 14;
+-		rt_sysc_w32(val, SYSC_REG_CFG1);
+-		_mt7620_mii_write(gsw, 4, 30, 0xa000);
+-		_mt7620_mii_write(gsw, 4, 4, 0x05e1);
+-		_mt7620_mii_write(gsw, 4, 16, 0x1313);
+-		_mt7620_mii_write(gsw, 4, 0, 0x3100);
+-		pr_info("gsw: setting port4 to ephy mode\n");
+-	}
+-}
+-
+-static const struct of_device_id mediatek_gsw_match[] = {
+-	{ .compatible = "mediatek,mt7620-gsw" },
+-	{},
+-};
+-MODULE_DEVICE_TABLE(of, mediatek_gsw_match);
+-
+-int mtk_gsw_init(struct fe_priv *priv)
+-{
+-	struct device_node *np = priv->switch_np;
+-	struct platform_device *pdev = of_find_device_by_node(np);
+-	struct mt7620_gsw *gsw;
+-
+-	if (!pdev)
+-		return -ENODEV;
+-
+-	if (!of_device_is_compatible(np, mediatek_gsw_match->compatible))
+-		return -EINVAL;
+-
+-	gsw = platform_get_drvdata(pdev);
+-	priv->soc->swpriv = gsw;
+-
+-	mt7620_hw_init(gsw, np);
+-
+-	if (gsw->irq) {
+-		request_irq(gsw->irq, gsw_interrupt_mt7620, 0,
+-			    "gsw", priv);
+-		mtk_switch_w32(gsw, ~PORT_IRQ_ST_CHG, GSW_REG_IMR);
+-	}
+-
+-	return 0;
+-}
+-
+-static int mt7620_gsw_probe(struct platform_device *pdev)
+-{
+-	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+-	const char *port4 = NULL;
+-	struct mt7620_gsw *gsw;
+-	struct device_node *np = pdev->dev.of_node;
+-
+-	gsw = devm_kzalloc(&pdev->dev, sizeof(struct mt7620_gsw), GFP_KERNEL);
+-	if (!gsw)
+-		return -ENOMEM;
+-
+-	gsw->base = devm_ioremap_resource(&pdev->dev, res);
+-	if (IS_ERR(gsw->base))
+-		return PTR_ERR(gsw->base);
+-
+-	gsw->dev = &pdev->dev;
+-
+-	of_property_read_string(np, "mediatek,port4", &port4);
+-	if (port4 && !strcmp(port4, "ephy"))
+-		gsw->port4 = PORT4_EPHY;
+-	else if (port4 && !strcmp(port4, "gmac"))
+-		gsw->port4 = PORT4_EXT;
+-	else
+-		gsw->port4 = PORT4_EPHY;
+-
+-	gsw->irq = platform_get_irq(pdev, 0);
+-
+-	platform_set_drvdata(pdev, gsw);
+-
+-	return 0;
+-}
+-
+-static int mt7620_gsw_remove(struct platform_device *pdev)
+-{
+-	platform_set_drvdata(pdev, NULL);
+-
+-	return 0;
+-}
+-
+-static struct platform_driver gsw_driver = {
+-	.probe = mt7620_gsw_probe,
+-	.remove = mt7620_gsw_remove,
+-	.driver = {
+-		.name = "mt7620-gsw",
+-		.owner = THIS_MODULE,
+-		.of_match_table = mediatek_gsw_match,
+-	},
+-};
+-
+-module_platform_driver(gsw_driver);
+-
+-MODULE_LICENSE("GPL");
+-MODULE_AUTHOR("John Crispin <blogic@openwrt.org>");
+-MODULE_DESCRIPTION("GBit switch driver for Mediatek MT7620 SoC");
+-MODULE_VERSION(MTK_FE_DRV_VERSION);
+diff --git a/drivers/net/ethernet/mtk/gsw_mt7620.h b/drivers/net/ethernet/mtk/gsw_mt7620.h
+deleted file mode 100644
+index ae0b6de02416..000000000000
+--- a/drivers/net/ethernet/mtk/gsw_mt7620.h
++++ /dev/null
+@@ -1,127 +0,0 @@
+-/*   This program is free software; you can redistribute it and/or modify
+- *   it under the terms of the GNU General Public License as published by
+- *   the Free Software Foundation; version 2 of the License
+- *
+- *   This program is distributed in the hope that it will be useful,
+- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+- *   GNU General Public License for more details.
+- *
+- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
+- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
+- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
+- */
+-
+-#ifndef _RALINK_GSW_MT7620_H__
+-#define _RALINK_GSW_MT7620_H__
+-
+-#define GSW_REG_PHY_TIMEOUT	(5 * HZ)
+-
+-#ifdef CONFIG_SOC_MT7621
+-#define MT7620A_GSW_REG_PIAC	0x0004
+-#else
+-#define MT7620A_GSW_REG_PIAC	0x7004
+-#endif
+-
+-#define GSW_NUM_VLANS		16
+-#define GSW_NUM_VIDS		4096
+-#define GSW_NUM_PORTS		7
+-#define GSW_PORT6		6
+-
+-#define GSW_MDIO_ACCESS		BIT(31)
+-#define GSW_MDIO_READ		BIT(19)
+-#define GSW_MDIO_WRITE		BIT(18)
+-#define GSW_MDIO_START		BIT(16)
+-#define GSW_MDIO_ADDR_SHIFT	20
+-#define GSW_MDIO_REG_SHIFT	25
+-
+-#define GSW_REG_MIB_CNT_EN	0x4000
+-
+-#define GSW_REG_PORT_PMCR(x)	(0x3000 + (x * 0x100))
+-#define GSW_REG_PORT_STATUS(x)	(0x3008 + (x * 0x100))
+-#define GSW_REG_SMACCR0		0x3fE4
+-#define GSW_REG_SMACCR1		0x3fE8
+-#define GSW_REG_CKGCR		0x3ff0
+-
+-#define GSW_REG_IMR		0x7008
+-#define GSW_REG_ISR		0x700c
+-#define GSW_REG_GPC1		0x7014
+-
+-#define GSW_REG_MAC_P0_MCR	0x100
+-#define GSW_REG_MAC_P1_MCR	0x200
+-
+-// Global MAC control register
+-#define GSW_REG_GMACCR		0x30E0
+-
+-#define SYSC_REG_CHIP_REV_ID	0x0c
+-#define SYSC_REG_CFG1		0x14
+-#define RST_CTRL_MCM		BIT(2)
+-#define SYSC_PAD_RGMII2_MDIO	0x58
+-#define SYSC_GPIO_MODE		0x60
+-
+-#define PORT_IRQ_ST_CHG		0x7f
+-
+-#ifdef CONFIG_SOC_MT7621
+-#define ESW_PHY_POLLING		0x0000
+-#else
+-#define ESW_PHY_POLLING		0x7000
+-#endif
+-
+-#define	PMCR_IPG		BIT(18)
+-#define	PMCR_MAC_MODE		BIT(16)
+-#define	PMCR_FORCE		BIT(15)
+-#define	PMCR_TX_EN		BIT(14)
+-#define	PMCR_RX_EN		BIT(13)
+-#define	PMCR_BACKOFF		BIT(9)
+-#define	PMCR_BACKPRES		BIT(8)
+-#define	PMCR_RX_FC		BIT(5)
+-#define	PMCR_TX_FC		BIT(4)
+-#define	PMCR_SPEED(_x)		(_x << 2)
+-#define	PMCR_DUPLEX		BIT(1)
+-#define	PMCR_LINK		BIT(0)
+-
+-#define PHY_AN_EN		BIT(31)
+-#define PHY_PRE_EN		BIT(30)
+-#define PMY_MDC_CONF(_x)	((_x & 0x3f) << 24)
+-
+-
+-enum {
+-	/* Global attributes. */
+-	GSW_ATTR_ENABLE_VLAN,
+-	/* Port attributes. */
+-	GSW_ATTR_PORT_UNTAG,
+-};
+-
+-enum {
+-	PORT4_EPHY = 0,
+-	PORT4_EXT,
+-};
+-
+-struct mt7620_gsw {
+-	struct device		*dev;
+-	void __iomem		*base;
+-	int			irq;
+-	int			port4;
+-	unsigned long int	autopoll;
+-};
+-
+-void mtk_switch_w32(struct mt7620_gsw *gsw, u32 val, unsigned reg);
+-u32 mtk_switch_r32(struct mt7620_gsw *gsw, unsigned reg);
+-int mtk_gsw_init(struct fe_priv *priv);
+-
+-int mt7620_mdio_write(struct mii_bus *bus, int phy_addr, int phy_reg, u16 val);
+-int mt7620_mdio_read(struct mii_bus *bus, int phy_addr, int phy_reg);
+-void mt7620_mdio_link_adjust(struct fe_priv *priv, int port);
+-int mt7620_has_carrier(struct fe_priv *priv);
+-void mt7620_print_link_state(struct fe_priv *priv, int port, int link,
+-			     int speed, int duplex);
+-
+-void mt7530_mdio_w32(struct mt7620_gsw *gsw, u32 reg, u32 val);
+-u32 mt7530_mdio_r32(struct mt7620_gsw *gsw, u32 reg);
+-
+-u32 _mt7620_mii_write(struct mt7620_gsw *gsw, u32 phy_addr,
+-			     u32 phy_register, u32 write_data);
+-u32 _mt7620_mii_read(struct mt7620_gsw *gsw, int phy_addr, int phy_reg);
+-void mt7620_handle_carrier(struct fe_priv *priv);
+-
+-#endif
+diff --git a/drivers/net/ethernet/mtk/gsw_mt7621.c b/drivers/net/ethernet/mtk/gsw_mt7621.c
+deleted file mode 100644
+index 89be23900738..000000000000
+--- a/drivers/net/ethernet/mtk/gsw_mt7621.c
++++ /dev/null
+@@ -1,281 +0,0 @@
+-/*   This program is free software; you can redistribute it and/or modify
+- *   it under the terms of the GNU General Public License as published by
+- *   the Free Software Foundation; version 2 of the License
+- *
+- *   This program is distributed in the hope that it will be useful,
+- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+- *   GNU General Public License for more details.
+- *
+- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
+- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
+- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
+- */
+-
+-#include <linux/module.h>
+-#include <linux/kernel.h>
+-#include <linux/types.h>
+-#include <linux/platform_device.h>
+-#include <linux/of_device.h>
+-#include <linux/of_irq.h>
+-
+-#include <ralink_regs.h>
+-
+-#include "mtk_eth_soc.h"
+-#include "gsw_mt7620.h"
+-
+-void mtk_switch_w32(struct mt7620_gsw *gsw, u32 val, unsigned reg)
+-{
+-	iowrite32(val, gsw->base + reg);
+-}
+-
+-u32 mtk_switch_r32(struct mt7620_gsw *gsw, unsigned reg)
+-{
+-	return ioread32(gsw->base + reg);
+-}
+-
+-static irqreturn_t gsw_interrupt_mt7621(int irq, void *_priv)
+-{
+-	struct fe_priv *priv = (struct fe_priv *)_priv;
+-	struct mt7620_gsw *gsw = (struct mt7620_gsw *)priv->soc->swpriv;
+-	u32 reg, i;
+-
+-	reg = mt7530_mdio_r32(gsw, 0x700c);
+-	mt7530_mdio_w32(gsw, 0x700c, reg);
+-
+-	for (i = 0; i < 5; i++)
+-		if (reg & BIT(i)) {
+-			unsigned int link;
+-
+-			link = mt7530_mdio_r32(gsw,
+-					       0x3008 + (i * 0x100)) & 0x1;
+-
+-			if (link != priv->link[i]) {
+-				priv->link[i] = link;
+-				if (link)
+-					netdev_info(priv->netdev,
+-						    "port %d link up\n", i);
+-				else
+-					netdev_info(priv->netdev,
+-						    "port %d link down\n", i);
+-			}
+-		}
+-
+-	mt7620_handle_carrier(priv);
+-
+-	return IRQ_HANDLED;
+-}
+-
+-static void mt7621_hw_init(struct mt7620_gsw *gsw, struct device_node *np)
+-{
+-	u32 i;
+-	u32 val;
+-
+-	/* wardware reset the switch */
+-	fe_reset(RST_CTRL_MCM);
+-	mdelay(10);
+-
+-	/* reduce RGMII2 PAD driving strength */
+-	rt_sysc_m32(3 << 4, 0, SYSC_PAD_RGMII2_MDIO);
+-
+-	/* gpio mux - RGMII1=Normal mode */
+-	rt_sysc_m32(BIT(14), 0, SYSC_GPIO_MODE);
+-
+-	/* set GMAC1 RGMII mode */
+-	rt_sysc_m32(3 << 12, 0, SYSC_REG_CFG1);
+-
+-	/* enable MDIO to control MT7530 */
+-	rt_sysc_m32(3 << 12, 0, SYSC_GPIO_MODE);
+-
+-	/* turn off all PHYs */
+-	for (i = 0; i <= 4; i++) {
+-		val = _mt7620_mii_read(gsw, i, 0x0);
+-		val |= BIT(11);
+-		_mt7620_mii_write(gsw, i, 0x0, val);
+-	}
+-
+-	/* reset the switch */
+-	mt7530_mdio_w32(gsw, 0x7000, 0x3);
+-	usleep_range(10, 20);
+-
+-	if ((rt_sysc_r32(SYSC_REG_CHIP_REV_ID) & 0xFFFF) == 0x0101) {
+-		/* (GE1, Force 1000M/FD, FC ON, MAX_RX_LENGTH 1536) */
+-		mtk_switch_w32(gsw, 0x2305e30b, GSW_REG_MAC_P0_MCR);
+-		mt7530_mdio_w32(gsw, 0x3600, 0x5e30b);
+-	} else {
+-		/* (GE1, Force 1000M/FD, FC ON, MAX_RX_LENGTH 1536) */
+-		mtk_switch_w32(gsw, 0x2305e33b, GSW_REG_MAC_P0_MCR);
+-		mt7530_mdio_w32(gsw, 0x3600, 0x5e33b);
+-	}
+-
+-	/* (GE2, Link down) */
+-	mtk_switch_w32(gsw, 0x8000, GSW_REG_MAC_P1_MCR);
+-
+-	/* Set switch max RX frame length to 2k */
+-	mt7530_mdio_w32(gsw, GSW_REG_GMACCR, 0x3F0B);
+-
+-	/* Enable Port 6, P5 as GMAC5, P5 disable */
+-	val = mt7530_mdio_r32(gsw, 0x7804);
+-	val &= ~BIT(8);
+-	val |= BIT(6) | BIT(13) | BIT(16);
+-	mt7530_mdio_w32(gsw, 0x7804, val);
+-
+-	val = rt_sysc_r32(0x10);
+-	val = (val >> 6) & 0x7;
+-	if (val >= 6) {
+-		/* 25Mhz Xtal - do nothing */
+-	} else if (val >= 3) {
+-		/* 40Mhz */
+-
+-		/* disable MT7530 core clock */
+-		_mt7620_mii_write(gsw, 0, 13, 0x1f);
+-		_mt7620_mii_write(gsw, 0, 14, 0x410);
+-		_mt7620_mii_write(gsw, 0, 13, 0x401f);
+-		_mt7620_mii_write(gsw, 0, 14, 0x0);
+-
+-		/* disable MT7530 PLL */
+-		_mt7620_mii_write(gsw, 0, 13, 0x1f);
+-		_mt7620_mii_write(gsw, 0, 14, 0x40d);
+-		_mt7620_mii_write(gsw, 0, 13, 0x401f);
+-		_mt7620_mii_write(gsw, 0, 14, 0x2020);
+-
+-		/* for MT7530 core clock = 500Mhz */
+-		_mt7620_mii_write(gsw, 0, 13, 0x1f);
+-		_mt7620_mii_write(gsw, 0, 14, 0x40e);
+-		_mt7620_mii_write(gsw, 0, 13, 0x401f);
+-		_mt7620_mii_write(gsw, 0, 14, 0x119);
+-
+-		/* enable MT7530 PLL */
+-		_mt7620_mii_write(gsw, 0, 13, 0x1f);
+-		_mt7620_mii_write(gsw, 0, 14, 0x40d);
+-		_mt7620_mii_write(gsw, 0, 13, 0x401f);
+-		_mt7620_mii_write(gsw, 0, 14, 0x2820);
+-
+-		usleep_range(20, 40);
+-
+-		/* enable MT7530 core clock */
+-		_mt7620_mii_write(gsw, 0, 13, 0x1f);
+-		_mt7620_mii_write(gsw, 0, 14, 0x410);
+-		_mt7620_mii_write(gsw, 0, 13, 0x401f);
+-	} else {
+-		/* 20Mhz Xtal - TODO */
+-	}
+-
+-	/* RGMII */
+-	_mt7620_mii_write(gsw, 0, 14, 0x1);
+-
+-	/* set MT7530 central align */
+-	val = mt7530_mdio_r32(gsw, 0x7830);
+-	val &= ~BIT(0);
+-	val |= BIT(1);
+-	mt7530_mdio_w32(gsw, 0x7830, val);
+-	val = mt7530_mdio_r32(gsw, 0x7a40);
+-	val &= ~BIT(30);
+-	mt7530_mdio_w32(gsw, 0x7a40, val);
+-	mt7530_mdio_w32(gsw, 0x7a78, 0x855);
+-
+-	/* delay setting for 10/1000M */
+-	mt7530_mdio_w32(gsw, 0x7b00, 0x102);
+-	mt7530_mdio_w32(gsw, 0x7b04, 0x14);
+-
+-	/* lower Tx Driving*/
+-	mt7530_mdio_w32(gsw, 0x7a54, 0x44);
+-	mt7530_mdio_w32(gsw, 0x7a5c, 0x44);
+-	mt7530_mdio_w32(gsw, 0x7a64, 0x44);
+-	mt7530_mdio_w32(gsw, 0x7a6c, 0x44);
+-	mt7530_mdio_w32(gsw, 0x7a74, 0x44);
+-	mt7530_mdio_w32(gsw, 0x7a7c, 0x44);
+-
+-	/* turn on all PHYs */
+-	for (i = 0; i <= 4; i++) {
+-		val = _mt7620_mii_read(gsw, i, 0);
+-		val &= ~BIT(11);
+-		_mt7620_mii_write(gsw, i, 0, val);
+-	}
+-
+-	/* enable irq */
+-	mt7530_mdio_w32(gsw, 0x7008, 0x1f);
+-	val = mt7530_mdio_r32(gsw, 0x7808);
+-	val |= 3 << 16;
+-	mt7530_mdio_w32(gsw, 0x7808, val);
+-}
+-
+-static const struct of_device_id mediatek_gsw_match[] = {
+-	{ .compatible = "mediatek,mt7621-gsw" },
+-	{},
+-};
+-MODULE_DEVICE_TABLE(of, mediatek_gsw_match);
+-
+-int mtk_gsw_init(struct fe_priv *priv)
+-{
+-	struct device_node *np = priv->switch_np;
+-	struct platform_device *pdev = of_find_device_by_node(np);
+-	struct mt7620_gsw *gsw;
+-
+-	if (!pdev)
+-		return -ENODEV;
+-
+-	if (!of_device_is_compatible(np, mediatek_gsw_match->compatible))
+-		return -EINVAL;
+-
+-	gsw = platform_get_drvdata(pdev);
+-	priv->soc->swpriv = gsw;
+-
+-	if (gsw->irq) {
+-		request_irq(gsw->irq, gsw_interrupt_mt7621, 0,
+-			    "gsw", priv);
+-		disable_irq(gsw->irq);
+-	}
+-
+-	mt7621_hw_init(gsw, np);
+-
+-	if (gsw->irq)
+-		enable_irq(gsw->irq);
+-
+-	return 0;
+-}
+-
+-static int mt7621_gsw_probe(struct platform_device *pdev)
+-{
+-	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+-	struct mt7620_gsw *gsw;
+-
+-	gsw = devm_kzalloc(&pdev->dev, sizeof(struct mt7620_gsw), GFP_KERNEL);
+-	if (!gsw)
+-		return -ENOMEM;
+-
+-	gsw->base = devm_ioremap_resource(&pdev->dev, res);
+-	if (IS_ERR(gsw->base))
+-		return PTR_ERR(gsw->base);
+-
+-	gsw->dev = &pdev->dev;
+-	gsw->irq = platform_get_irq(pdev, 0);
+-
+-	platform_set_drvdata(pdev, gsw);
+-
+-	return 0;
+-}
+-
+-static int mt7621_gsw_remove(struct platform_device *pdev)
+-{
+-	platform_set_drvdata(pdev, NULL);
+-
+-	return 0;
+-}
+-
+-static struct platform_driver gsw_driver = {
+-	.probe = mt7621_gsw_probe,
+-	.remove = mt7621_gsw_remove,
+-	.driver = {
+-		.name = "mt7621-gsw",
+-		.owner = THIS_MODULE,
+-		.of_match_table = mediatek_gsw_match,
+-	},
+-};
+-
+-module_platform_driver(gsw_driver);
+-
+-MODULE_LICENSE("GPL");
+-MODULE_AUTHOR("John Crispin <blogic@openwrt.org>");
+-MODULE_DESCRIPTION("GBit switch driver for Mediatek MT7621 SoC");
+-MODULE_VERSION(MTK_FE_DRV_VERSION);
+diff --git a/drivers/net/ethernet/mtk/mdio.c b/drivers/net/ethernet/mtk/mdio.c
+deleted file mode 100644
+index bdfdf7a432c7..000000000000
+--- a/drivers/net/ethernet/mtk/mdio.c
++++ /dev/null
+@@ -1,261 +0,0 @@
+-/*   This program is free software; you can redistribute it and/or modify
+- *   it under the terms of the GNU General Public License as published by
+- *   the Free Software Foundation; version 2 of the License
+- *
+- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
+- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
+- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
+- */
+-
+-#include <linux/module.h>
+-#include <linux/kernel.h>
+-#include <linux/phy.h>
+-#include <linux/of_net.h>
+-#include <linux/of_mdio.h>
+-
+-#include "mtk_eth_soc.h"
+-#include "mdio.h"
+-
+-static int fe_mdio_reset(struct mii_bus *bus)
+-{
+-	/* TODO */
+-	return 0;
+-}
+-
+-static void fe_phy_link_adjust(struct net_device *dev)
+-{
+-	struct fe_priv *priv = netdev_priv(dev);
+-	unsigned long flags;
+-	int i;
+-
+-	spin_lock_irqsave(&priv->phy->lock, flags);
+-	for (i = 0; i < 8; i++) {
+-		if (priv->phy->phy_node[i]) {
+-			struct phy_device *phydev = priv->phy->phy[i];
+-			int status_change = 0;
+-
+-			if (phydev->link)
+-				if (priv->phy->duplex[i] != phydev->duplex ||
+-				    priv->phy->speed[i] != phydev->speed)
+-					status_change = 1;
+-
+-			if (phydev->link != priv->link[i])
+-				status_change = 1;
+-
+-			switch (phydev->speed) {
+-			case SPEED_1000:
+-			case SPEED_100:
+-			case SPEED_10:
+-				priv->link[i] = phydev->link;
+-				priv->phy->duplex[i] = phydev->duplex;
+-				priv->phy->speed[i] = phydev->speed;
+-
+-				if (status_change &&
+-				    priv->soc->mdio_adjust_link)
+-					priv->soc->mdio_adjust_link(priv, i);
+-				break;
+-			}
+-		}
+-	}
+-	spin_unlock_irqrestore(&priv->phy->lock, flags);
+-}
+-
+-int fe_connect_phy_node(struct fe_priv *priv, struct device_node *phy_node)
+-{
+-	const __be32 *_port = NULL;
+-	struct phy_device *phydev;
+-	int phy_mode, port;
+-
+-	_port = of_get_property(phy_node, "reg", NULL);
+-
+-	if (!_port || (be32_to_cpu(*_port) >= 0x20)) {
+-		pr_err("%s: invalid port id\n", phy_node->name);
+-		return -EINVAL;
+-	}
+-	port = be32_to_cpu(*_port);
+-	phy_mode = of_get_phy_mode(phy_node);
+-	if (phy_mode < 0) {
+-		dev_err(priv->dev, "incorrect phy-mode %d\n", phy_mode);
+-		priv->phy->phy_node[port] = NULL;
+-		return -EINVAL;
+-	}
+-
+-	phydev = of_phy_connect(priv->netdev, phy_node, fe_phy_link_adjust,
+-				0, phy_mode);
+-	if (!phydev) {
+-		dev_err(priv->dev, "could not connect to PHY\n");
+-		priv->phy->phy_node[port] = NULL;
+-		return -ENODEV;
+-	}
+-
+-	phydev->supported &= PHY_GBIT_FEATURES;
+-	phydev->advertising = phydev->supported;
+-	phydev->no_auto_carrier_off = 1;
+-
+-	dev_info(priv->dev,
+-		 "connected port %d to PHY at %s [uid=%08x, driver=%s]\n",
+-		 port, dev_name(&phydev->mdio.dev), phydev->phy_id,
+-		 phydev->drv->name);
+-
+-	priv->phy->phy[port] = phydev;
+-	priv->link[port] = 0;
+-
+-	return 0;
+-}
+-
+-static void phy_init(struct fe_priv *priv, struct phy_device *phy)
+-{
+-	phy_attach(priv->netdev, dev_name(&phy->mdio.dev), PHY_INTERFACE_MODE_MII);
+-
+-	phy->autoneg = AUTONEG_ENABLE;
+-	phy->speed = 0;
+-	phy->duplex = 0;
+-	phy->supported &= IS_ENABLED(CONFIG_NET_MEDIATEK_MDIO_MT7620) ?
+-			PHY_GBIT_FEATURES : PHY_BASIC_FEATURES;
+-	phy->advertising = phy->supported | ADVERTISED_Autoneg;
+-
+-	phy_start_aneg(phy);
+-}
+-
+-static int fe_phy_connect(struct fe_priv *priv)
+-{
+-	int i;
+-
+-	for (i = 0; i < 8; i++) {
+-		if (priv->phy->phy_node[i]) {
+-			if (!priv->phy_dev) {
+-				priv->phy_dev = priv->phy->phy[i];
+-				priv->phy_flags = FE_PHY_FLAG_PORT;
+-			}
+-		} else if (priv->mii_bus && mdiobus_get_phy(priv->mii_bus, i)) {
+-			phy_init(priv, mdiobus_get_phy(priv->mii_bus, i));
+-			if (!priv->phy_dev) {
+-				priv->phy_dev = mdiobus_get_phy(priv->mii_bus, i);
+-				priv->phy_flags = FE_PHY_FLAG_ATTACH;
+-			}
+-		}
+-	}
+-
+-	return 0;
+-}
+-
+-static void fe_phy_disconnect(struct fe_priv *priv)
+-{
+-	unsigned long flags;
+-	int i;
+-
+-	for (i = 0; i < 8; i++)
+-		if (priv->phy->phy_fixed[i]) {
+-			spin_lock_irqsave(&priv->phy->lock, flags);
+-			priv->link[i] = 0;
+-			if (priv->soc->mdio_adjust_link)
+-				priv->soc->mdio_adjust_link(priv, i);
+-			spin_unlock_irqrestore(&priv->phy->lock, flags);
+-		} else if (priv->phy->phy[i]) {
+-			phy_disconnect(priv->phy->phy[i]);
+-		} else if (priv->mii_bus && mdiobus_get_phy(priv->mii_bus, i)) {
+-			phy_detach(mdiobus_get_phy(priv->mii_bus, i));
+-		}
+-}
+-
+-static void fe_phy_start(struct fe_priv *priv)
+-{
+-	unsigned long flags;
+-	int i;
+-
+-	for (i = 0; i < 8; i++) {
+-		if (priv->phy->phy_fixed[i]) {
+-			spin_lock_irqsave(&priv->phy->lock, flags);
+-			priv->link[i] = 1;
+-			if (priv->soc->mdio_adjust_link)
+-				priv->soc->mdio_adjust_link(priv, i);
+-			spin_unlock_irqrestore(&priv->phy->lock, flags);
+-		} else if (priv->phy->phy[i]) {
+-			phy_start(priv->phy->phy[i]);
+-		}
+-	}
+-}
+-
+-static void fe_phy_stop(struct fe_priv *priv)
+-{
+-	unsigned long flags;
+-	int i;
+-
+-	for (i = 0; i < 8; i++)
+-		if (priv->phy->phy_fixed[i]) {
+-			spin_lock_irqsave(&priv->phy->lock, flags);
+-			priv->link[i] = 0;
+-			if (priv->soc->mdio_adjust_link)
+-				priv->soc->mdio_adjust_link(priv, i);
+-			spin_unlock_irqrestore(&priv->phy->lock, flags);
+-		} else if (priv->phy->phy[i]) {
+-			phy_stop(priv->phy->phy[i]);
+-		}
+-}
+-
+-static struct fe_phy phy_ralink = {
+-	.connect = fe_phy_connect,
+-	.disconnect = fe_phy_disconnect,
+-	.start = fe_phy_start,
+-	.stop = fe_phy_stop,
+-};
+-
+-int fe_mdio_init(struct fe_priv *priv)
+-{
+-	struct device_node *mii_np;
+-	int err;
+-
+-	if (!priv->soc->mdio_read || !priv->soc->mdio_write)
+-		return 0;
+-
+-	spin_lock_init(&phy_ralink.lock);
+-	priv->phy = &phy_ralink;
+-
+-	mii_np = of_get_child_by_name(priv->dev->of_node, "mdio-bus");
+-	if (!mii_np) {
+-		dev_err(priv->dev, "no %s child node found", "mdio-bus");
+-		return -ENODEV;
+-	}
+-
+-	if (!of_device_is_available(mii_np)) {
+-		err = 0;
+-		goto err_put_node;
+-	}
+-
+-	priv->mii_bus = mdiobus_alloc();
+-	if (!priv->mii_bus) {
+-		err = -ENOMEM;
+-		goto err_put_node;
+-	}
+-
+-	priv->mii_bus->name = "mdio";
+-	priv->mii_bus->read = priv->soc->mdio_read;
+-	priv->mii_bus->write = priv->soc->mdio_write;
+-	priv->mii_bus->reset = fe_mdio_reset;
+-	priv->mii_bus->priv = priv;
+-	priv->mii_bus->parent = priv->dev;
+-
+-	snprintf(priv->mii_bus->id, MII_BUS_ID_SIZE, "%s", mii_np->name);
+-	err = of_mdiobus_register(priv->mii_bus, mii_np);
+-	if (err)
+-		goto err_free_bus;
+-
+-	return 0;
+-
+-err_free_bus:
+-	kfree(priv->mii_bus);
+-err_put_node:
+-	of_node_put(mii_np);
+-	priv->mii_bus = NULL;
+-	return err;
+-}
+-
+-void fe_mdio_cleanup(struct fe_priv *priv)
+-{
+-	if (!priv->mii_bus)
+-		return;
+-
+-	mdiobus_unregister(priv->mii_bus);
+-	of_node_put(priv->mii_bus->dev.of_node);
+-	kfree(priv->mii_bus);
+-}
+diff --git a/drivers/net/ethernet/mtk/mdio.h b/drivers/net/ethernet/mtk/mdio.h
+deleted file mode 100644
+index 498cf144e631..000000000000
+--- a/drivers/net/ethernet/mtk/mdio.h
++++ /dev/null
+@@ -1,27 +0,0 @@
+-/*   This program is free software; you can redistribute it and/or modify
+- *   it under the terms of the GNU General Public License as published by
+- *   the Free Software Foundation; version 2 of the License
+- *
+- *   This program is distributed in the hope that it will be useful,
+- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+- *   GNU General Public License for more details.
+- *
+- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
+- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
+- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
+- */
+-
+-#ifndef _RALINK_MDIO_H__
+-#define _RALINK_MDIO_H__
+-
+-#ifdef CONFIG_NET_MEDIATEK_MDIO
+-int fe_mdio_init(struct fe_priv *priv);
+-void fe_mdio_cleanup(struct fe_priv *priv);
+-int fe_connect_phy_node(struct fe_priv *priv,
+-			struct device_node *phy_node);
+-#else
+-static inline int fe_mdio_init(struct fe_priv *priv) { return 0; }
+-static inline void fe_mdio_cleanup(struct fe_priv *priv) {}
+-#endif
+-#endif
+diff --git a/drivers/net/ethernet/mtk/mdio_mt7620.c b/drivers/net/ethernet/mtk/mdio_mt7620.c
+deleted file mode 100644
+index 9efe7896a581..000000000000
+--- a/drivers/net/ethernet/mtk/mdio_mt7620.c
++++ /dev/null
+@@ -1,168 +0,0 @@
+-/*   This program is free software; you can redistribute it and/or modify
+- *   it under the terms of the GNU General Public License as published by
+- *   the Free Software Foundation; version 2 of the License
+- *
+- *   This program is distributed in the hope that it will be useful,
+- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+- *   GNU General Public License for more details.
+- *
+- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
+- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
+- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
+- */
+-
+-#include <linux/module.h>
+-#include <linux/kernel.h>
+-#include <linux/types.h>
+-
+-#include "mtk_eth_soc.h"
+-#include "gsw_mt7620.h"
+-#include "mdio.h"
+-
+-static int mt7620_mii_busy_wait(struct mt7620_gsw *gsw)
+-{
+-	unsigned long t_start = jiffies;
+-
+-	while (1) {
+-		if (!(mtk_switch_r32(gsw, MT7620A_GSW_REG_PIAC) & GSW_MDIO_ACCESS))
+-			return 0;
+-		if (time_after(jiffies, t_start + GSW_REG_PHY_TIMEOUT))
+-			break;
+-	}
+-
+-	dev_err(gsw->dev, "mdio: MDIO timeout\n");
+-	return -1;
+-}
+-
+-u32 _mt7620_mii_write(struct mt7620_gsw *gsw, u32 phy_addr,
+-			     u32 phy_register, u32 write_data)
+-{
+-	if (mt7620_mii_busy_wait(gsw))
+-		return -1;
+-
+-	write_data &= 0xffff;
+-
+-	mtk_switch_w32(gsw, GSW_MDIO_ACCESS | GSW_MDIO_START | GSW_MDIO_WRITE |
+-		(phy_register << GSW_MDIO_REG_SHIFT) |
+-		(phy_addr << GSW_MDIO_ADDR_SHIFT) | write_data,
+-		MT7620A_GSW_REG_PIAC);
+-
+-	if (mt7620_mii_busy_wait(gsw))
+-		return -1;
+-
+-	return 0;
+-}
+-
+-u32 _mt7620_mii_read(struct mt7620_gsw *gsw, int phy_addr, int phy_reg)
+-{
+-	u32 d;
+-
+-	if (mt7620_mii_busy_wait(gsw))
+-		return 0xffff;
+-
+-	mtk_switch_w32(gsw, GSW_MDIO_ACCESS | GSW_MDIO_START | GSW_MDIO_READ |
+-		(phy_reg << GSW_MDIO_REG_SHIFT) |
+-		(phy_addr << GSW_MDIO_ADDR_SHIFT),
+-		MT7620A_GSW_REG_PIAC);
+-
+-	if (mt7620_mii_busy_wait(gsw))
+-		return 0xffff;
+-
+-	d = mtk_switch_r32(gsw, MT7620A_GSW_REG_PIAC) & 0xffff;
+-
+-	return d;
+-}
+-
+-int mt7620_mdio_write(struct mii_bus *bus, int phy_addr, int phy_reg, u16 val)
+-{
+-	struct fe_priv *priv = bus->priv;
+-	struct mt7620_gsw *gsw = (struct mt7620_gsw *)priv->soc->swpriv;
+-
+-	return _mt7620_mii_write(gsw, phy_addr, phy_reg, val);
+-}
+-
+-int mt7620_mdio_read(struct mii_bus *bus, int phy_addr, int phy_reg)
+-{
+-	struct fe_priv *priv = bus->priv;
+-	struct mt7620_gsw *gsw = (struct mt7620_gsw *)priv->soc->swpriv;
+-
+-	return _mt7620_mii_read(gsw, phy_addr, phy_reg);
+-}
+-
+-void mt7530_mdio_w32(struct mt7620_gsw *gsw, u32 reg, u32 val)
+-{
+-	_mt7620_mii_write(gsw, 0x1f, 0x1f, (reg >> 6) & 0x3ff);
+-	_mt7620_mii_write(gsw, 0x1f, (reg >> 2) & 0xf,  val & 0xffff);
+-	_mt7620_mii_write(gsw, 0x1f, 0x10, val >> 16);
+-}
+-
+-u32 mt7530_mdio_r32(struct mt7620_gsw *gsw, u32 reg)
+-{
+-	u16 high, low;
+-
+-	_mt7620_mii_write(gsw, 0x1f, 0x1f, (reg >> 6) & 0x3ff);
+-	low = _mt7620_mii_read(gsw, 0x1f, (reg >> 2) & 0xf);
+-	high = _mt7620_mii_read(gsw, 0x1f, 0x10);
+-
+-	return (high << 16) | (low & 0xffff);
+-}
+-
+-static unsigned char *fe_speed_str(int speed)
+-{
+-	switch (speed) {
+-	case 2:
+-	case SPEED_1000:
+-		return "1000";
+-	case 1:
+-	case SPEED_100:
+-		return "100";
+-	case 0:
+-	case SPEED_10:
+-		return "10";
+-	}
+-
+-	return "? ";
+-}
+-
+-int mt7620_has_carrier(struct fe_priv *priv)
+-{
+-	struct mt7620_gsw *gsw = (struct mt7620_gsw *)priv->soc->swpriv;
+-	int i;
+-
+-	for (i = 0; i < GSW_PORT6; i++)
+-		if (mtk_switch_r32(gsw, GSW_REG_PORT_STATUS(i)) & 0x1)
+-			return 1;
+-	return 0;
+-}
+-
+-
+-void mt7620_handle_carrier(struct fe_priv *priv)
+-{
+-	if (!priv->phy)
+-		return;
+-
+-	if (mt7620_has_carrier(priv))
+-		netif_carrier_on(priv->netdev);
+-	else
+-		netif_carrier_off(priv->netdev);
+-}
+-
+-void mt7620_print_link_state(struct fe_priv *priv, int port, int link,
+-			     int speed, int duplex)
+-{
+-	if (link)
+-		netdev_info(priv->netdev, "port %d link up (%sMbps/%s duplex)\n",
+-			    port, fe_speed_str(speed),
+-			    (duplex) ? "Full" : "Half");
+-	else
+-		netdev_info(priv->netdev, "port %d link down\n", port);
+-}
+-
+-void mt7620_mdio_link_adjust(struct fe_priv *priv, int port)
+-{
+-	mt7620_print_link_state(priv, port, priv->link[port],
+-				priv->phy->speed[port],
+-				(priv->phy->duplex[port] == DUPLEX_FULL));
+-	mt7620_handle_carrier(priv);
+-}
+diff --git a/drivers/net/ethernet/mtk/mdio_rt2880.c b/drivers/net/ethernet/mtk/mdio_rt2880.c
+deleted file mode 100644
+index e53fd7f62889..000000000000
+--- a/drivers/net/ethernet/mtk/mdio_rt2880.c
++++ /dev/null
+@@ -1,222 +0,0 @@
+-/*   This program is free software; you can redistribute it and/or modify
+- *   it under the terms of the GNU General Public License as published by
+- *   the Free Software Foundation; version 2 of the License
+- *
+- *   This program is distributed in the hope that it will be useful,
+- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+- *   GNU General Public License for more details.
+- *
+- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
+- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
+- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
+- */
+-
+-#include <linux/module.h>
+-#include <linux/kernel.h>
+-#include <linux/types.h>
+-#include <linux/of_net.h>
+-#include <linux/of_mdio.h>
+-
+-#include "mtk_eth_soc.h"
+-#include "mdio_rt2880.h"
+-#include "mdio.h"
+-
+-#define FE_MDIO_RETRY	1000
+-
+-static unsigned char *rt2880_speed_str(struct fe_priv *priv)
+-{
+-	switch (priv->phy->speed[0]) {
+-	case SPEED_1000:
+-		return "1000";
+-	case SPEED_100:
+-		return "100";
+-	case SPEED_10:
+-		return "10";
+-	}
+-
+-	return "?";
+-}
+-
+-void rt2880_mdio_link_adjust(struct fe_priv *priv, int port)
+-{
+-	u32 mdio_cfg;
+-
+-	if (!priv->link[0]) {
+-		netif_carrier_off(priv->netdev);
+-		netdev_info(priv->netdev, "link down\n");
+-		return;
+-	}
+-
+-	mdio_cfg = FE_MDIO_CFG_TX_CLK_SKEW_200 |
+-		   FE_MDIO_CFG_RX_CLK_SKEW_200 |
+-		   FE_MDIO_CFG_GP1_FRC_EN;
+-
+-	if (priv->phy->duplex[0] == DUPLEX_FULL)
+-		mdio_cfg |= FE_MDIO_CFG_GP1_DUPLEX;
+-
+-	if (priv->phy->tx_fc[0])
+-		mdio_cfg |= FE_MDIO_CFG_GP1_FC_TX;
+-
+-	if (priv->phy->rx_fc[0])
+-		mdio_cfg |= FE_MDIO_CFG_GP1_FC_RX;
+-
+-	switch (priv->phy->speed[0]) {
+-	case SPEED_10:
+-		mdio_cfg |= FE_MDIO_CFG_GP1_SPEED_10;
+-		break;
+-	case SPEED_100:
+-		mdio_cfg |= FE_MDIO_CFG_GP1_SPEED_100;
+-		break;
+-	case SPEED_1000:
+-		mdio_cfg |= FE_MDIO_CFG_GP1_SPEED_1000;
+-		break;
+-	default:
+-		BUG();
+-	}
+-
+-	fe_w32(mdio_cfg, FE_MDIO_CFG);
+-
+-	netif_carrier_on(priv->netdev);
+-	netdev_info(priv->netdev, "link up (%sMbps/%s duplex)\n",
+-		    rt2880_speed_str(priv),
+-		    (priv->phy->duplex[0] == DUPLEX_FULL) ? "Full" : "Half");
+-}
+-
+-static int rt2880_mdio_wait_ready(struct fe_priv *priv)
+-{
+-	int retries;
+-
+-	retries = FE_MDIO_RETRY;
+-	while (1) {
+-		u32 t;
+-
+-		t = fe_r32(FE_MDIO_ACCESS);
+-		if ((t & BIT(31)) == 0)
+-			return 0;
+-
+-		if (retries-- == 0)
+-			break;
+-
+-		udelay(1);
+-	}
+-
+-	dev_err(priv->dev, "MDIO operation timed out\n");
+-	return -ETIMEDOUT;
+-}
+-
+-int rt2880_mdio_read(struct mii_bus *bus, int phy_addr, int phy_reg)
+-{
+-	struct fe_priv *priv = bus->priv;
+-	int err;
+-	u32 t;
+-
+-	err = rt2880_mdio_wait_ready(priv);
+-	if (err)
+-		return 0xffff;
+-
+-	t = (phy_addr << 24) | (phy_reg << 16);
+-	fe_w32(t, FE_MDIO_ACCESS);
+-	t |= BIT(31);
+-	fe_w32(t, FE_MDIO_ACCESS);
+-
+-	err = rt2880_mdio_wait_ready(priv);
+-	if (err)
+-		return 0xffff;
+-
+-	pr_debug("%s: addr=%04x, reg=%04x, value=%04x\n", __func__,
+-		 phy_addr, phy_reg, fe_r32(FE_MDIO_ACCESS) & 0xffff);
+-
+-	return fe_r32(FE_MDIO_ACCESS) & 0xffff;
+-}
+-
+-int rt2880_mdio_write(struct mii_bus *bus, int phy_addr, int phy_reg, u16 val)
+-{
+-	struct fe_priv *priv = bus->priv;
+-	int err;
+-	u32 t;
+-
+-	pr_debug("%s: addr=%04x, reg=%04x, value=%04x\n", __func__,
+-		 phy_addr, phy_reg, fe_r32(FE_MDIO_ACCESS) & 0xffff);
+-
+-	err = rt2880_mdio_wait_ready(priv);
+-	if (err)
+-		return err;
+-
+-	t = (1 << 30) | (phy_addr << 24) | (phy_reg << 16) | val;
+-	fe_w32(t, FE_MDIO_ACCESS);
+-	t |= BIT(31);
+-	fe_w32(t, FE_MDIO_ACCESS);
+-
+-	return rt2880_mdio_wait_ready(priv);
+-}
+-
+-void rt2880_port_init(struct fe_priv *priv, struct device_node *np)
+-{
+-	const __be32 *id = of_get_property(np, "reg", NULL);
+-	const __be32 *link;
+-	int size;
+-	int phy_mode;
+-
+-	if (!id || (be32_to_cpu(*id) != 0)) {
+-		pr_err("%s: invalid port id\n", np->name);
+-		return;
+-	}
+-
+-	priv->phy->phy_fixed[0] = of_get_property(np,
+-						  "mediatek,fixed-link", &size);
+-	if (priv->phy->phy_fixed[0] &&
+-	    (size != (4 * sizeof(*priv->phy->phy_fixed[0])))) {
+-		pr_err("%s: invalid fixed link property\n", np->name);
+-		priv->phy->phy_fixed[0] = NULL;
+-		return;
+-	}
+-
+-	phy_mode = of_get_phy_mode(np);
+-	switch (phy_mode) {
+-	case PHY_INTERFACE_MODE_RGMII:
+-		break;
+-	case PHY_INTERFACE_MODE_MII:
+-		break;
+-	case PHY_INTERFACE_MODE_RMII:
+-		break;
+-	default:
+-		if (!priv->phy->phy_fixed[0])
+-			dev_err(priv->dev, "port %d - invalid phy mode\n",
+-				priv->phy->speed[0]);
+-		break;
+-	}
+-
+-	priv->phy->phy_node[0] = of_parse_phandle(np, "phy-handle", 0);
+-	if (!priv->phy->phy_node[0] && !priv->phy->phy_fixed[0])
+-		return;
+-
+-	if (priv->phy->phy_fixed[0]) {
+-		link = priv->phy->phy_fixed[0];
+-		priv->phy->speed[0] = be32_to_cpup(link++);
+-		priv->phy->duplex[0] = be32_to_cpup(link++);
+-		priv->phy->tx_fc[0] = be32_to_cpup(link++);
+-		priv->phy->rx_fc[0] = be32_to_cpup(link++);
+-
+-		priv->link[0] = 1;
+-		switch (priv->phy->speed[0]) {
+-		case SPEED_10:
+-			break;
+-		case SPEED_100:
+-			break;
+-		case SPEED_1000:
+-			break;
+-		default:
+-			dev_err(priv->dev, "invalid link speed: %d\n",
+-				priv->phy->speed[0]);
+-			priv->phy->phy_fixed[0] = 0;
+-			return;
+-		}
+-		dev_info(priv->dev, "using fixed link parameters\n");
+-		rt2880_mdio_link_adjust(priv, 0);
+-		return;
+-	}
+-
+-	if (priv->phy->phy_node[0] && mdiobus_get_phy(priv->mii_bus, 0))
+-		fe_connect_phy_node(priv, priv->phy->phy_node[0]);
+-}
+diff --git a/drivers/net/ethernet/mtk/mdio_rt2880.h b/drivers/net/ethernet/mtk/mdio_rt2880.h
+deleted file mode 100644
+index 70e344283e59..000000000000
+--- a/drivers/net/ethernet/mtk/mdio_rt2880.h
++++ /dev/null
+@@ -1,23 +0,0 @@
+-/*   This program is free software; you can redistribute it and/or modify
+- *   it under the terms of the GNU General Public License as published by
+- *   the Free Software Foundation; version 2 of the License
+- *
+- *   This program is distributed in the hope that it will be useful,
+- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+- *   GNU General Public License for more details.
+- *
+- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
+- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
+- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
+- */
+-
+-#ifndef _RALINK_MDIO_RT2880_H__
+-#define _RALINK_MDIO_RT2880_H__
+-
+-void rt2880_mdio_link_adjust(struct fe_priv *priv, int port);
+-int rt2880_mdio_read(struct mii_bus *bus, int phy_addr, int phy_reg);
+-int rt2880_mdio_write(struct mii_bus *bus, int phy_addr, int phy_reg, u16 val);
+-void rt2880_port_init(struct fe_priv *priv, struct device_node *np);
+-
+-#endif
+diff --git a/drivers/net/ethernet/mtk/mt7530.c b/drivers/net/ethernet/mtk/mt7530.c
+deleted file mode 100644
+index 5216cb5c6618..000000000000
+--- a/drivers/net/ethernet/mtk/mt7530.c
++++ /dev/null
+@@ -1,979 +0,0 @@
+-/*
+- * This program is free software; you can redistribute it and/or
+- * modify it under the terms of the GNU General Public License
+- * as published by the Free Software Foundation; either version 2
+- * of the License, or (at your option) any later version.
+- *
+- * This program is distributed in the hope that it will be useful,
+- * but WITHOUT ANY WARRANTY; without even the implied warranty of
+- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+- * GNU General Public License for more details.
+- *
+- * Copyright (C) 2013 John Crispin <blogic@openwrt.org>
+- * Copyright (C) 2016 Vitaly Chekryzhev <13hakta@gmail.com>
+- */
+-
+-#include <linux/if.h>
+-#include <linux/module.h>
+-#include <linux/init.h>
+-#include <linux/list.h>
+-#include <linux/if_ether.h>
+-#include <linux/skbuff.h>
+-#include <linux/netdevice.h>
+-#include <linux/netlink.h>
+-#include <linux/bitops.h>
+-#include <net/genetlink.h>
+-#include <linux/switch.h>
+-#include <linux/delay.h>
+-#include <linux/phy.h>
+-#include <linux/netdevice.h>
+-#include <linux/etherdevice.h>
+-#include <linux/lockdep.h>
+-#include <linux/workqueue.h>
+-#include <linux/of_device.h>
+-
+-#include "mt7530.h"
+-
+-#define MT7530_CPU_PORT		6
+-#define MT7530_NUM_PORTS	8
+-#ifdef CONFIG_SOC_MT7621
+-#define MT7530_NUM_VLANS	4095
+-#else
+-#define MT7530_NUM_VLANS	16
+-#endif
+-#define MT7530_MAX_VID		4095
+-#define MT7530_MIN_VID		0
+-
+-#define MT7530_PORT_MIB_TXB_ID	2	/* TxGOC */
+-#define MT7530_PORT_MIB_RXB_ID	6	/* RxGOC */
+-
+-#define MT7621_PORT_MIB_TXB_ID	18	/* TxByte */
+-#define MT7621_PORT_MIB_RXB_ID	37	/* RxByte */
+-
+-/* registers */
+-#define REG_ESW_VLAN_VTCR		0x90
+-#define REG_ESW_VLAN_VAWD1		0x94
+-#define REG_ESW_VLAN_VAWD2		0x98
+-#define REG_ESW_VLAN_VTIM(x)	(0x100 + 4 * ((x) / 2))
+-
+-#define REG_ESW_VLAN_VAWD1_IVL_MAC	BIT(30)
+-#define REG_ESW_VLAN_VAWD1_VTAG_EN	BIT(28)
+-#define REG_ESW_VLAN_VAWD1_VALID	BIT(0)
+-
+-/* vlan egress mode */
+-enum {
+-	ETAG_CTRL_UNTAG	= 0,
+-	ETAG_CTRL_TAG	= 2,
+-	ETAG_CTRL_SWAP	= 1,
+-	ETAG_CTRL_STACK	= 3,
+-};
+-
+-#define REG_ESW_PORT_PCR(x)	(0x2004 | ((x) << 8))
+-#define REG_ESW_PORT_PVC(x)	(0x2010 | ((x) << 8))
+-#define REG_ESW_PORT_PPBV1(x)	(0x2014 | ((x) << 8))
+-
+-#define REG_HWTRAP		0x7804
+-
+-#define MIB_DESC(_s , _o, _n)   \
+-	{                       \
+-		.size = (_s),   \
+-		.offset = (_o), \
+-		.name = (_n),   \
+-	}
+-
+-struct mt7xxx_mib_desc {
+-	unsigned int size;
+-	unsigned int offset;
+-	const char *name;
+-};
+-
+-static const struct mt7xxx_mib_desc mt7620_mibs[] = {
+-	MIB_DESC(1, MT7620_MIB_STATS_PPE_AC_BCNT0, "PPE_AC_BCNT0"),
+-	MIB_DESC(1, MT7620_MIB_STATS_PPE_AC_PCNT0, "PPE_AC_PCNT0"),
+-	MIB_DESC(1, MT7620_MIB_STATS_PPE_AC_BCNT63, "PPE_AC_BCNT63"),
+-	MIB_DESC(1, MT7620_MIB_STATS_PPE_AC_PCNT63, "PPE_AC_PCNT63"),
+-	MIB_DESC(1, MT7620_MIB_STATS_PPE_MTR_CNT0, "PPE_MTR_CNT0"),
+-	MIB_DESC(1, MT7620_MIB_STATS_PPE_MTR_CNT63, "PPE_MTR_CNT63"),
+-	MIB_DESC(1, MT7620_MIB_STATS_GDM1_TX_GBCNT, "GDM1_TX_GBCNT"),
+-	MIB_DESC(1, MT7620_MIB_STATS_GDM1_TX_GPCNT, "GDM1_TX_GPCNT"),
+-	MIB_DESC(1, MT7620_MIB_STATS_GDM1_TX_SKIPCNT, "GDM1_TX_SKIPCNT"),
+-	MIB_DESC(1, MT7620_MIB_STATS_GDM1_TX_COLCNT, "GDM1_TX_COLCNT"),
+-	MIB_DESC(1, MT7620_MIB_STATS_GDM1_RX_GBCNT1, "GDM1_RX_GBCNT1"),
+-	MIB_DESC(1, MT7620_MIB_STATS_GDM1_RX_GPCNT1, "GDM1_RX_GPCNT1"),
+-	MIB_DESC(1, MT7620_MIB_STATS_GDM1_RX_OERCNT, "GDM1_RX_OERCNT"),
+-	MIB_DESC(1, MT7620_MIB_STATS_GDM1_RX_FERCNT, "GDM1_RX_FERCNT"),
+-	MIB_DESC(1, MT7620_MIB_STATS_GDM1_RX_SERCNT, "GDM1_RX_SERCNT"),
+-	MIB_DESC(1, MT7620_MIB_STATS_GDM1_RX_LERCNT, "GDM1_RX_LERCNT"),
+-	MIB_DESC(1, MT7620_MIB_STATS_GDM1_RX_CERCNT, "GDM1_RX_CERCNT"),
+-	MIB_DESC(1, MT7620_MIB_STATS_GDM1_RX_FCCNT, "GDM1_RX_FCCNT"),
+-	MIB_DESC(1, MT7620_MIB_STATS_GDM2_TX_GBCNT, "GDM2_TX_GBCNT"),
+-	MIB_DESC(1, MT7620_MIB_STATS_GDM2_TX_GPCNT, "GDM2_TX_GPCNT"),
+-	MIB_DESC(1, MT7620_MIB_STATS_GDM2_TX_SKIPCNT, "GDM2_TX_SKIPCNT"),
+-	MIB_DESC(1, MT7620_MIB_STATS_GDM2_TX_COLCNT, "GDM2_TX_COLCNT"),
+-	MIB_DESC(1, MT7620_MIB_STATS_GDM2_RX_GBCNT, "GDM2_RX_GBCNT"),
+-	MIB_DESC(1, MT7620_MIB_STATS_GDM2_RX_GPCNT, "GDM2_RX_GPCNT"),
+-	MIB_DESC(1, MT7620_MIB_STATS_GDM2_RX_OERCNT, "GDM2_RX_OERCNT"),
+-	MIB_DESC(1, MT7620_MIB_STATS_GDM2_RX_FERCNT, "GDM2_RX_FERCNT"),
+-	MIB_DESC(1, MT7620_MIB_STATS_GDM2_RX_SERCNT, "GDM2_RX_SERCNT"),
+-	MIB_DESC(1, MT7620_MIB_STATS_GDM2_RX_LERCNT, "GDM2_RX_LERCNT"),
+-	MIB_DESC(1, MT7620_MIB_STATS_GDM2_RX_CERCNT, "GDM2_RX_CERCNT"),
+-	MIB_DESC(1, MT7620_MIB_STATS_GDM2_RX_FCCNT, "GDM2_RX_FCCNT")
+-};
+-
+-static const struct mt7xxx_mib_desc mt7620_port_mibs[] = {
+-	MIB_DESC(1, MT7620_MIB_STATS_PORT_TGPCN,  "TxGPC"),
+-	MIB_DESC(1, MT7620_MIB_STATS_PORT_TBOCN,  "TxBOC"),
+-	MIB_DESC(1, MT7620_MIB_STATS_PORT_TGOCN,  "TxGOC"),
+-	MIB_DESC(1, MT7620_MIB_STATS_PORT_TEPCN,  "TxEPC"),
+-	MIB_DESC(1, MT7620_MIB_STATS_PORT_RGPCN,  "RxGPC"),
+-	MIB_DESC(1, MT7620_MIB_STATS_PORT_RBOCN,  "RxBOC"),
+-	MIB_DESC(1, MT7620_MIB_STATS_PORT_RGOCN,  "RxGOC"),
+-	MIB_DESC(1, MT7620_MIB_STATS_PORT_REPC1N, "RxEPC1"),
+-	MIB_DESC(1, MT7620_MIB_STATS_PORT_REPC2N, "RxEPC2")
+-};
+-
+-static const struct mt7xxx_mib_desc mt7621_mibs[] = {
+-	MIB_DESC(1, MT7621_STATS_TDPC, "TxDrop"),
+-	MIB_DESC(1, MT7621_STATS_TCRC, "TxCRC"),
+-	MIB_DESC(1, MT7621_STATS_TUPC, "TxUni"),
+-	MIB_DESC(1, MT7621_STATS_TMPC, "TxMulti"),
+-	MIB_DESC(1, MT7621_STATS_TBPC, "TxBroad"),
+-	MIB_DESC(1, MT7621_STATS_TCEC, "TxCollision"),
+-	MIB_DESC(1, MT7621_STATS_TSCEC, "TxSingleCol"),
+-	MIB_DESC(1, MT7621_STATS_TMCEC, "TxMultiCol"),
+-	MIB_DESC(1, MT7621_STATS_TDEC, "TxDefer"),
+-	MIB_DESC(1, MT7621_STATS_TLCEC, "TxLateCol"),
+-	MIB_DESC(1, MT7621_STATS_TXCEC, "TxExcCol"),
+-	MIB_DESC(1, MT7621_STATS_TPPC, "TxPause"),
+-	MIB_DESC(1, MT7621_STATS_TL64PC, "Tx64Byte"),
+-	MIB_DESC(1, MT7621_STATS_TL65PC, "Tx65Byte"),
+-	MIB_DESC(1, MT7621_STATS_TL128PC, "Tx128Byte"),
+-	MIB_DESC(1, MT7621_STATS_TL256PC, "Tx256Byte"),
+-	MIB_DESC(1, MT7621_STATS_TL512PC, "Tx512Byte"),
+-	MIB_DESC(1, MT7621_STATS_TL1024PC, "Tx1024Byte"),
+-	MIB_DESC(2, MT7621_STATS_TOC, "TxByte"),
+-	MIB_DESC(1, MT7621_STATS_RDPC, "RxDrop"),
+-	MIB_DESC(1, MT7621_STATS_RFPC, "RxFiltered"),
+-	MIB_DESC(1, MT7621_STATS_RUPC, "RxUni"),
+-	MIB_DESC(1, MT7621_STATS_RMPC, "RxMulti"),
+-	MIB_DESC(1, MT7621_STATS_RBPC, "RxBroad"),
+-	MIB_DESC(1, MT7621_STATS_RAEPC, "RxAlignErr"),
+-	MIB_DESC(1, MT7621_STATS_RCEPC, "RxCRC"),
+-	MIB_DESC(1, MT7621_STATS_RUSPC, "RxUnderSize"),
+-	MIB_DESC(1, MT7621_STATS_RFEPC, "RxFragment"),
+-	MIB_DESC(1, MT7621_STATS_ROSPC, "RxOverSize"),
+-	MIB_DESC(1, MT7621_STATS_RJEPC, "RxJabber"),
+-	MIB_DESC(1, MT7621_STATS_RPPC, "RxPause"),
+-	MIB_DESC(1, MT7621_STATS_RL64PC, "Rx64Byte"),
+-	MIB_DESC(1, MT7621_STATS_RL65PC, "Rx65Byte"),
+-	MIB_DESC(1, MT7621_STATS_RL128PC, "Rx128Byte"),
+-	MIB_DESC(1, MT7621_STATS_RL256PC, "Rx256Byte"),
+-	MIB_DESC(1, MT7621_STATS_RL512PC, "Rx512Byte"),
+-	MIB_DESC(1, MT7621_STATS_RL1024PC, "Rx1024Byte"),
+-	MIB_DESC(2, MT7621_STATS_ROC, "RxByte"),
+-	MIB_DESC(1, MT7621_STATS_RDPC_CTRL, "RxCtrlDrop"),
+-	MIB_DESC(1, MT7621_STATS_RDPC_ING, "RxIngDrop"),
+-	MIB_DESC(1, MT7621_STATS_RDPC_ARL, "RxARLDrop")
+-};
+-
+-enum {
+-	/* Global attributes. */
+-	MT7530_ATTR_ENABLE_VLAN,
+-};
+-
+-struct mt7530_port_entry {
+-	u16	pvid;
+-};
+-
+-struct mt7530_vlan_entry {
+-	u16	vid;
+-	u8	member;
+-	u8	etags;
+-};
+-
+-struct mt7530_priv {
+-	void __iomem		*base;
+-	struct mii_bus		*bus;
+-	struct switch_dev	swdev;
+-
+-	bool			global_vlan_enable;
+-	struct mt7530_vlan_entry	vlan_entries[MT7530_NUM_VLANS];
+-	struct mt7530_port_entry	port_entries[MT7530_NUM_PORTS];
+-};
+-
+-struct mt7530_mapping {
+-	char	*name;
+-	u16	pvids[MT7530_NUM_PORTS];
+-	u8	members[MT7530_NUM_VLANS];
+-	u8	etags[MT7530_NUM_VLANS];
+-	u16	vids[MT7530_NUM_VLANS];
+-} mt7530_defaults[] = {
+-	{
+-		.name = "llllw",
+-		.pvids = { 1, 1, 1, 1, 2, 1, 1 },
+-		.members = { 0, 0x6f, 0x50 },
+-		.etags = { 0, 0x40, 0x40 },
+-		.vids = { 0, 1, 2 },
+-	}, {
+-		.name = "wllll",
+-		.pvids = { 2, 1, 1, 1, 1, 1, 1 },
+-		.members = { 0, 0x7e, 0x41 },
+-		.etags = { 0, 0x40, 0x40 },
+-		.vids = { 0, 1, 2 },
+-	}, {
+-		.name = "lwlll",
+-		.pvids = { 1, 2, 1, 1, 1, 1, 1 },
+-		.members = { 0, 0x7d, 0x42 },
+-		.etags = { 0, 0x40, 0x40 },
+-		.vids = { 0, 1, 2 },
+-	},
+-};
+-
+-struct mt7530_mapping*
+-mt7530_find_mapping(struct device_node *np)
+-{
+-	const char *map;
+-	int i;
+-
+-	if (of_property_read_string(np, "mediatek,portmap", &map))
+-		return NULL;
+-
+-	for (i = 0; i < ARRAY_SIZE(mt7530_defaults); i++)
+-		if (!strcmp(map, mt7530_defaults[i].name))
+-			return &mt7530_defaults[i];
+-
+-	return NULL;
+-}
+-
+-static void
+-mt7530_apply_mapping(struct mt7530_priv *mt7530, struct mt7530_mapping *map)
+-{
+-	int i = 0;
+-
+-	for (i = 0; i < MT7530_NUM_PORTS; i++)
+-		mt7530->port_entries[i].pvid = map->pvids[i];
+-
+-	for (i = 0; i < MT7530_NUM_VLANS; i++) {
+-		mt7530->vlan_entries[i].member = map->members[i];
+-		mt7530->vlan_entries[i].etags = map->etags[i];
+-		mt7530->vlan_entries[i].vid = map->vids[i];
+-	}
+-}
+-
+-static int
+-mt7530_reset_switch(struct switch_dev *dev)
+-{
+-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
+-	int i;
+-
+-	memset(priv->port_entries, 0, sizeof(priv->port_entries));
+-	memset(priv->vlan_entries, 0, sizeof(priv->vlan_entries));
+-
+-	/* set default vid of each vlan to the same number of vlan, so the vid
+-	 * won't need be set explicitly.
+-	 */
+-	for (i = 0; i < MT7530_NUM_VLANS; i++) {
+-		priv->vlan_entries[i].vid = i;
+-	}
+-
+-	return 0;
+-}
+-
+-static int
+-mt7530_get_vlan_enable(struct switch_dev *dev,
+-			   const struct switch_attr *attr,
+-			   struct switch_val *val)
+-{
+-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
+-
+-	val->value.i = priv->global_vlan_enable;
+-
+-	return 0;
+-}
+-
+-static int
+-mt7530_set_vlan_enable(struct switch_dev *dev,
+-			   const struct switch_attr *attr,
+-			   struct switch_val *val)
+-{
+-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
+-
+-	priv->global_vlan_enable = val->value.i != 0;
+-
+-	return 0;
+-}
+-
+-static u32
+-mt7530_r32(struct mt7530_priv *priv, u32 reg)
+-{
+-	u32 val;
+-	if (priv->bus) {
+-		u16 high, low;
+-
+-		mdiobus_write(priv->bus, 0x1f, 0x1f, (reg >> 6) & 0x3ff);
+-		low = mdiobus_read(priv->bus, 0x1f, (reg >> 2) & 0xf);
+-		high = mdiobus_read(priv->bus, 0x1f, 0x10);
+-
+-		return (high << 16) | (low & 0xffff);
+-	}
+-
+-	val = ioread32(priv->base + reg);
+-	pr_debug("MT7530 MDIO Read [%04x]=%08x\n", reg, val);
+-
+-	return val;
+-}
+-
+-static void
+-mt7530_w32(struct mt7530_priv *priv, u32 reg, u32 val)
+-{
+-	if (priv->bus) {
+-		mdiobus_write(priv->bus, 0x1f, 0x1f, (reg >> 6) & 0x3ff);
+-		mdiobus_write(priv->bus, 0x1f, (reg >> 2) & 0xf,  val & 0xffff);
+-		mdiobus_write(priv->bus, 0x1f, 0x10, val >> 16);
+-		return;
+-	}
+-
+-	pr_debug("MT7530 MDIO Write[%04x]=%08x\n", reg, val);
+-	iowrite32(val, priv->base + reg);
+-}
+-
+-static void
+-mt7530_vtcr(struct mt7530_priv *priv, u32 cmd, u32 val)
+-{
+-	int i;
+-
+-	mt7530_w32(priv, REG_ESW_VLAN_VTCR, BIT(31) | (cmd << 12) | val);
+-
+-	for (i = 0; i < 20; i++) {
+-		u32 val = mt7530_r32(priv, REG_ESW_VLAN_VTCR);
+-
+-		if ((val & BIT(31)) == 0)
+-			break;
+-
+-		udelay(1000);
+-	}
+-	if (i == 20)
+-		printk("mt7530: vtcr timeout\n");
+-}
+-
+-static int
+-mt7530_get_port_pvid(struct switch_dev *dev, int port, int *val)
+-{
+-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
+-
+-	if (port >= MT7530_NUM_PORTS)
+-		return -EINVAL;
+-
+-	*val = mt7530_r32(priv, REG_ESW_PORT_PPBV1(port));
+-	*val &= 0xfff;
+-
+-	return 0;
+-}
+-
+-static int
+-mt7530_set_port_pvid(struct switch_dev *dev, int port, int pvid)
+-{
+-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
+-
+-	if (port >= MT7530_NUM_PORTS)
+-		return -EINVAL;
+-
+-	if (pvid < MT7530_MIN_VID || pvid > MT7530_MAX_VID)
+-		return -EINVAL;
+-
+-	priv->port_entries[port].pvid = pvid;
+-
+-	return 0;
+-}
+-
+-static int
+-mt7530_get_vlan_ports(struct switch_dev *dev, struct switch_val *val)
+-{
+-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
+-	u32 member;
+-	u32 etags;
+-	int i;
+-
+-	val->len = 0;
+-
+-	if (val->port_vlan < 0 || val->port_vlan >= MT7530_NUM_VLANS)
+-		return -EINVAL;
+-
+-	mt7530_vtcr(priv, 0, val->port_vlan);
+-
+-	member = mt7530_r32(priv, REG_ESW_VLAN_VAWD1);
+-	member >>= 16;
+-	member &= 0xff;
+-
+-	etags = mt7530_r32(priv, REG_ESW_VLAN_VAWD2);
+-
+-	for (i = 0; i < MT7530_NUM_PORTS; i++) {
+-		struct switch_port *p;
+-		int etag;
+-
+-		if (!(member & BIT(i)))
+-			continue;
+-
+-		p = &val->value.ports[val->len++];
+-		p->id = i;
+-
+-		etag = (etags >> (i * 2)) & 0x3;
+-
+-		if (etag == ETAG_CTRL_TAG)
+-			p->flags |= BIT(SWITCH_PORT_FLAG_TAGGED);
+-		else if (etag != ETAG_CTRL_UNTAG)
+-			printk("vlan egress tag control neither untag nor tag.\n");
+-	}
+-
+-	return 0;
+-}
+-
+-static int
+-mt7530_set_vlan_ports(struct switch_dev *dev, struct switch_val *val)
+-{
+-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
+-	u8 member = 0;
+-	u8 etags = 0;
+-	int i;
+-
+-	if (val->port_vlan < 0 || val->port_vlan >= MT7530_NUM_VLANS ||
+-			val->len > MT7530_NUM_PORTS)
+-		return -EINVAL;
+-
+-	for (i = 0; i < val->len; i++) {
+-		struct switch_port *p = &val->value.ports[i];
+-
+-		if (p->id >= MT7530_NUM_PORTS)
+-			return -EINVAL;
+-
+-		member |= BIT(p->id);
+-
+-		if (p->flags & BIT(SWITCH_PORT_FLAG_TAGGED))
+-			etags |= BIT(p->id);
+-	}
+-	priv->vlan_entries[val->port_vlan].member = member;
+-	priv->vlan_entries[val->port_vlan].etags = etags;
+-
+-	return 0;
+-}
+-
+-static int
+-mt7530_set_vid(struct switch_dev *dev, const struct switch_attr *attr,
+-		struct switch_val *val)
+-{
+-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
+-	int vlan;
+-	u16 vid;
+-
+-	vlan = val->port_vlan;
+-	vid = (u16)val->value.i;
+-
+-	if (vlan < 0 || vlan >= MT7530_NUM_VLANS)
+-		return -EINVAL;
+-
+-	if (vid < MT7530_MIN_VID || vid > MT7530_MAX_VID)
+-		return -EINVAL;
+-
+-	priv->vlan_entries[vlan].vid = vid;
+-	return 0;
+-}
+-
+-static int
+-mt7621_get_vid(struct switch_dev *dev, const struct switch_attr *attr,
+-		struct switch_val *val)
+-{
+-	val->value.i = val->port_vlan;
+-	return 0;
+-}
+-
+-static int
+-mt7530_get_vid(struct switch_dev *dev, const struct switch_attr *attr,
+-		struct switch_val *val)
+-{
+-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
+-	u32 vid;
+-	int vlan;
+-
+-	vlan = val->port_vlan;
+-
+-	vid = mt7530_r32(priv, REG_ESW_VLAN_VTIM(vlan));
+-	if (vlan & 1)
+-		vid = vid >> 12;
+-	vid &= 0xfff;
+-
+-	val->value.i = vid;
+-	return 0;
+-}
+-
+-static void
+-mt7530_write_vlan_entry(struct mt7530_priv *priv, int vlan, u16 vid,
+-	                    u8 ports, u8 etags)
+-{
+-	int port;
+-	u32 val;
+-
+-#ifndef CONFIG_SOC_MT7621
+-	/* vid of vlan */
+-	val = mt7530_r32(priv, REG_ESW_VLAN_VTIM(vlan));
+-	if (vlan % 2 == 0) {
+-		val &= 0xfff000;
+-		val |= vid;
+-	} else {
+-		val &= 0xfff;
+-		val |= (vid << 12);
+-	}
+-	mt7530_w32(priv, REG_ESW_VLAN_VTIM(vlan), val);
+-#endif
+-
+-	/* vlan port membership */
+-	if (ports)
+-		mt7530_w32(priv, REG_ESW_VLAN_VAWD1, REG_ESW_VLAN_VAWD1_IVL_MAC |
+-			REG_ESW_VLAN_VAWD1_VTAG_EN | (ports << 16) |
+-			REG_ESW_VLAN_VAWD1_VALID);
+-	else
+-		mt7530_w32(priv, REG_ESW_VLAN_VAWD1, 0);
+-
+-	/* egress mode */
+-	val = 0;
+-	for (port = 0; port < MT7530_NUM_PORTS; port++) {
+-		if (etags & BIT(port))
+-			val |= ETAG_CTRL_TAG << (port * 2);
+-		else
+-			val |= ETAG_CTRL_UNTAG << (port * 2);
+-	}
+-	mt7530_w32(priv, REG_ESW_VLAN_VAWD2, val);
+-
+-	/* write to vlan table */
+-#ifdef CONFIG_SOC_MT7621
+-	mt7530_vtcr(priv, 1, vid);
+-#else
+-	mt7530_vtcr(priv, 1, vlan);
+-#endif
+-}
+-
+-static int
+-mt7530_apply_config(struct switch_dev *dev)
+-{
+-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
+-	int i, j;
+-	u8 tag_ports;
+-	u8 untag_ports;
+-
+-	if (!priv->global_vlan_enable) {
+-		for (i = 0; i < MT7530_NUM_PORTS; i++)
+-			mt7530_w32(priv, REG_ESW_PORT_PCR(i), 0x00400000);
+-
+-		mt7530_w32(priv, REG_ESW_PORT_PCR(MT7530_CPU_PORT), 0x00ff0000);
+-
+-		for (i = 0; i < MT7530_NUM_PORTS; i++)
+-			mt7530_w32(priv, REG_ESW_PORT_PVC(i), 0x810000c0);
+-
+-		return 0;
+-	}
+-
+-	/* set all ports as security mode */
+-	for (i = 0; i < MT7530_NUM_PORTS; i++)
+-		mt7530_w32(priv, REG_ESW_PORT_PCR(i), 0x00ff0003);
+-
+-	/* check if a port is used in tag/untag vlan egress mode */
+-	tag_ports = 0;
+-	untag_ports = 0;
+-
+-	for (i = 0; i < MT7530_NUM_VLANS; i++) {
+-		u8 member = priv->vlan_entries[i].member;
+-		u8 etags = priv->vlan_entries[i].etags;
+-
+-		if (!member)
+-			continue;
+-
+-		for (j = 0; j < MT7530_NUM_PORTS; j++) {
+-			if (!(member & BIT(j)))
+-				continue;
+-
+-			if (etags & BIT(j))
+-				tag_ports |= 1u << j;
+-			else
+-				untag_ports |= 1u << j;
+-		}
+-	}
+-
+-	/* set all untag-only ports as transparent and the rest as user port */
+-	for (i = 0; i < MT7530_NUM_PORTS; i++) {
+-		u32 pvc_mode = 0x81000000;
+-
+-		if (untag_ports & BIT(i) && !(tag_ports & BIT(i)))
+-			pvc_mode = 0x810000c0;
+-
+-		mt7530_w32(priv, REG_ESW_PORT_PVC(i), pvc_mode);
+-	}
+-
+-	/* first clear the swtich vlan table */
+-	for (i = 0; i < MT7530_NUM_VLANS; i++)
+-		mt7530_write_vlan_entry(priv, i, i, 0, 0);
+-
+-	/* now program only vlans with members to avoid
+-	   clobbering remapped entries in later iterations */
+-	for (i = 0; i < MT7530_NUM_VLANS; i++) {
+-		u16 vid = priv->vlan_entries[i].vid;
+-		u8 member = priv->vlan_entries[i].member;
+-		u8 etags = priv->vlan_entries[i].etags;
+-
+-		if (member)
+-			mt7530_write_vlan_entry(priv, i, vid, member, etags);
+-	}
+-
+-	/* Port Default PVID */
+-	for (i = 0; i < MT7530_NUM_PORTS; i++) {
+-		int vlan = priv->port_entries[i].pvid;
+-		u16 pvid = 0;
+-		u32 val;
+-
+-		if (vlan < MT7530_NUM_VLANS && priv->vlan_entries[vlan].member)
+-			pvid = priv->vlan_entries[vlan].vid;
+-
+-		val = mt7530_r32(priv, REG_ESW_PORT_PPBV1(i));
+-		val &= ~0xfff;
+-		val |= pvid;
+-		mt7530_w32(priv, REG_ESW_PORT_PPBV1(i), val);
+-	}
+-
+-	return 0;
+-}
+-
+-static int
+-mt7530_get_port_link(struct switch_dev *dev,  int port,
+-			struct switch_port_link *link)
+-{
+-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
+-	u32 speed, pmsr;
+-
+-	if (port < 0 || port >= MT7530_NUM_PORTS)
+-		return -EINVAL;
+-
+-	pmsr = mt7530_r32(priv, 0x3008 + (0x100 * port));
+-
+-	link->link = pmsr & 1;
+-	link->duplex = (pmsr >> 1) & 1;
+-	speed = (pmsr >> 2) & 3;
+-
+-	switch (speed) {
+-	case 0:
+-		link->speed = SWITCH_PORT_SPEED_10;
+-		break;
+-	case 1:
+-		link->speed = SWITCH_PORT_SPEED_100;
+-		break;
+-	case 2:
+-	case 3: /* forced gige speed can be 2 or 3 */
+-		link->speed = SWITCH_PORT_SPEED_1000;
+-		break;
+-	default:
+-		link->speed = SWITCH_PORT_SPEED_UNKNOWN;
+-		break;
+-	}
+-
+-	return 0;
+-}
+-
+-static u64 get_mib_counter(struct mt7530_priv *priv, int i, int port)
+-{
+-	unsigned int port_base;
+-	u64 lo;
+-
+-	port_base = MT7621_MIB_COUNTER_BASE +
+-		    MT7621_MIB_COUNTER_PORT_OFFSET * port;
+-
+-	lo = mt7530_r32(priv, port_base + mt7621_mibs[i].offset);
+-	if (mt7621_mibs[i].size == 2) {
+-		u64 hi;
+-
+-		hi = mt7530_r32(priv, port_base + mt7621_mibs[i].offset + 4);
+-		lo |= hi << 32;
+-	}
+-
+-	return lo;
+-}
+-
+-static int mt7621_sw_get_port_mib(struct switch_dev *dev,
+-				  const struct switch_attr *attr,
+-				  struct switch_val *val)
+-{
+-	static char buf[4096];
+-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
+-	int i, len = 0;
+-
+-	if (val->port_vlan >= MT7530_NUM_PORTS)
+-		return -EINVAL;
+-
+-	len += snprintf(buf + len, sizeof(buf) - len,
+-			"Port %d MIB counters\n", val->port_vlan);
+-
+-	for (i = 0; i < ARRAY_SIZE(mt7621_mibs); ++i) {
+-		u64 counter;
+-		len += snprintf(buf + len, sizeof(buf) - len,
+-				"%-11s: ", mt7621_mibs[i].name);
+-		counter = get_mib_counter(priv, i, val->port_vlan);
+-		len += snprintf(buf + len, sizeof(buf) - len, "%llu\n",
+-				counter);
+-	}
+-
+-	val->value.s = buf;
+-	val->len = len;
+-	return 0;
+-}
+-
+-static u64 get_mib_counter_7620(struct mt7530_priv *priv, int i)
+-{
+-	return mt7530_r32(priv, MT7620_MIB_COUNTER_BASE + mt7620_mibs[i].offset);
+-}
+-
+-static u64 get_mib_counter_port_7620(struct mt7530_priv *priv, int i, int port)
+-{
+-	return mt7530_r32(priv,
+-			MT7620_MIB_COUNTER_BASE_PORT +
+-			(MT7620_MIB_COUNTER_PORT_OFFSET * port) +
+-			mt7620_port_mibs[i].offset);
+-}
+-
+-static int mt7530_sw_get_mib(struct switch_dev *dev,
+-				  const struct switch_attr *attr,
+-				  struct switch_val *val)
+-{
+-	static char buf[4096];
+-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
+-	int i, len = 0;
+-
+-	len += snprintf(buf + len, sizeof(buf) - len, "Switch MIB counters\n");
+-
+-	for (i = 0; i < ARRAY_SIZE(mt7620_mibs); ++i) {
+-		u64 counter;
+-		len += snprintf(buf + len, sizeof(buf) - len,
+-				"%-11s: ", mt7620_mibs[i].name);
+-		counter = get_mib_counter_7620(priv, i);
+-		len += snprintf(buf + len, sizeof(buf) - len, "%llu\n",
+-				counter);
+-	}
+-
+-	val->value.s = buf;
+-	val->len = len;
+-	return 0;
+-}
+-
+-static int mt7530_sw_get_port_mib(struct switch_dev *dev,
+-				  const struct switch_attr *attr,
+-				  struct switch_val *val)
+-{
+-	static char buf[4096];
+-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
+-	int i, len = 0;
+-
+-	if (val->port_vlan >= MT7530_NUM_PORTS)
+-		return -EINVAL;
+-
+-	len += snprintf(buf + len, sizeof(buf) - len,
+-			"Port %d MIB counters\n", val->port_vlan);
+-
+-	for (i = 0; i < ARRAY_SIZE(mt7620_port_mibs); ++i) {
+-		u64 counter;
+-		len += snprintf(buf + len, sizeof(buf) - len,
+-				"%-11s: ", mt7620_port_mibs[i].name);
+-		counter = get_mib_counter_port_7620(priv, i, val->port_vlan);
+-		len += snprintf(buf + len, sizeof(buf) - len, "%llu\n",
+-				counter);
+-	}
+-
+-	val->value.s = buf;
+-	val->len = len;
+-	return 0;
+-}
+-
+-static int mt7530_get_port_stats(struct switch_dev *dev, int port,
+-					struct switch_port_stats *stats)
+-{
+-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
+-
+-	if (port < 0 || port >= MT7530_NUM_PORTS)
+-		return -EINVAL;
+-
+-	stats->tx_bytes = get_mib_counter_port_7620(priv, MT7530_PORT_MIB_TXB_ID, port);
+-	stats->rx_bytes = get_mib_counter_port_7620(priv, MT7530_PORT_MIB_RXB_ID, port);
+-
+-	return 0;
+-}
+-
+-static int mt7621_get_port_stats(struct switch_dev *dev, int port,
+-					struct switch_port_stats *stats)
+-{
+-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
+-
+-	if (port < 0 || port >= MT7530_NUM_PORTS)
+-		return -EINVAL;
+-
+-	stats->tx_bytes = get_mib_counter(priv, MT7621_PORT_MIB_TXB_ID, port);
+-	stats->rx_bytes = get_mib_counter(priv, MT7621_PORT_MIB_RXB_ID, port);
+-
+-	return 0;
+-}
+-
+-static const struct switch_attr mt7530_global[] = {
+-	{
+-		.type = SWITCH_TYPE_INT,
+-		.name = "enable_vlan",
+-		.description = "VLAN mode (1:enabled)",
+-		.max = 1,
+-		.id = MT7530_ATTR_ENABLE_VLAN,
+-		.get = mt7530_get_vlan_enable,
+-		.set = mt7530_set_vlan_enable,
+-	}, {
+-		.type = SWITCH_TYPE_STRING,
+-		.name = "mib",
+-		.description = "Get MIB counters for switch",
+-		.get = mt7530_sw_get_mib,
+-		.set = NULL,
+-	},
+-};
+-
+-static const struct switch_attr mt7621_port[] = {
+-	{
+-		.type = SWITCH_TYPE_STRING,
+-		.name = "mib",
+-		.description = "Get MIB counters for port",
+-		.get = mt7621_sw_get_port_mib,
+-		.set = NULL,
+-	},
+-};
+-
+-static const struct switch_attr mt7621_vlan[] = {
+-	{
+-		.type = SWITCH_TYPE_INT,
+-		.name = "vid",
+-		.description = "VLAN ID (0-4094)",
+-		.set = mt7530_set_vid,
+-		.get = mt7621_get_vid,
+-		.max = 4094,
+-	},
+-};
+-
+-static const struct switch_attr mt7530_port[] = {
+-	{
+-		.type = SWITCH_TYPE_STRING,
+-		.name = "mib",
+-		.description = "Get MIB counters for port",
+-		.get = mt7530_sw_get_port_mib,
+-		.set = NULL,
+-	},
+-};
+-
+-static const struct switch_attr mt7530_vlan[] = {
+-	{
+-		.type = SWITCH_TYPE_INT,
+-		.name = "vid",
+-		.description = "VLAN ID (0-4094)",
+-		.set = mt7530_set_vid,
+-		.get = mt7530_get_vid,
+-		.max = 4094,
+-	},
+-};
+-
+-static const struct switch_dev_ops mt7621_ops = {
+-	.attr_global = {
+-		.attr = mt7530_global,
+-		.n_attr = ARRAY_SIZE(mt7530_global),
+-	},
+-	.attr_port = {
+-		.attr = mt7621_port,
+-		.n_attr = ARRAY_SIZE(mt7621_port),
+-	},
+-	.attr_vlan = {
+-		.attr = mt7621_vlan,
+-		.n_attr = ARRAY_SIZE(mt7621_vlan),
+-	},
+-	.get_vlan_ports = mt7530_get_vlan_ports,
+-	.set_vlan_ports = mt7530_set_vlan_ports,
+-	.get_port_pvid = mt7530_get_port_pvid,
+-	.set_port_pvid = mt7530_set_port_pvid,
+-	.get_port_link = mt7530_get_port_link,
+-	.get_port_stats = mt7621_get_port_stats,
+-	.apply_config = mt7530_apply_config,
+-	.reset_switch = mt7530_reset_switch,
+-};
+-
+-static const struct switch_dev_ops mt7530_ops = {
+-	.attr_global = {
+-		.attr = mt7530_global,
+-		.n_attr = ARRAY_SIZE(mt7530_global),
+-	},
+-	.attr_port = {
+-		.attr = mt7530_port,
+-		.n_attr = ARRAY_SIZE(mt7530_port),
+-	},
+-	.attr_vlan = {
+-		.attr = mt7530_vlan,
+-		.n_attr = ARRAY_SIZE(mt7530_vlan),
+-	},
+-	.get_vlan_ports = mt7530_get_vlan_ports,
+-	.set_vlan_ports = mt7530_set_vlan_ports,
+-	.get_port_pvid = mt7530_get_port_pvid,
+-	.set_port_pvid = mt7530_set_port_pvid,
+-	.get_port_link = mt7530_get_port_link,
+-	.get_port_stats = mt7530_get_port_stats,
+-	.apply_config = mt7530_apply_config,
+-	.reset_switch = mt7530_reset_switch,
+-};
+-
+-int
+-mt7530_probe(struct device *dev, void __iomem *base, struct mii_bus *bus, int vlan)
+-{
+-	struct switch_dev *swdev;
+-	struct mt7530_priv *mt7530;
+-	struct mt7530_mapping *map;
+-	int ret;
+-
+-	mt7530 = devm_kzalloc(dev, sizeof(struct mt7530_priv), GFP_KERNEL);
+-	if (!mt7530)
+-		return -ENOMEM;
+-
+-	mt7530->base = base;
+-	mt7530->bus = bus;
+-	mt7530->global_vlan_enable = vlan;
+-
+-	swdev = &mt7530->swdev;
+-	if (bus) {
+-		swdev->alias = "mt7530";
+-		swdev->name = "mt7530";
+-	} else if (IS_ENABLED(CONFIG_SOC_MT7621)) {
+-		swdev->alias = "mt7621";
+-		swdev->name = "mt7621";
+-	} else {
+-		swdev->alias = "mt7620";
+-		swdev->name = "mt7620";
+-	}
+-	swdev->cpu_port = MT7530_CPU_PORT;
+-	swdev->ports = MT7530_NUM_PORTS;
+-	swdev->vlans = MT7530_NUM_VLANS;
+-	if (IS_ENABLED(CONFIG_SOC_MT7621))
+-		swdev->ops = &mt7621_ops;
+-	else
+-		swdev->ops = &mt7530_ops;
+-
+-	ret = register_switch(swdev, NULL);
+-	if (ret) {
+-		dev_err(dev, "failed to register mt7530\n");
+-		return ret;
+-	}
+-
+-
+-	map = mt7530_find_mapping(dev->of_node);
+-	if (map)
+-		mt7530_apply_mapping(mt7530, map);
+-	mt7530_apply_config(swdev);
+-
+-	/* magic vodoo */
+-	if (!IS_ENABLED(CONFIG_SOC_MT7621) && bus && mt7530_r32(mt7530, REG_HWTRAP) !=  0x1117edf) {
+-		dev_info(dev, "fixing up MHWTRAP register - bootloader probably played with it\n");
+-		mt7530_w32(mt7530, REG_HWTRAP, 0x1117edf);
+-	}
+-	dev_info(dev, "loaded %s driver\n", swdev->name);
+-
+-	return 0;
+-}
+diff --git a/drivers/net/ethernet/mtk/mt7530.h b/drivers/net/ethernet/mtk/mt7530.h
+deleted file mode 100644
+index cf725c2f2ba9..000000000000
+--- a/drivers/net/ethernet/mtk/mt7530.h
++++ /dev/null
+@@ -1,186 +0,0 @@
+-/*
+- * This program is free software; you can redistribute it and/or
+- * modify it under the terms of the GNU General Public License
+- * as published by the Free Software Foundation; either version 2
+- * of the License, or (at your option) any later version.
+- *
+- * This program is distributed in the hope that it will be useful,
+- * but WITHOUT ANY WARRANTY; without even the implied warranty of
+- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+- * GNU General Public License for more details.
+- *
+- * Copyright (C) 2013 John Crispin <blogic@openwrt.org>
+- * Copyright (C) 2016 Vitaly Chekryzhev <13hakta@gmail.com>
+- */
+-
+-#ifndef _MT7530_H__
+-#define _MT7530_H__
+-
+-#define MT7620_MIB_COUNTER_BASE_PORT	0x4000
+-#define MT7620_MIB_COUNTER_PORT_OFFSET	0x100
+-#define MT7620_MIB_COUNTER_BASE	0x1010
+-
+-/* PPE Accounting Group #0 Byte Counter */
+-#define MT7620_MIB_STATS_PPE_AC_BCNT0	0x000
+-
+-/* PPE Accounting Group #0 Packet Counter */
+-#define MT7620_MIB_STATS_PPE_AC_PCNT0	0x004
+-
+-/* PPE Accounting Group #63 Byte Counter */
+-#define MT7620_MIB_STATS_PPE_AC_BCNT63	0x1F8
+-
+-/* PPE Accounting Group #63 Packet Counter */
+-#define MT7620_MIB_STATS_PPE_AC_PCNT63	0x1FC
+-
+-/* PPE Meter Group #0 */
+-#define MT7620_MIB_STATS_PPE_MTR_CNT0	0x200
+-
+-/* PPE Meter Group #63 */
+-#define MT7620_MIB_STATS_PPE_MTR_CNT63	0x2FC
+-
+-/* Transmit good byte count for CPU GDM */
+-#define MT7620_MIB_STATS_GDM1_TX_GBCNT	0x300
+-
+-/* Transmit good packet count for CPU GDM (exclude flow control frames) */
+-#define MT7620_MIB_STATS_GDM1_TX_GPCNT	0x304
+-
+-/* Transmit abort count for CPU GDM */
+-#define MT7620_MIB_STATS_GDM1_TX_SKIPCNT	0x308
+-
+-/* Transmit collision count for CPU GDM */
+-#define MT7620_MIB_STATS_GDM1_TX_COLCNT	0x30C
+-
+-/* Received good byte count for CPU GDM */
+-#define MT7620_MIB_STATS_GDM1_RX_GBCNT1	0x320
+-
+-/* Received good packet count for CPU GDM (exclude flow control frame) */
+-#define MT7620_MIB_STATS_GDM1_RX_GPCNT1	0x324
+-
+-/* Received overflow error packet count for CPU GDM */
+-#define MT7620_MIB_STATS_GDM1_RX_OERCNT	0x328
+-
+-/* Received FCS error packet count for CPU GDM */
+-#define MT7620_MIB_STATS_GDM1_RX_FERCNT	0x32C
+-
+-/* Received too short error packet count for CPU GDM */
+-#define MT7620_MIB_STATS_GDM1_RX_SERCNT	0x330
+-
+-/* Received too long error packet count for CPU GDM */
+-#define MT7620_MIB_STATS_GDM1_RX_LERCNT	0x334
+-
+-/* Received IP/TCP/UDP checksum error packet count for CPU GDM */
+-#define MT7620_MIB_STATS_GDM1_RX_CERCNT	0x338
+-
+-/* Received flow control pkt count for CPU GDM */
+-#define MT7620_MIB_STATS_GDM1_RX_FCCNT	0x33C
+-
+-/* Transmit good byte count for PPE GDM */
+-#define MT7620_MIB_STATS_GDM2_TX_GBCNT	0x340
+-
+-/* Transmit good packet count for PPE GDM (exclude flow control frames) */
+-#define MT7620_MIB_STATS_GDM2_TX_GPCNT	0x344
+-
+-/* Transmit abort count for PPE GDM */
+-#define MT7620_MIB_STATS_GDM2_TX_SKIPCNT	0x348
+-
+-/* Transmit collision count for PPE GDM */
+-#define MT7620_MIB_STATS_GDM2_TX_COLCNT	0x34C
+-
+-/* Received good byte count for PPE GDM */
+-#define MT7620_MIB_STATS_GDM2_RX_GBCNT	0x360
+-
+-/* Received good packet count for PPE GDM (exclude flow control frame) */
+-#define MT7620_MIB_STATS_GDM2_RX_GPCNT	0x364
+-
+-/* Received overflow error packet count for PPE GDM */
+-#define MT7620_MIB_STATS_GDM2_RX_OERCNT	0x368
+-
+-/* Received FCS error packet count for PPE GDM */
+-#define MT7620_MIB_STATS_GDM2_RX_FERCNT	0x36C
+-
+-/* Received too short error packet count for PPE GDM */
+-#define MT7620_MIB_STATS_GDM2_RX_SERCNT	0x370
+-
+-/* Received too long error packet count for PPE GDM */
+-#define MT7620_MIB_STATS_GDM2_RX_LERCNT	0x374
+-
+-/* Received IP/TCP/UDP checksum error packet count for PPE GDM */
+-#define MT7620_MIB_STATS_GDM2_RX_CERCNT	0x378
+-
+-/* Received flow control pkt count for PPE GDM */
+-#define MT7620_MIB_STATS_GDM2_RX_FCCNT	0x37C
+-
+-/* Tx Packet Counter of Port n */
+-#define MT7620_MIB_STATS_PORT_TGPCN	0x10
+-
+-/* Tx Bad Octet Counter of Port n */
+-#define MT7620_MIB_STATS_PORT_TBOCN	0x14
+-
+-/* Tx Good Octet Counter of Port n */
+-#define MT7620_MIB_STATS_PORT_TGOCN	0x18
+-
+-/* Tx Event Packet Counter of Port n */
+-#define MT7620_MIB_STATS_PORT_TEPCN	0x1C
+-
+-/* Rx Packet Counter of Port n */
+-#define MT7620_MIB_STATS_PORT_RGPCN	0x20
+-
+-/* Rx Bad Octet Counter of Port n */
+-#define MT7620_MIB_STATS_PORT_RBOCN	0x24
+-
+-/* Rx Good Octet Counter of Port n */
+-#define MT7620_MIB_STATS_PORT_RGOCN	0x28
+-
+-/* Rx Event Packet Counter of Port n */
+-#define MT7620_MIB_STATS_PORT_REPC1N	0x2C
+-
+-/* Rx Event Packet Counter of Port n */
+-#define MT7620_MIB_STATS_PORT_REPC2N	0x30
+-
+-#define MT7621_MIB_COUNTER_BASE	0x4000
+-#define MT7621_MIB_COUNTER_PORT_OFFSET	0x100
+-#define MT7621_STATS_TDPC	0x00
+-#define MT7621_STATS_TCRC	0x04
+-#define MT7621_STATS_TUPC	0x08
+-#define MT7621_STATS_TMPC	0x0C
+-#define MT7621_STATS_TBPC	0x10
+-#define MT7621_STATS_TCEC	0x14
+-#define MT7621_STATS_TSCEC	0x18
+-#define MT7621_STATS_TMCEC	0x1C
+-#define MT7621_STATS_TDEC	0x20
+-#define MT7621_STATS_TLCEC	0x24
+-#define MT7621_STATS_TXCEC	0x28
+-#define MT7621_STATS_TPPC	0x2C
+-#define MT7621_STATS_TL64PC	0x30
+-#define MT7621_STATS_TL65PC	0x34
+-#define MT7621_STATS_TL128PC	0x38
+-#define MT7621_STATS_TL256PC	0x3C
+-#define MT7621_STATS_TL512PC	0x40
+-#define MT7621_STATS_TL1024PC	0x44
+-#define MT7621_STATS_TOC	0x48
+-#define MT7621_STATS_RDPC	0x60
+-#define MT7621_STATS_RFPC	0x64
+-#define MT7621_STATS_RUPC	0x68
+-#define MT7621_STATS_RMPC	0x6C
+-#define MT7621_STATS_RBPC	0x70
+-#define MT7621_STATS_RAEPC	0x74
+-#define MT7621_STATS_RCEPC	0x78
+-#define MT7621_STATS_RUSPC	0x7C
+-#define MT7621_STATS_RFEPC	0x80
+-#define MT7621_STATS_ROSPC	0x84
+-#define MT7621_STATS_RJEPC	0x88
+-#define MT7621_STATS_RPPC	0x8C
+-#define MT7621_STATS_RL64PC	0x90
+-#define MT7621_STATS_RL65PC	0x94
+-#define MT7621_STATS_RL128PC	0x98
+-#define MT7621_STATS_RL256PC	0x9C
+-#define MT7621_STATS_RL512PC	0xA0
+-#define MT7621_STATS_RL1024PC	0xA4
+-#define MT7621_STATS_ROC	0xA8
+-#define MT7621_STATS_RDPC_CTRL	0xB0
+-#define MT7621_STATS_RDPC_ING	0xB4
+-#define MT7621_STATS_RDPC_ARL	0xB8
+-
+-int mt7530_probe(struct device *dev, void __iomem *base, struct mii_bus *bus, int vlan);
+-
+-#endif
+diff --git a/drivers/net/ethernet/mtk/mtk_debugfs.c b/drivers/net/ethernet/mtk/mtk_debugfs.c
+deleted file mode 100644
+index 2938119e891e..000000000000
+--- a/drivers/net/ethernet/mtk/mtk_debugfs.c
++++ /dev/null
+@@ -1,115 +0,0 @@
+-/*   This program is free software; you can redistribute it and/or modify
+- *   it under the terms of the GNU General Public License as published by
+- *   the Free Software Foundation; version 2 of the License
+- *
+- *   This program is distributed in the hope that it will be useful,
+- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+- *   GNU General Public License for more details.
+- *
+- *   Copyright (C) 2014-2016 Sean Wang <sean.wang@mediatek.com>
+- *   Copyright (C) 2016-2017 John Crispin <blogic@openwrt.org>
+- */
+-
+-#include "mtk_offload.h"
+-
+-static const char *mtk_foe_entry_state_str[] = {
+-	"INVALID",
+-	"UNBIND",
+-	"BIND",
+-	"FIN"
+-};
+-
+-static const char *mtk_foe_packet_type_str[] = {
+-	"IPV4_HNAPT",
+-	"IPV4_HNAT",
+-	"IPV6_1T_ROUTE",
+-	"IPV4_DSLITE",
+-	"IPV6_3T_ROUTE",
+-	"IPV6_5T_ROUTE",
+-	"IPV6_6RD",
+-};
+-
+-#define IPV4_HNAPT                      0
+-#define IPV4_HNAT                       1
+-#define IS_IPV4_HNAPT(x)	(((x)->bfib1.pkt_type == IPV4_HNAPT) ? 1: 0)
+-struct mtk_eth *_eth;
+-#define es(entry)		(mtk_foe_entry_state_str[entry->bfib1.state])
+-//#define ei(entry, end)		(MTK_PPE_TBL_SZ - (int)(end - entry))
+-#define ei(entry, end)		(MTK_PPE_ENTRY_CNT - (int)(end - entry))
+-#define pt(entry)		(mtk_foe_packet_type_str[entry->ipv4_hnapt.bfib1.pkt_type])
+-
+-static int mtk_ppe_debugfs_foe_show(struct seq_file *m, void *private)
+-{
+-	struct mtk_eth *eth = _eth;
+-	struct mtk_foe_entry *entry, *end;
+-	int i = 0;
+-
+-	entry = eth->foe_table;
+-	end = eth->foe_table + MTK_PPE_ENTRY_CNT;
+-
+-	while (entry < end) {
+-		if (IS_IPV4_HNAPT(entry)) {
+-			__be32 saddr = htonl(entry->ipv4_hnapt.sip);
+-			__be32 daddr = htonl(entry->ipv4_hnapt.dip);
+-			__be32 nsaddr = htonl(entry->ipv4_hnapt.new_sip);
+-			__be32 ndaddr = htonl(entry->ipv4_hnapt.new_dip);
+-			unsigned char h_dest[ETH_ALEN];
+-			unsigned char h_source[ETH_ALEN];
+-
+-			*((u32*) h_source) = swab32(entry->ipv4_hnapt.smac_hi);
+-			*((u16*) &h_source[4]) = swab16(entry->ipv4_hnapt.smac_lo);
+-			*((u32*) h_dest) = swab32(entry->ipv4_hnapt.dmac_hi);
+-			*((u16*) &h_dest[4]) = swab16(entry->ipv4_hnapt.dmac_lo);
+-			seq_printf(m,
+-				   "(%x)0x%05x|state=%s|type=%s|"
+-				   "%pI4:%d->%pI4:%d=>%pI4:%d->%pI4:%d|%pM=>%pM|"
+-				   "etype=0x%04x|info1=0x%x|info2=0x%x|"
+-				   "vlan1=%d|vlan2=%d\n",
+-				   i,
+-				   ei(entry, end), es(entry), pt(entry),
+-				   &saddr, entry->ipv4_hnapt.sport,
+-				   &daddr, entry->ipv4_hnapt.dport,
+-				   &nsaddr, entry->ipv4_hnapt.new_sport,
+-				   &ndaddr, entry->ipv4_hnapt.new_dport, h_source,
+-				   h_dest, ntohs(entry->ipv4_hnapt.etype),
+-				   entry->ipv4_hnapt.info_blk1,
+-				   entry->ipv4_hnapt.info_blk2,
+-				   entry->ipv4_hnapt.vlan1,
+-				   entry->ipv4_hnapt.vlan2);
+-		} else
+-			seq_printf(m, "0x%05x state=%s\n",
+-				   ei(entry, end), es(entry));
+-		entry++;
+-		i++;
+-	}
+-
+-	return 0;
+-}
+-
+-static int mtk_ppe_debugfs_foe_open(struct inode *inode, struct file *file)
+-{
+-	return single_open(file, mtk_ppe_debugfs_foe_show, file->private_data);
+-}
+-
+-static const struct file_operations mtk_ppe_debugfs_foe_fops = {
+-	.open = mtk_ppe_debugfs_foe_open,
+-	.read = seq_read,
+-	.llseek = seq_lseek,
+-	.release = single_release,
+-};
+-
+-int mtk_ppe_debugfs_init(struct mtk_eth *eth)
+-{
+-	struct dentry *root;
+-
+-	_eth = eth;
+-
+-	root = debugfs_create_dir("mtk_ppe", NULL);
+-	if (!root)
+-		return -ENOMEM;
+-
+-	debugfs_create_file("all_entry", S_IRUGO, root, eth, &mtk_ppe_debugfs_foe_fops);
+-
+-	return 0;
+-}
+diff --git a/drivers/net/ethernet/mtk/mtk_offload.c b/drivers/net/ethernet/mtk/mtk_offload.c
+deleted file mode 100644
+index 3001c081f7c4..000000000000
+--- a/drivers/net/ethernet/mtk/mtk_offload.c
++++ /dev/null
+@@ -1,526 +0,0 @@
+-/*   This program is free software; you can redistribute it and/or modify
+- *   it under the terms of the GNU General Public License as published by
+- *   the Free Software Foundation; version 2 of the License
+- *
+- *   This program is distributed in the hope that it will be useful,
+- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+- *   GNU General Public License for more details.
+- *
+- *   Copyright (C) 2018 John Crispin <john@phrozen.org>
+- */
+-
+-#include "mtk_offload.h"
+-
+-#define INVALID	0
+-#define UNBIND	1
+-#define BIND	2
+-#define FIN	3
+-
+-#define IPV4_HNAPT			0
+-#define IPV4_HNAT			1
+-
+-static u32
+-mtk_flow_hash_v4(struct flow_offload_tuple *tuple)
+-{
+-	u32 ports = ntohs(tuple->src_port)  << 16 | ntohs(tuple->dst_port);
+-	u32 src = ntohl(tuple->dst_v4.s_addr);
+-	u32 dst = ntohl(tuple->src_v4.s_addr);
+-	u32 hash = (ports & src) | ((~ports) & dst);
+-	u32 hash_23_0 = hash & 0xffffff;
+-	u32 hash_31_24 = hash & 0xff000000;
+-
+-	hash = ports ^ src ^ dst ^ ((hash_23_0 << 8) | (hash_31_24 >> 24));
+-	hash = ((hash & 0xffff0000) >> 16 ) ^ (hash & 0xfffff);
+-	hash &= 0x7ff;
+-	hash *= 2;;
+-
+-	return hash;
+-}
+-
+-static int
+-mtk_foe_prepare_v4(struct mtk_foe_entry *entry,
+-		   struct flow_offload_tuple *tuple,
+-		   struct flow_offload_tuple *dest_tuple,
+-		   struct flow_offload_hw_path *src,
+-		   struct flow_offload_hw_path *dest)
+-{
+-	int is_mcast = !!is_multicast_ether_addr(dest->eth_dest);
+-
+-	if (tuple->l4proto == IPPROTO_UDP)
+-		entry->ipv4_hnapt.bfib1.udp = 1;
+-
+-	entry->ipv4_hnapt.etype = htons(ETH_P_IP);
+-	entry->ipv4_hnapt.bfib1.pkt_type = IPV4_HNAPT;
+-	entry->ipv4_hnapt.iblk2.fqos = 0;
+-	entry->ipv4_hnapt.bfib1.ttl = 1;
+-	entry->ipv4_hnapt.bfib1.cah = 1;
+-	entry->ipv4_hnapt.bfib1.ka = 1;
+-	entry->ipv4_hnapt.iblk2.mcast = is_mcast;
+-	entry->ipv4_hnapt.iblk2.dscp = 0;
+-	entry->ipv4_hnapt.iblk2.port_mg = 0x3f;
+-	entry->ipv4_hnapt.iblk2.port_ag = 0x1f;
+-#ifdef CONFIG_NET_MEDIATEK_HW_QOS
+-	entry->ipv4_hnapt.iblk2.qid = 1;
+-	entry->ipv4_hnapt.iblk2.fqos = 1;
+-#endif
+-#ifdef CONFIG_RALINK
+-	entry->ipv4_hnapt.iblk2.dp = 1;
+-	if ((dest->flags & FLOW_OFFLOAD_PATH_VLAN) && (dest->vlan_id > 1))
+-		entry->ipv4_hnapt.iblk2.qid += 8;
+-#else
+-	entry->ipv4_hnapt.iblk2.dp = (dest->dev->name[3] - '0') + 1;
+-#endif
+-
+-	entry->ipv4_hnapt.sip = ntohl(tuple->src_v4.s_addr);
+-	entry->ipv4_hnapt.dip = ntohl(tuple->dst_v4.s_addr);
+-	entry->ipv4_hnapt.sport = ntohs(tuple->src_port);
+-	entry->ipv4_hnapt.dport = ntohs(tuple->dst_port);
+-
+-	entry->ipv4_hnapt.new_sip = ntohl(dest_tuple->dst_v4.s_addr);
+-	entry->ipv4_hnapt.new_dip = ntohl(dest_tuple->src_v4.s_addr);
+-	entry->ipv4_hnapt.new_sport = ntohs(dest_tuple->dst_port);
+-	entry->ipv4_hnapt.new_dport = ntohs(dest_tuple->src_port);
+-
+-	entry->bfib1.state = BIND;
+-
+-	if (dest->flags & FLOW_OFFLOAD_PATH_PPPOE) {
+-		entry->bfib1.psn = 1;
+-		entry->ipv4_hnapt.etype = htons(ETH_P_PPP_SES);
+-		entry->ipv4_hnapt.pppoe_id = dest->pppoe_sid;
+-	}
+-
+-	if (dest->flags & FLOW_OFFLOAD_PATH_VLAN) {
+-		entry->ipv4_hnapt.vlan1 = dest->vlan_id;
+-		entry->bfib1.vlan_layer = 1;
+-
+-		switch (dest->vlan_proto) {
+-		case htons(ETH_P_8021Q):
+-			entry->ipv4_hnapt.bfib1.vpm = 1;
+-			break;
+-		case htons(ETH_P_8021AD):
+-			entry->ipv4_hnapt.bfib1.vpm = 2;
+-			break;
+-		default:
+-			return -EINVAL;
+-		}
+-	}
+-
+-	return 0;
+-}
+-
+-static void
+-mtk_foe_set_mac(struct mtk_foe_entry *entry, u8 *smac, u8 *dmac)
+-{
+-	entry->ipv4_hnapt.dmac_hi = swab32(*((u32*) dmac));
+-	entry->ipv4_hnapt.dmac_lo = swab16(*((u16*) &dmac[4]));
+-	entry->ipv4_hnapt.smac_hi = swab32(*((u32*) smac));
+-	entry->ipv4_hnapt.smac_lo = swab16(*((u16*) &smac[4]));
+-}
+-
+-static void
+-mtk_foe_write(struct mtk_eth *eth, u32 hash,
+-	      struct mtk_foe_entry *entry)
+-{
+-	struct mtk_foe_entry *table = (struct mtk_foe_entry *)eth->foe_table;
+-
+-	memcpy(&table[hash], entry, sizeof(*entry));
+-}
+-
+-int mtk_flow_offload(struct mtk_eth *eth,
+-		     enum flow_offload_type type,
+-		     struct flow_offload *flow,
+-		     struct flow_offload_hw_path *src,
+-		     struct flow_offload_hw_path *dest)
+-{
+-	struct flow_offload_tuple *otuple = &flow->tuplehash[FLOW_OFFLOAD_DIR_ORIGINAL].tuple;
+-	struct flow_offload_tuple *rtuple = &flow->tuplehash[FLOW_OFFLOAD_DIR_REPLY].tuple;
+-	u32 time_stamp = mtk_r32(eth, 0x0010) & (0x7fff);
+-	u32 ohash, rhash;
+-	struct mtk_foe_entry orig = {
+-		.bfib1.time_stamp = time_stamp,
+-		.bfib1.psn = 0,
+-	};
+-	struct mtk_foe_entry reply = {
+-		.bfib1.time_stamp = time_stamp,
+-		.bfib1.psn = 0,
+-	};
+-
+-	if (otuple->l4proto != IPPROTO_TCP && otuple->l4proto != IPPROTO_UDP)
+-		return -EINVAL;
+-
+-	switch (otuple->l3proto) {
+-	case AF_INET:
+-		if (mtk_foe_prepare_v4(&orig, otuple, rtuple, src, dest) ||
+-		    mtk_foe_prepare_v4(&reply, rtuple, otuple, dest, src))
+-			return -EINVAL;
+-
+-		ohash = mtk_flow_hash_v4(otuple);
+-		rhash = mtk_flow_hash_v4(rtuple);
+-		break;
+-
+-	case AF_INET6:
+-		return -EINVAL;
+-
+-	default:
+-		return -EINVAL;
+-	}
+-
+-	if (type == FLOW_OFFLOAD_DEL) {
+-		orig.bfib1.state = INVALID;
+-		reply.bfib1.state = INVALID;
+-		flow = NULL;
+-		goto write;
+-	}
+-
+-	mtk_foe_set_mac(&orig, dest->eth_src, dest->eth_dest);
+-	mtk_foe_set_mac(&reply, src->eth_src, src->eth_dest);
+-
+-write:
+-	mtk_foe_write(eth, ohash, &orig);
+-	mtk_foe_write(eth, rhash, &reply);
+-	rcu_assign_pointer(eth->foe_flow_table[ohash], flow);
+-	rcu_assign_pointer(eth->foe_flow_table[rhash], flow);
+-
+-	if (type == FLOW_OFFLOAD_DEL)
+-		synchronize_rcu();
+-
+-	return 0;
+-}
+-
+-#ifdef CONFIG_NET_MEDIATEK_HW_QOS
+-
+-#define QDMA_TX_SCH_TX	  0x1a14
+-
+-static void mtk_ppe_scheduler(struct mtk_eth *eth, int id, u32 rate)
+-{
+-	int exp = 0, shift = 0;
+-	u32 reg = mtk_r32(eth, QDMA_TX_SCH_TX);
+-	u32 val = 0;
+-
+-	if (rate)
+-		val = BIT(11);
+-
+-	while (rate > 127) {
+-		rate /= 10;
+-		exp++;
+-	}
+-
+-	val |= (rate & 0x7f) << 4;
+-	val |= exp & 0xf;
+-	if (id)
+-		shift = 16;
+-	reg &= ~(0xffff << shift);
+-	reg |= val << shift;
+-	mtk_w32(eth, val, QDMA_TX_SCH_TX);
+-}
+-
+-#define QTX_CFG(x)	(0x1800 + (x * 0x10))
+-#define QTX_SCH(x)	(0x1804 + (x * 0x10))
+-
+-static void mtk_ppe_queue(struct mtk_eth *eth, int id, int sched, int weight, int resv, u32 min_rate, u32 max_rate)
+-{
+-	int max_exp = 0, min_exp = 0;
+-	u32 reg;
+-
+-	if (id >= 16)
+-		return;
+-
+-	reg = mtk_r32(eth, QTX_SCH(id));
+-	reg &= 0x70000000;
+-
+-	if (sched)
+-		reg |= BIT(31);
+-
+-	if (min_rate)
+-		reg |= BIT(27);
+-
+-	if (max_rate)
+-		reg |= BIT(11);
+-
+-	while (max_rate > 127) {
+-		max_rate /= 10;
+-		max_exp++;
+-	}
+-
+-	while (min_rate > 127) {
+-		min_rate /= 10;
+-		min_exp++;
+-	}
+-
+-	reg |= (min_rate & 0x7f) << 20;
+-	reg |= (min_exp & 0xf) << 16;
+-	reg |= (weight & 0xf) << 12;
+-	reg |= (max_rate & 0x7f) << 4;
+-	reg |= max_exp & 0xf;
+-	mtk_w32(eth, reg, QTX_SCH(id));
+-
+-	resv &= 0xff;
+-	reg = mtk_r32(eth, QTX_CFG(id));
+-	reg &= 0xffff0000;
+-	reg |= (resv << 8) | resv;
+-	mtk_w32(eth, reg, QTX_CFG(id));
+-}
+-#endif
+-
+-static int mtk_init_foe_table(struct mtk_eth *eth)
+-{
+-	if (eth->foe_table)
+-		return 0;
+-
+-	eth->foe_flow_table = devm_kcalloc(eth->dev, MTK_PPE_ENTRY_CNT,
+-					   sizeof(*eth->foe_flow_table),
+-					   GFP_KERNEL);
+-	if (!eth->foe_flow_table)
+-		return -EINVAL;
+-
+-	/* map the FOE table */
+-	eth->foe_table = dmam_alloc_coherent(eth->dev, MTK_PPE_TBL_SZ,
+-					     &eth->foe_table_phys, GFP_KERNEL);
+-	if (!eth->foe_table) {
+-		dev_err(eth->dev, "failed to allocate foe table\n");
+-		kfree(eth->foe_flow_table);
+-		return -ENOMEM;
+-	}
+-
+-
+-	return 0;
+-}
+-
+-static int mtk_ppe_start(struct mtk_eth *eth)
+-{
+-	int ret;
+-
+-	ret = mtk_init_foe_table(eth);
+-	if (ret)
+-		return ret;
+-
+-	/* tell the PPE about the tables base address */
+-	mtk_w32(eth, eth->foe_table_phys, MTK_REG_PPE_TB_BASE);
+-
+-	/* flush the table */
+-	memset(eth->foe_table, 0, MTK_PPE_TBL_SZ);
+-
+-	/* setup hashing */
+-	mtk_m32(eth,
+-		MTK_PPE_TB_CFG_HASH_MODE_MASK | MTK_PPE_TB_CFG_TBL_SZ_MASK,
+-		MTK_PPE_TB_CFG_HASH_MODE1 | MTK_PPE_TB_CFG_TBL_SZ_4K,
+-		MTK_REG_PPE_TB_CFG);
+-
+-	/* set the default hashing seed */
+-	mtk_w32(eth, MTK_PPE_HASH_SEED, MTK_REG_PPE_HASH_SEED);
+-
+-	/* each foe entry is 64bytes and is setup by cpu forwarding*/
+-	mtk_m32(eth, MTK_PPE_CAH_CTRL_X_MODE | MTK_PPE_TB_CFG_ENTRY_SZ_MASK |
+-		MTK_PPE_TB_CFG_SMA_MASK,
+-		MTK_PPE_TB_CFG_ENTRY_SZ_64B |  MTK_PPE_TB_CFG_SMA_FWD_CPU,
+-		MTK_REG_PPE_TB_CFG);
+-
+-	/* set ip proto */
+-	mtk_w32(eth, 0xFFFFFFFF, MTK_REG_PPE_IP_PROT_CHK);
+-
+-	/* setup caching */
+-	mtk_m32(eth, 0, MTK_PPE_CAH_CTRL_X_MODE, MTK_REG_PPE_CAH_CTRL);
+-	mtk_m32(eth, MTK_PPE_CAH_CTRL_X_MODE, MTK_PPE_CAH_CTRL_EN,
+-		MTK_REG_PPE_CAH_CTRL);
+-
+-	/* enable FOE */
+-	mtk_m32(eth, 0, MTK_PPE_FLOW_CFG_IPV4_NAT_FRAG_EN |
+-		MTK_PPE_FLOW_CFG_IPV4_NAPT_EN | MTK_PPE_FLOW_CFG_IPV4_NAT_EN |
+-		MTK_PPE_FLOW_CFG_IPV4_GREK_EN,
+-		MTK_REG_PPE_FLOW_CFG);
+-
+-	/* setup flow entry un/bind aging */
+-	mtk_m32(eth, 0,
+-		MTK_PPE_TB_CFG_UNBD_AGE | MTK_PPE_TB_CFG_NTU_AGE |
+-		MTK_PPE_TB_CFG_FIN_AGE | MTK_PPE_TB_CFG_UDP_AGE |
+-		MTK_PPE_TB_CFG_TCP_AGE,
+-		MTK_REG_PPE_TB_CFG);
+-
+-	mtk_m32(eth, MTK_PPE_UNB_AGE_MNP_MASK | MTK_PPE_UNB_AGE_DLTA_MASK,
+-		MTK_PPE_UNB_AGE_MNP | MTK_PPE_UNB_AGE_DLTA,
+-		MTK_REG_PPE_UNB_AGE);
+-	mtk_m32(eth, MTK_PPE_BND_AGE0_NTU_DLTA_MASK |
+-		MTK_PPE_BND_AGE0_UDP_DLTA_MASK,
+-		MTK_PPE_BND_AGE0_NTU_DLTA | MTK_PPE_BND_AGE0_UDP_DLTA,
+-		MTK_REG_PPE_BND_AGE0);
+-	mtk_m32(eth, MTK_PPE_BND_AGE1_FIN_DLTA_MASK |
+-		MTK_PPE_BND_AGE1_TCP_DLTA_MASK,
+-		MTK_PPE_BND_AGE1_FIN_DLTA | MTK_PPE_BND_AGE1_TCP_DLTA,
+-		MTK_REG_PPE_BND_AGE1);
+-
+-	/* setup flow entry keep alive */
+-	mtk_m32(eth, MTK_PPE_TB_CFG_KA_MASK, MTK_PPE_TB_CFG_KA,
+-		MTK_REG_PPE_TB_CFG);
+-	mtk_w32(eth, MTK_PPE_KA_UDP | MTK_PPE_KA_TCP | MTK_PPE_KA_T, MTK_REG_PPE_KA);
+-
+-	/* setup flow entry rate limit */
+-	mtk_w32(eth, (0x3fff << 16) | 0x3fff, MTK_REG_PPE_BIND_LMT_0);
+-	mtk_w32(eth, MTK_PPE_NTU_KA | 0x3fff, MTK_REG_PPE_BIND_LMT_1);
+-	mtk_m32(eth, MTK_PPE_BNDR_RATE_MASK, 1, MTK_REG_PPE_BNDR);
+-
+-	/* enable the PPE */
+-	mtk_m32(eth, 0, MTK_PPE_GLO_CFG_EN, MTK_REG_PPE_GLO_CFG);
+-
+-#ifdef CONFIG_RALINK
+-	/* set the default forwarding port to QDMA */
+-	mtk_w32(eth, 0x0, MTK_REG_PPE_DFT_CPORT);
+-#else
+-	/* set the default forwarding port to QDMA */
+-	mtk_w32(eth, 0x55555555, MTK_REG_PPE_DFT_CPORT);
+-#endif
+-
+-	/* drop packets with TTL=0 */
+-	mtk_m32(eth, 0, MTK_PPE_GLO_CFG_TTL0_DROP, MTK_REG_PPE_GLO_CFG);
+-
+-	/* send all traffic from gmac to the ppe */
+-	mtk_m32(eth, 0xffff, 0x4444, MTK_GDMA_FWD_CFG(0));
+-	mtk_m32(eth, 0xffff, 0x4444, MTK_GDMA_FWD_CFG(1));
+-
+-	dev_info(eth->dev, "PPE started\n");
+-
+-#ifdef CONFIG_NET_MEDIATEK_HW_QOS
+-	mtk_ppe_scheduler(eth, 0, 500000);
+-	mtk_ppe_scheduler(eth, 1, 500000);
+-	mtk_ppe_queue(eth, 0, 0, 7, 32, 250000, 0);
+-	mtk_ppe_queue(eth, 1, 0, 7, 32, 250000, 0);
+-	mtk_ppe_queue(eth, 8, 1, 7, 32, 250000, 0);
+-	mtk_ppe_queue(eth, 9, 1, 7, 32, 250000, 0);
+-#endif
+-
+-	return 0;
+-}
+-
+-static int mtk_ppe_busy_wait(struct mtk_eth *eth)
+-{
+-	unsigned long t_start = jiffies;
+-	u32 r = 0;
+-
+-	while (1) {
+-		r = mtk_r32(eth, MTK_REG_PPE_GLO_CFG);
+-		if (!(r & MTK_PPE_GLO_CFG_BUSY))
+-			return 0;
+-		if (time_after(jiffies, t_start + HZ))
+-			break;
+-		usleep_range(10, 20);
+-	}
+-
+-	dev_err(eth->dev, "ppe: table busy timeout - resetting\n");
+-	reset_control_reset(eth->rst_ppe);
+-
+-	return -ETIMEDOUT;
+-}
+-
+-static int mtk_ppe_stop(struct mtk_eth *eth)
+-{
+-	u32 r1 = 0, r2 = 0;
+-	int i;
+-
+-	/* discard all traffic while we disable the PPE */
+-	mtk_m32(eth, 0xffff, 0x7777, MTK_GDMA_FWD_CFG(0));
+-	mtk_m32(eth, 0xffff, 0x7777, MTK_GDMA_FWD_CFG(1));
+-
+-	if (mtk_ppe_busy_wait(eth))
+-		return -ETIMEDOUT;
+-
+-	/* invalidate all flow table entries */
+-	for (i = 0; i < MTK_PPE_ENTRY_CNT; i++)
+-		eth->foe_table[i].bfib1.state = FOE_STATE_INVALID;
+-
+-	/* disable caching */
+-	mtk_m32(eth, 0, MTK_PPE_CAH_CTRL_X_MODE, MTK_REG_PPE_CAH_CTRL);
+-	mtk_m32(eth, MTK_PPE_CAH_CTRL_X_MODE | MTK_PPE_CAH_CTRL_EN, 0,
+-		MTK_REG_PPE_CAH_CTRL);
+-
+-	/* flush cache has to be ahead of hnat diable --*/
+-	mtk_m32(eth, MTK_PPE_GLO_CFG_EN, 0, MTK_REG_PPE_GLO_CFG);
+-
+-	/* disable FOE */
+-	mtk_m32(eth,
+-		MTK_PPE_FLOW_CFG_IPV4_NAT_FRAG_EN |
+-		MTK_PPE_FLOW_CFG_IPV4_NAPT_EN | MTK_PPE_FLOW_CFG_IPV4_NAT_EN |
+-		MTK_PPE_FLOW_CFG_FUC_FOE | MTK_PPE_FLOW_CFG_FMC_FOE,
+-		0, MTK_REG_PPE_FLOW_CFG);
+-
+-	/* disable FOE aging */
+-	mtk_m32(eth, 0,
+-		MTK_PPE_TB_CFG_FIN_AGE | MTK_PPE_TB_CFG_UDP_AGE |
+-		MTK_PPE_TB_CFG_TCP_AGE | MTK_PPE_TB_CFG_UNBD_AGE |
+-		MTK_PPE_TB_CFG_NTU_AGE, MTK_REG_PPE_TB_CFG);
+-
+-	r1 = mtk_r32(eth, 0x100);
+-	r2 = mtk_r32(eth, 0x10c);
+-
+-	dev_info(eth->dev, "0x100 = 0x%x, 0x10c = 0x%x\n", r1, r2);
+-
+-	if (((r1 & 0xff00) >> 0x8) >= (r1 & 0xff) ||
+-	    ((r1 & 0xff00) >> 0x8) >= (r2 & 0xff)) {
+-		dev_info(eth->dev, "reset pse\n");
+-		mtk_w32(eth, 0x1, 0x4);
+-	}
+-
+-	/* set the foe entry base address to 0 */
+-	mtk_w32(eth, 0, MTK_REG_PPE_TB_BASE);
+-
+-	if (mtk_ppe_busy_wait(eth))
+-		return -ETIMEDOUT;
+-
+-	/* send all traffic back to the DMA engine */
+-#ifdef CONFIG_RALINK
+-	mtk_m32(eth, 0xffff, 0x0, MTK_GDMA_FWD_CFG(0));
+-	mtk_m32(eth, 0xffff, 0x0, MTK_GDMA_FWD_CFG(1));
+-#else
+-	mtk_m32(eth, 0xffff, 0x5555, MTK_GDMA_FWD_CFG(0));
+-	mtk_m32(eth, 0xffff, 0x5555, MTK_GDMA_FWD_CFG(1));
+-#endif
+-	return 0;
+-}
+-
+-static void mtk_offload_keepalive(struct fe_priv *eth, unsigned int hash)
+-{
+-	struct flow_offload *flow;
+-
+-	rcu_read_lock();
+-	flow = rcu_dereference(eth->foe_flow_table[hash]);
+-	if (flow)
+-		flow->timeout = jiffies + 30 * HZ;
+-	rcu_read_unlock();
+-}
+-
+-int mtk_offload_check_rx(struct fe_priv *eth, struct sk_buff *skb, u32 rxd4)
+-{
+-	unsigned int hash;
+-
+-	switch (FIELD_GET(MTK_RXD4_CPU_REASON, rxd4)) {
+-	case MTK_CPU_REASON_KEEPALIVE_UC_OLD_HDR:
+-	case MTK_CPU_REASON_KEEPALIVE_MC_NEW_HDR:
+-	case MTK_CPU_REASON_KEEPALIVE_DUP_OLD_HDR:
+-		hash = FIELD_GET(MTK_RXD4_FOE_ENTRY, rxd4);
+-		mtk_offload_keepalive(eth, hash);
+-		return -1;
+-	case MTK_CPU_REASON_PACKET_SAMPLING:
+-		return -1;
+-	default:
+-		return 0;
+-	}
+-}
+-
+-int mtk_ppe_probe(struct mtk_eth *eth)
+-{
+-	int err;
+-
+-	err = mtk_ppe_start(eth);
+-	if (err)
+-		return err;
+-
+-	err = mtk_ppe_debugfs_init(eth);
+-	if (err)
+-		return err;
+-
+-	return 0;
+-}
+-
+-void mtk_ppe_remove(struct mtk_eth *eth)
+-{
+-	mtk_ppe_stop(eth);
+-}
+diff --git a/drivers/net/ethernet/mtk/mtk_offload.h b/drivers/net/ethernet/mtk/mtk_offload.h
+deleted file mode 100644
+index f714c90f9225..000000000000
+--- a/drivers/net/ethernet/mtk/mtk_offload.h
++++ /dev/null
+@@ -1,260 +0,0 @@
+-/*   This program is free software; you can redistribute it and/or modify
+- *   it under the terms of the GNU General Public License as published by
+- *   the Free Software Foundation; version 2 of the License
+- *
+- *   This program is distributed in the hope that it will be useful,
+- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+- *   GNU General Public License for more details.
+- *
+- *   Copyright (C) 2014-2016 Sean Wang <sean.wang@mediatek.com>
+- *   Copyright (C) 2016-2017 John Crispin <blogic@openwrt.org>
+- */
+-
+-#include <linux/dma-mapping.h>
+-#include <linux/delay.h>
+-#include <linux/if.h>
+-#include <linux/io.h>
+-#include <linux/module.h>
+-#include <linux/of_device.h>
+-#include <linux/platform_device.h>
+-#include <linux/reset.h>
+-#include <linux/netfilter.h>
+-#include <linux/netdevice.h>
+-#include <net/netfilter/nf_flow_table.h>
+-#include <linux/debugfs.h>
+-#include <linux/etherdevice.h>
+-#include <linux/bitfield.h>
+-
+-#include "mtk_eth_soc.h"
+-
+-#ifdef CONFIG_RALINK
+-/* ramips compat */
+-#define mtk_eth					fe_priv
+-#define MTK_GDMA_FWD_CFG(x)			(0x500 + (x * 0x1000))
+-#define mtk_m32					fe_m32
+-
+-static inline u32
+-mtk_r32(struct mtk_eth *eth, u32 reg)
+-{
+-	return fe_r32(reg);
+-}
+-
+-static inline void
+-mtk_w32(struct mtk_eth *eth, u32 val, u32 reg)
+-{
+-	fe_w32(val, reg);
+-}
+-#endif
+-
+-#define MTK_REG_PPE_GLO_CFG			0xe00
+-#define   MTK_PPE_GLO_CFG_BUSY			BIT(31)
+-#define   MTK_PPE_GLO_CFG_TTL0_DROP		BIT(4)
+-#define   MTK_PPE_GLO_CFG_EN			BIT(0)
+-
+-#define MTK_REG_PPE_FLOW_CFG			0xe04
+-#define   MTK_PPE_FLOW_CFG_IPV4_GREK_EN		BIT(19)
+-#define   MTK_PPE_FLOW_CFG_IPV4_NAT_FRAG_EN	BIT(17)
+-#define   MTK_PPE_FLOW_CFG_IPV4_NAPT_EN		BIT(13)
+-#define   MTK_PPE_FLOW_CFG_IPV4_NAT_EN		BIT(12)
+-#define   MTK_PPE_FLOW_CFG_FUC_FOE		BIT(2)
+-#define   MTK_PPE_FLOW_CFG_FMC_FOE		BIT(1)
+-
+-#define MTK_REG_PPE_IP_PROT_CHK			0xe08
+-
+-#define MTK_REG_PPE_TB_BASE			0xe20
+-
+-#define MTK_REG_PPE_BNDR			0xe28
+-#define   MTK_PPE_BNDR_RATE_MASK		0xffff
+-
+-#define MTK_REG_PPE_BIND_LMT_0			0xe2C
+-
+-#define MTK_REG_PPE_BIND_LMT_1			0xe30
+-#define   MTK_PPE_NTU_KA			BIT(16)
+-
+-#define MTK_REG_PPE_KA				0xe34
+-#define   MTK_PPE_KA_T				BIT(0)
+-#define   MTK_PPE_KA_TCP			BIT(16)
+-#define   MTK_PPE_KA_UDP			BIT(24)
+-
+-#define MTK_REG_PPE_UNB_AGE			0xe38
+-#define   MTK_PPE_UNB_AGE_MNP_MASK		(0xffff << 16)
+-#define   MTK_PPE_UNB_AGE_MNP			(1000 << 16)
+-#define   MTK_PPE_UNB_AGE_DLTA_MASK		0xff
+-#define   MTK_PPE_UNB_AGE_DLTA			3
+-
+-#define MTK_REG_PPE_BND_AGE0			0xe3c
+-#define   MTK_PPE_BND_AGE0_NTU_DLTA_MASK	(0xffff << 16)
+-#define   MTK_PPE_BND_AGE0_NTU_DLTA		(5 << 16)
+-#define   MTK_PPE_BND_AGE0_UDP_DLTA_MASK	0xffff
+-#define   MTK_PPE_BND_AGE0_UDP_DLTA		5
+-
+-#define MTK_REG_PPE_BND_AGE1			0xe40
+-#define   MTK_PPE_BND_AGE1_FIN_DLTA_MASK	(0xffff << 16)
+-#define   MTK_PPE_BND_AGE1_FIN_DLTA		(5 << 16)
+-#define   MTK_PPE_BND_AGE1_TCP_DLTA_MASK	0xffff
+-#define   MTK_PPE_BND_AGE1_TCP_DLTA		5
+-
+-#define MTK_REG_PPE_DFT_CPORT			0xe48
+-
+-#define MTK_REG_PPE_TB_CFG			0xe1c
+-#define   MTK_PPE_TB_CFG_X_MODE_MASK		(3 << 18)
+-#define   MTK_PPE_TB_CFG_HASH_MODE1		BIT(14)
+-#define   MTK_PPE_TB_CFG_HASH_MODE_MASK		(0x3 << 14)
+-#define   MTK_PPE_TB_CFG_KA			(3 << 12)
+-#define   MTK_PPE_TB_CFG_KA_MASK		(0x3 << 12)
+-#define   MTK_PPE_TB_CFG_FIN_AGE		BIT(11)
+-#define   MTK_PPE_TB_CFG_UDP_AGE		BIT(10)
+-#define   MTK_PPE_TB_CFG_TCP_AGE		BIT(9)
+-#define   MTK_PPE_TB_CFG_UNBD_AGE		BIT(8)
+-#define   MTK_PPE_TB_CFG_NTU_AGE		BIT(7)
+-#define   MTK_PPE_TB_CFG_SMA_FWD_CPU		(0x3 << 4)
+-#define   MTK_PPE_TB_CFG_SMA_MASK		(0x3 << 4)
+-#define   MTK_PPE_TB_CFG_ENTRY_SZ_64B		0
+-#define   MTK_PPE_TB_CFG_ENTRY_SZ_MASK		BIT(3)
+-#define   MTK_PPE_TB_CFG_TBL_SZ_4K		2
+-#define   MTK_PPE_TB_CFG_TBL_SZ_MASK		0x7
+-
+-#define MTK_REG_PPE_HASH_SEED			0xe44
+-#define   MTK_PPE_HASH_SEED			0x12345678
+-
+-
+-#define MTK_REG_PPE_CAH_CTRL			0xf20
+-#define   MTK_PPE_CAH_CTRL_X_MODE		BIT(9)
+-#define   MTK_PPE_CAH_CTRL_EN			BIT(0)
+-
+-struct mtk_foe_unbind_info_blk {
+-	u32 time_stamp:8;
+-	u32 pcnt:16;		/* packet count */
+-	u32 preb:1;
+-	u32 pkt_type:3;
+-	u32 state:2;
+-	u32 udp:1;
+-	u32 sta:1;		/* static entry */
+-} __attribute__ ((packed));
+-
+-struct mtk_foe_bind_info_blk {
+-	u32 time_stamp:15;
+-	u32 ka:1;		/* keep alive */
+-	u32 vlan_layer:3;
+-	u32 psn:1;		/* egress packet has PPPoE session */
+-#ifdef CONFIG_RALINK
+-	u32 vpm:2;		/* 0:ethertype remark, 1:0x8100(CR default) */
+-#else
+-	u32 vpm:1;		/* 0:ethertype remark, 1:0x8100(CR default) */
+-	u32 ps:1;		/* packet sampling */
+-#endif
+-	u32 cah:1;		/* cacheable flag */
+-	u32 rmt:1;		/* remove tunnel ip header (6rd/dslite only) */
+-	u32 ttl:1;
+-	u32 pkt_type:3;
+-	u32 state:2;
+-	u32 udp:1;
+-	u32 sta:1;		/* static entry */
+-} __attribute__ ((packed));
+-
+-struct mtk_foe_info_blk2 {
+-	u32 qid:4;		/* QID in Qos Port */
+-	u32 fqos:1;		/* force to PSE QoS port */
+-	u32 dp:3;		/* force to PSE port x 
+-				 0:PSE,1:GSW, 2:GMAC,4:PPE,5:QDMA,7=DROP */
+-	u32 mcast:1;		/* multicast this packet to CPU */
+-	u32 pcpl:1;		/* OSBN */
+-	u32 mlen:1;		/* 0:post 1:pre packet length in meter */
+-	u32 alen:1;		/* 0:post 1:pre packet length in accounting */
+-	u32 port_mg:6;		/* port meter group */
+-	u32 port_ag:6;		/* port account group */
+-	u32 dscp:8;		/* DSCP value */
+-} __attribute__ ((packed));
+-
+-struct mtk_foe_ipv4_hnapt {
+-	union {
+-		struct mtk_foe_bind_info_blk bfib1;
+-		struct mtk_foe_unbind_info_blk udib1;
+-		u32 info_blk1;
+-	};
+-	u32 sip;
+-	u32 dip;
+-	u16 dport;
+-	u16 sport;
+-	union {
+-		struct mtk_foe_info_blk2 iblk2;
+-		u32 info_blk2;
+-	};
+-	u32 new_sip;
+-	u32 new_dip;
+-	u16 new_dport;
+-	u16 new_sport;
+-	u32 resv1;
+-	u32 resv2;
+-	u32 resv3:26;
+-	u32 act_dp:6;		/* UDF */
+-	u16 vlan1;
+-	u16 etype;
+-	u32 dmac_hi;
+-	u16 vlan2;
+-	u16 dmac_lo;
+-	u32 smac_hi;
+-	u16 pppoe_id;
+-	u16 smac_lo;
+-} __attribute__ ((packed));
+-
+-struct mtk_foe_entry {
+-	union {
+-		struct mtk_foe_unbind_info_blk udib1;
+-		struct mtk_foe_bind_info_blk bfib1;
+-		struct mtk_foe_ipv4_hnapt ipv4_hnapt;
+-	};
+-};
+-
+-enum mtk_foe_entry_state {
+-	FOE_STATE_INVALID = 0,
+-	FOE_STATE_UNBIND = 1,
+-	FOE_STATE_BIND = 2,
+-	FOE_STATE_FIN = 3
+-};
+-
+-
+-#define MTK_RXD4_FOE_ENTRY		GENMASK(13, 0)
+-#define MTK_RXD4_CPU_REASON		GENMASK(18, 14)
+-#define MTK_RXD4_SRC_PORT		GENMASK(21, 19)
+-#define MTK_RXD4_ALG			GENMASK(31, 22)
+-
+-enum mtk_foe_cpu_reason {
+-	MTK_CPU_REASON_TTL_EXCEEDED		= 0x02,
+-	MTK_CPU_REASON_OPTION_HEADER		= 0x03,
+-	MTK_CPU_REASON_NO_FLOW			= 0x07,
+-	MTK_CPU_REASON_IPV4_FRAG		= 0x08,
+-	MTK_CPU_REASON_IPV4_DSLITE_FRAG		= 0x09,
+-	MTK_CPU_REASON_IPV4_DSLITE_NO_TCP_UDP	= 0x0a,
+-	MTK_CPU_REASON_IPV6_6RD_NO_TCP_UDP	= 0x0b,
+-	MTK_CPU_REASON_TCP_FIN_SYN_RST		= 0x0c,
+-	MTK_CPU_REASON_UN_HIT			= 0x0d,
+-	MTK_CPU_REASON_HIT_UNBIND		= 0x0e,
+-	MTK_CPU_REASON_HIT_UNBIND_RATE_REACHED	= 0x0f,
+-	MTK_CPU_REASON_HIT_BIND_TCP_FIN		= 0x10,
+-	MTK_CPU_REASON_HIT_TTL_1		= 0x11,
+-	MTK_CPU_REASON_HIT_BIND_VLAN_VIOLATION	= 0x12,
+-	MTK_CPU_REASON_KEEPALIVE_UC_OLD_HDR	= 0x13,
+-	MTK_CPU_REASON_KEEPALIVE_MC_NEW_HDR	= 0x14,
+-	MTK_CPU_REASON_KEEPALIVE_DUP_OLD_HDR	= 0x15,
+-	MTK_CPU_REASON_HIT_BIND_FORCE_CPU	= 0x16,
+-	MTK_CPU_REASON_TUNNEL_OPTION_HEADER	= 0x17,
+-	MTK_CPU_REASON_MULTICAST_TO_CPU		= 0x18,
+-	MTK_CPU_REASON_MULTICAST_TO_GMAC1_CPU	= 0x19,
+-	MTK_CPU_REASON_HIT_PRE_BIND		= 0x1a,
+-	MTK_CPU_REASON_PACKET_SAMPLING		= 0x1b,
+-	MTK_CPU_REASON_EXCEED_MTU		= 0x1c,
+-	MTK_CPU_REASON_PPE_BYPASS		= 0x1e,
+-	MTK_CPU_REASON_INVALID			= 0x1f,
+-};
+-
+-
+-/* our table size is 4K */
+-#define MTK_PPE_ENTRY_CNT		0x1000
+-#define MTK_PPE_TBL_SZ			\
+-			(MTK_PPE_ENTRY_CNT * sizeof(struct mtk_foe_entry))
+-
+-int mtk_ppe_debugfs_init(struct mtk_eth *eth);
+-
+-
+diff --git a/drivers/net/ethernet/mtk/soc_mt7620.c b/drivers/net/ethernet/mtk/soc_mt7620.c
+deleted file mode 100644
+index 7f728d142de4..000000000000
+--- a/drivers/net/ethernet/mtk/soc_mt7620.c
++++ /dev/null
+@@ -1,335 +0,0 @@
+-/*   This program is free software; you can redistribute it and/or modify
+- *   it under the terms of the GNU General Public License as published by
+- *   the Free Software Foundation; version 2 of the License
+- *
+- *   This program is distributed in the hope that it will be useful,
+- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+- *   GNU General Public License for more details.
+- *
+- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
+- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
+- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
+- */
+-
+-#include <linux/module.h>
+-#include <linux/platform_device.h>
+-#include <linux/if_vlan.h>
+-#include <linux/of_net.h>
+-
+-#include <asm/mach-ralink/ralink_regs.h>
+-
+-#include <mt7620.h>
+-#include "mtk_eth_soc.h"
+-#include "gsw_mt7620.h"
+-#include "mt7530.h"
+-#include "mdio.h"
+-
+-#define MT7620A_CDMA_CSG_CFG	0x400
+-#define MT7620_DMA_VID		(MT7620A_CDMA_CSG_CFG | 0x30)
+-#define MT7621_CDMP_IG_CTRL	(MT7620A_CDMA_CSG_CFG + 0x00)
+-#define MT7621_CDMP_EG_CTRL	(MT7620A_CDMA_CSG_CFG + 0x04)
+-#define MT7620A_RESET_FE	BIT(21)
+-#define MT7621_RESET_FE		BIT(6)
+-#define MT7620A_RESET_ESW	BIT(23)
+-#define MT7620_L4_VALID		BIT(23)
+-#define MT7621_L4_VALID		BIT(24)
+-
+-#define MT7620_TX_DMA_UDF	BIT(15)
+-#define MT7621_TX_DMA_UDF	BIT(19)
+-#define TX_DMA_FP_BMAP		((0xff) << 19)
+-
+-#define CDMA_ICS_EN		BIT(2)
+-#define CDMA_UCS_EN		BIT(1)
+-#define CDMA_TCS_EN		BIT(0)
+-
+-#define GDMA_ICS_EN		BIT(22)
+-#define GDMA_TCS_EN		BIT(21)
+-#define GDMA_UCS_EN		BIT(20)
+-
+-/* frame engine counters */
+-#define MT7620_REG_MIB_OFFSET	0x1000
+-#define MT7620_PPE_AC_BCNT0	(MT7620_REG_MIB_OFFSET + 0x00)
+-#define MT7620_GDM1_TX_GBCNT	(MT7620_REG_MIB_OFFSET + 0x300)
+-#define MT7620_GDM2_TX_GBCNT	(MT7620_GDM1_TX_GBCNT + 0x40)
+-
+-#define MT7621_REG_MIB_OFFSET	0x2000
+-#define MT7621_PPE_AC_BCNT0	(MT7621_REG_MIB_OFFSET + 0x00)
+-#define MT7621_GDM1_TX_GBCNT	(MT7621_REG_MIB_OFFSET + 0x400)
+-#define MT7621_GDM2_TX_GBCNT	(MT7621_GDM1_TX_GBCNT + 0x40)
+-
+-#define GSW_REG_GDMA1_MAC_ADRL	0x508
+-#define GSW_REG_GDMA1_MAC_ADRH	0x50C
+-
+-#define MT7621_FE_RST_GL	(FE_FE_OFFSET + 0x04)
+-#define MT7620_FE_INT_STATUS2	(FE_FE_OFFSET + 0x08)
+-
+-/* FE_INT_STATUS reg on mt7620 define CNT_GDM1_AF at BIT(29)
+- * but after test it should be BIT(13).
+- */
+-#define MT7620_FE_GDM1_AF	BIT(13)
+-#define MT7621_FE_GDM1_AF	BIT(28)
+-#define MT7621_FE_GDM2_AF	BIT(29)
+-
+-static const u16 mt7620_reg_table[FE_REG_COUNT] = {
+-	[FE_REG_PDMA_GLO_CFG] = RT5350_PDMA_GLO_CFG,
+-	[FE_REG_PDMA_RST_CFG] = RT5350_PDMA_RST_CFG,
+-	[FE_REG_DLY_INT_CFG] = RT5350_DLY_INT_CFG,
+-	[FE_REG_TX_BASE_PTR0] = RT5350_TX_BASE_PTR0,
+-	[FE_REG_TX_MAX_CNT0] = RT5350_TX_MAX_CNT0,
+-	[FE_REG_TX_CTX_IDX0] = RT5350_TX_CTX_IDX0,
+-	[FE_REG_TX_DTX_IDX0] = RT5350_TX_DTX_IDX0,
+-	[FE_REG_RX_BASE_PTR0] = RT5350_RX_BASE_PTR0,
+-	[FE_REG_RX_MAX_CNT0] = RT5350_RX_MAX_CNT0,
+-	[FE_REG_RX_CALC_IDX0] = RT5350_RX_CALC_IDX0,
+-	[FE_REG_RX_DRX_IDX0] = RT5350_RX_DRX_IDX0,
+-	[FE_REG_FE_INT_ENABLE] = RT5350_FE_INT_ENABLE,
+-	[FE_REG_FE_INT_STATUS] = RT5350_FE_INT_STATUS,
+-	[FE_REG_FE_DMA_VID_BASE] = MT7620_DMA_VID,
+-	[FE_REG_FE_COUNTER_BASE] = MT7620_GDM1_TX_GBCNT,
+-	[FE_REG_FE_RST_GL] = MT7621_FE_RST_GL,
+-	[FE_REG_FE_INT_STATUS2] = MT7620_FE_INT_STATUS2,
+-};
+-
+-static int mt7620_gsw_config(struct fe_priv *priv)
+-{
+-	struct mt7620_gsw *gsw = (struct mt7620_gsw *) priv->soc->swpriv;
+-
+-	/* is the mt7530 internal or external */
+-	if (priv->mii_bus && mdiobus_get_phy(priv->mii_bus, 0x1f)) {
+-		mt7530_probe(priv->dev, gsw->base, NULL, 0);
+-		mt7530_probe(priv->dev, NULL, priv->mii_bus, 1);
+-	} else {
+-		mt7530_probe(priv->dev, gsw->base, NULL, 1);
+-	}
+-
+-	return 0;
+-}
+-
+-static void mt7620_set_mac(struct fe_priv *priv, unsigned char *mac)
+-{
+-	struct mt7620_gsw *gsw = (struct mt7620_gsw *)priv->soc->swpriv;
+-	unsigned long flags;
+-
+-	spin_lock_irqsave(&priv->page_lock, flags);
+-	mtk_switch_w32(gsw, (mac[0] << 8) | mac[1], GSW_REG_SMACCR1);
+-	mtk_switch_w32(gsw, (mac[2] << 24) | (mac[3] << 16) | (mac[4] << 8) | mac[5],
+-		GSW_REG_SMACCR0);
+-	spin_unlock_irqrestore(&priv->page_lock, flags);
+-}
+-
+-static void mt7620_auto_poll(struct mt7620_gsw *gsw)
+-{
+-	int phy;
+-	int lsb = -1, msb = 0;
+-
+-	for_each_set_bit(phy, &gsw->autopoll, 32) {
+-		if (lsb < 0)
+-			lsb = phy;
+-		msb = phy;
+-	}
+-
+-	if (lsb == msb)
+-		lsb--;
+-
+-	mtk_switch_w32(gsw, PHY_AN_EN | PHY_PRE_EN | PMY_MDC_CONF(5) |
+-		(msb << 8) | lsb, ESW_PHY_POLLING);
+-}
+-
+-static void mt7620_port_init(struct fe_priv *priv, struct device_node *np)
+-{
+-	struct mt7620_gsw *gsw = (struct mt7620_gsw *)priv->soc->swpriv;
+-	const __be32 *_id = of_get_property(np, "reg", NULL);
+-	int phy_mode, size, id;
+-	int shift = 12;
+-	u32 val, mask = 0;
+-	int min = (gsw->port4 == PORT4_EPHY) ? (5) : (4);
+-
+-	if (!_id || (be32_to_cpu(*_id) < min) || (be32_to_cpu(*_id) > 5)) {
+-		if (_id)
+-			pr_err("%s: invalid port id %d\n", np->name,
+-			       be32_to_cpu(*_id));
+-		else
+-			pr_err("%s: invalid port id\n", np->name);
+-		return;
+-	}
+-
+-	id = be32_to_cpu(*_id);
+-
+-	if (id == 4)
+-		shift = 14;
+-
+-	priv->phy->phy_fixed[id] = of_get_property(np, "mediatek,fixed-link",
+-						   &size);
+-	if (priv->phy->phy_fixed[id] &&
+-	    (size != (4 * sizeof(*priv->phy->phy_fixed[id])))) {
+-		pr_err("%s: invalid fixed link property\n", np->name);
+-		priv->phy->phy_fixed[id] = NULL;
+-		return;
+-	}
+-
+-	phy_mode = of_get_phy_mode(np);
+-	switch (phy_mode) {
+-	case PHY_INTERFACE_MODE_RGMII:
+-		mask = 0;
+-		break;
+-	case PHY_INTERFACE_MODE_MII:
+-		mask = 1;
+-		break;
+-	case PHY_INTERFACE_MODE_RMII:
+-		mask = 2;
+-		break;
+-	default:
+-		dev_err(priv->dev, "port %d - invalid phy mode\n", id);
+-		return;
+-	}
+-
+-	priv->phy->phy_node[id] = of_parse_phandle(np, "phy-handle", 0);
+-	if (!priv->phy->phy_node[id] && !priv->phy->phy_fixed[id])
+-		return;
+-
+-	val = rt_sysc_r32(SYSC_REG_CFG1);
+-	val &= ~(3 << shift);
+-	val |= mask << shift;
+-	rt_sysc_w32(val, SYSC_REG_CFG1);
+-
+-	if (priv->phy->phy_fixed[id]) {
+-		const __be32 *link = priv->phy->phy_fixed[id];
+-		int tx_fc, rx_fc;
+-		u32 val = 0;
+-
+-		priv->phy->speed[id] = be32_to_cpup(link++);
+-		tx_fc = be32_to_cpup(link++);
+-		rx_fc = be32_to_cpup(link++);
+-		priv->phy->duplex[id] = be32_to_cpup(link++);
+-		priv->link[id] = 1;
+-
+-		switch (priv->phy->speed[id]) {
+-		case SPEED_10:
+-			val = 0;
+-			break;
+-		case SPEED_100:
+-			val = 1;
+-			break;
+-		case SPEED_1000:
+-			val = 2;
+-			break;
+-		default:
+-			dev_err(priv->dev, "invalid link speed: %d\n",
+-				priv->phy->speed[id]);
+-			priv->phy->phy_fixed[id] = 0;
+-			return;
+-		}
+-		val = PMCR_SPEED(val);
+-		val |= PMCR_LINK | PMCR_BACKPRES | PMCR_BACKOFF | PMCR_RX_EN |
+-			PMCR_TX_EN | PMCR_FORCE | PMCR_MAC_MODE | PMCR_IPG;
+-		if (tx_fc)
+-			val |= PMCR_TX_FC;
+-		if (rx_fc)
+-			val |= PMCR_RX_FC;
+-		if (priv->phy->duplex[id])
+-			val |= PMCR_DUPLEX;
+-		mtk_switch_w32(gsw, val, GSW_REG_PORT_PMCR(id));
+-		dev_info(priv->dev, "using fixed link parameters\n");
+-		return;
+-	}
+-
+-	if (priv->phy->phy_node[id] && mdiobus_get_phy(priv->mii_bus, id)) {
+-		u32 val = PMCR_BACKPRES | PMCR_BACKOFF | PMCR_RX_EN |
+-			PMCR_TX_EN |  PMCR_MAC_MODE | PMCR_IPG;
+-
+-		mtk_switch_w32(gsw, val, GSW_REG_PORT_PMCR(id));
+-		fe_connect_phy_node(priv, priv->phy->phy_node[id]);
+-		gsw->autopoll |= BIT(id);
+-		mt7620_auto_poll(gsw);
+-		return;
+-	}
+-}
+-
+-static void mt7620_fe_reset(void)
+-{
+-	fe_reset(MT7620A_RESET_FE | MT7620A_RESET_ESW);
+-}
+-
+-static void mt7620_rxcsum_config(bool enable)
+-{
+-	if (enable)
+-		fe_w32(fe_r32(MT7620A_GDMA1_FWD_CFG) | (GDMA_ICS_EN |
+-					GDMA_TCS_EN | GDMA_UCS_EN),
+-				MT7620A_GDMA1_FWD_CFG);
+-	else
+-		fe_w32(fe_r32(MT7620A_GDMA1_FWD_CFG) & ~(GDMA_ICS_EN |
+-					GDMA_TCS_EN | GDMA_UCS_EN),
+-				MT7620A_GDMA1_FWD_CFG);
+-}
+-
+-static void mt7620_txcsum_config(bool enable)
+-{
+-	if (enable)
+-		fe_w32(fe_r32(MT7620A_CDMA_CSG_CFG) | (CDMA_ICS_EN |
+-					CDMA_UCS_EN | CDMA_TCS_EN),
+-				MT7620A_CDMA_CSG_CFG);
+-	else
+-		fe_w32(fe_r32(MT7620A_CDMA_CSG_CFG) & ~(CDMA_ICS_EN |
+-					CDMA_UCS_EN | CDMA_TCS_EN),
+-				MT7620A_CDMA_CSG_CFG);
+-}
+-
+-static int mt7620_fwd_config(struct fe_priv *priv)
+-{
+-	struct net_device *dev = priv_netdev(priv);
+-
+-	fe_w32(fe_r32(MT7620A_GDMA1_FWD_CFG) & ~7, MT7620A_GDMA1_FWD_CFG);
+-
+-	mt7620_txcsum_config((dev->features & NETIF_F_IP_CSUM));
+-	mt7620_rxcsum_config((dev->features & NETIF_F_RXCSUM));
+-
+-	return 0;
+-}
+-
+-static void mt7620_tx_dma(struct fe_tx_dma *txd)
+-{
+-}
+-
+-static void mt7620_init_data(struct fe_soc_data *data,
+-			     struct net_device *netdev)
+-{
+-	struct fe_priv *priv = netdev_priv(netdev);
+-
+-	priv->flags = FE_FLAG_PADDING_64B | FE_FLAG_RX_2B_OFFSET |
+-		FE_FLAG_RX_SG_DMA | FE_FLAG_HAS_SWITCH;
+-
+-	netdev->hw_features = NETIF_F_IP_CSUM | NETIF_F_RXCSUM |
+-		NETIF_F_HW_VLAN_CTAG_TX;
+-	if (mt7620_get_eco() >= 5)
+-		netdev->hw_features |= NETIF_F_SG | NETIF_F_TSO | NETIF_F_TSO6 |
+-			NETIF_F_IPV6_CSUM;
+-}
+-
+-static struct fe_soc_data mt7620_data = {
+-	.init_data = mt7620_init_data,
+-	.reset_fe = mt7620_fe_reset,
+-	.set_mac = mt7620_set_mac,
+-	.fwd_config = mt7620_fwd_config,
+-	.tx_dma = mt7620_tx_dma,
+-	.switch_init = mtk_gsw_init,
+-	.switch_config = mt7620_gsw_config,
+-	.port_init = mt7620_port_init,
+-	.reg_table = mt7620_reg_table,
+-	.pdma_glo_cfg = FE_PDMA_SIZE_16DWORDS,
+-	.rx_int = RT5350_RX_DONE_INT,
+-	.tx_int = RT5350_TX_DONE_INT,
+-	.status_int = MT7620_FE_GDM1_AF,
+-	.checksum_bit = MT7620_L4_VALID,
+-	.has_carrier = mt7620_has_carrier,
+-	.mdio_read = mt7620_mdio_read,
+-	.mdio_write = mt7620_mdio_write,
+-	.mdio_adjust_link = mt7620_mdio_link_adjust,
+-};
+-
+-const struct of_device_id of_fe_match[] = {
+-	{ .compatible = "mediatek,mt7620-eth", .data = &mt7620_data },
+-	{},
+-};
+-
+-MODULE_DEVICE_TABLE(of, of_fe_match);
+diff --git a/drivers/net/ethernet/mtk/soc_mt7621.c b/drivers/net/ethernet/mtk/soc_mt7621.c
+deleted file mode 100644
+index 392e0ea2e588..000000000000
+--- a/drivers/net/ethernet/mtk/soc_mt7621.c
++++ /dev/null
+@@ -1,185 +0,0 @@
+-/*   This program is free software; you can redistribute it and/or modify
+- *   it under the terms of the GNU General Public License as published by
+- *   the Free Software Foundation; version 2 of the License
+- *
+- *   This program is distributed in the hope that it will be useful,
+- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+- *   GNU General Public License for more details.
+- *
+- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
+- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
+- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
+- */
+-
+-#include <linux/module.h>
+-#include <linux/platform_device.h>
+-#include <linux/if_vlan.h>
+-#include <linux/of_net.h>
+-
+-#include <asm/mach-ralink/ralink_regs.h>
+-
+-#include "mtk_eth_soc.h"
+-#include "gsw_mt7620.h"
+-#include "mt7530.h"
+-#include "mdio.h"
+-
+-#define MT7620A_CDMA_CSG_CFG	0x400
+-#define MT7621_CDMP_IG_CTRL	(MT7620A_CDMA_CSG_CFG + 0x00)
+-#define MT7621_CDMP_EG_CTRL	(MT7620A_CDMA_CSG_CFG + 0x04)
+-#define MT7621_RESET_FE		BIT(6)
+-#define MT7621_L4_VALID		BIT(24)
+-
+-#define MT7621_TX_DMA_UDF	BIT(19)
+-#define MT7621_TX_DMA_FPORT	BIT(25)
+-
+-#define CDMA_ICS_EN		BIT(2)
+-#define CDMA_UCS_EN		BIT(1)
+-#define CDMA_TCS_EN		BIT(0)
+-
+-#define GDMA_ICS_EN		BIT(22)
+-#define GDMA_TCS_EN		BIT(21)
+-#define GDMA_UCS_EN		BIT(20)
+-
+-/* frame engine counters */
+-#define MT7621_REG_MIB_OFFSET	0x2000
+-#define MT7621_PPE_AC_BCNT0	(MT7621_REG_MIB_OFFSET + 0x00)
+-#define MT7621_GDM1_TX_GBCNT	(MT7621_REG_MIB_OFFSET + 0x400)
+-#define MT7621_GDM2_TX_GBCNT	(MT7621_GDM1_TX_GBCNT + 0x40)
+-
+-#define GSW_REG_GDMA1_MAC_ADRL	0x508
+-#define GSW_REG_GDMA1_MAC_ADRH	0x50C
+-
+-#define MT7621_FE_RST_GL	(FE_FE_OFFSET + 0x04)
+-#define MT7620_FE_INT_STATUS2	(FE_FE_OFFSET + 0x08)
+-
+-/* FE_INT_STATUS reg on mt7620 define CNT_GDM1_AF at BIT(29)
+- * but after test it should be BIT(13).
+- */
+-#define MT7620_FE_GDM1_AF	BIT(13)
+-#define MT7621_FE_GDM1_AF	BIT(28)
+-#define MT7621_FE_GDM2_AF	BIT(29)
+-
+-static const u16 mt7621_reg_table[FE_REG_COUNT] = {
+-	[FE_REG_PDMA_GLO_CFG] = RT5350_PDMA_GLO_CFG,
+-	[FE_REG_PDMA_RST_CFG] = RT5350_PDMA_RST_CFG,
+-	[FE_REG_DLY_INT_CFG] = RT5350_DLY_INT_CFG,
+-	[FE_REG_TX_BASE_PTR0] = RT5350_TX_BASE_PTR0,
+-	[FE_REG_TX_MAX_CNT0] = RT5350_TX_MAX_CNT0,
+-	[FE_REG_TX_CTX_IDX0] = RT5350_TX_CTX_IDX0,
+-	[FE_REG_TX_DTX_IDX0] = RT5350_TX_DTX_IDX0,
+-	[FE_REG_RX_BASE_PTR0] = RT5350_RX_BASE_PTR0,
+-	[FE_REG_RX_MAX_CNT0] = RT5350_RX_MAX_CNT0,
+-	[FE_REG_RX_CALC_IDX0] = RT5350_RX_CALC_IDX0,
+-	[FE_REG_RX_DRX_IDX0] = RT5350_RX_DRX_IDX0,
+-	[FE_REG_FE_INT_ENABLE] = RT5350_FE_INT_ENABLE,
+-	[FE_REG_FE_INT_STATUS] = RT5350_FE_INT_STATUS,
+-	[FE_REG_FE_DMA_VID_BASE] = 0,
+-	[FE_REG_FE_COUNTER_BASE] = MT7621_GDM1_TX_GBCNT,
+-	[FE_REG_FE_RST_GL] = MT7621_FE_RST_GL,
+-	[FE_REG_FE_INT_STATUS2] = MT7620_FE_INT_STATUS2,
+-};
+-
+-static int mt7621_gsw_config(struct fe_priv *priv)
+-{
+-	if (priv->mii_bus &&  mdiobus_get_phy(priv->mii_bus, 0x1f))
+-		mt7530_probe(priv->dev, NULL, priv->mii_bus, 1);
+-
+-	return 0;
+-}
+-
+-static void mt7621_fe_reset(void)
+-{
+-	fe_reset(MT7621_RESET_FE);
+-}
+-
+-static void mt7621_rxcsum_config(bool enable)
+-{
+-	if (enable)
+-		fe_w32(fe_r32(MT7620A_GDMA1_FWD_CFG) | (GDMA_ICS_EN |
+-					GDMA_TCS_EN | GDMA_UCS_EN),
+-				MT7620A_GDMA1_FWD_CFG);
+-	else
+-		fe_w32(fe_r32(MT7620A_GDMA1_FWD_CFG) & ~(GDMA_ICS_EN |
+-					GDMA_TCS_EN | GDMA_UCS_EN),
+-				MT7620A_GDMA1_FWD_CFG);
+-}
+-
+-static void mt7621_rxvlan_config(bool enable)
+-{
+-	if (enable)
+-		fe_w32(1, MT7621_CDMP_EG_CTRL);
+-	else
+-		fe_w32(0, MT7621_CDMP_EG_CTRL);
+-}
+-
+-static int mt7621_fwd_config(struct fe_priv *priv)
+-{
+-	struct net_device *dev = priv_netdev(priv);
+-
+-	fe_w32(fe_r32(MT7620A_GDMA1_FWD_CFG) & ~0xffff,
+-	       MT7620A_GDMA1_FWD_CFG);
+-
+-	/* mt7621 doesn't have txcsum config */
+-	mt7621_rxcsum_config((dev->features & NETIF_F_RXCSUM));
+-	mt7621_rxvlan_config(priv->flags & FE_FLAG_RX_VLAN_CTAG);
+-
+-	return 0;
+-}
+-
+-static void mt7621_tx_dma(struct fe_tx_dma *txd)
+-{
+-	txd->txd4 = MT7621_TX_DMA_FPORT;
+-}
+-
+-static void mt7621_init_data(struct fe_soc_data *data,
+-			     struct net_device *netdev)
+-{
+-	struct fe_priv *priv = netdev_priv(netdev);
+-
+-	priv->flags = FE_FLAG_PADDING_64B | FE_FLAG_RX_2B_OFFSET |
+-		FE_FLAG_RX_SG_DMA | FE_FLAG_NAPI_WEIGHT |
+-		FE_FLAG_HAS_SWITCH | FE_FLAG_JUMBO_FRAME;
+-
+-	netdev->hw_features = NETIF_F_IP_CSUM | NETIF_F_RXCSUM |
+-		NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_SG | NETIF_F_TSO |
+-		NETIF_F_TSO6 | NETIF_F_IPV6_CSUM;
+-}
+-
+-static void mt7621_set_mac(struct fe_priv *priv, unsigned char *mac)
+-{
+-	unsigned long flags;
+-
+-	spin_lock_irqsave(&priv->page_lock, flags);
+-	fe_w32((mac[0] << 8) | mac[1], GSW_REG_GDMA1_MAC_ADRH);
+-	fe_w32((mac[2] << 24) | (mac[3] << 16) | (mac[4] << 8) | mac[5],
+-	       GSW_REG_GDMA1_MAC_ADRL);
+-	spin_unlock_irqrestore(&priv->page_lock, flags);
+-}
+-
+-static struct fe_soc_data mt7621_data = {
+-	.init_data = mt7621_init_data,
+-	.reset_fe = mt7621_fe_reset,
+-	.set_mac = mt7621_set_mac,
+-	.fwd_config = mt7621_fwd_config,
+-	.tx_dma = mt7621_tx_dma,
+-	.switch_init = mtk_gsw_init,
+-	.switch_config = mt7621_gsw_config,
+-	.reg_table = mt7621_reg_table,
+-	.pdma_glo_cfg = FE_PDMA_SIZE_16DWORDS,
+-	.rx_int = RT5350_RX_DONE_INT,
+-	.tx_int = RT5350_TX_DONE_INT,
+-	.status_int = (MT7621_FE_GDM1_AF | MT7621_FE_GDM2_AF),
+-	.checksum_bit = MT7621_L4_VALID,
+-	.has_carrier = mt7620_has_carrier,
+-	.mdio_read = mt7620_mdio_read,
+-	.mdio_write = mt7620_mdio_write,
+-	.mdio_adjust_link = mt7620_mdio_link_adjust,
+-};
+-
+-const struct of_device_id of_fe_match[] = {
+-	{ .compatible = "mediatek,mt7621-eth", .data = &mt7621_data },
+-	{},
+-};
+-
+-MODULE_DEVICE_TABLE(of, of_fe_match);
+diff --git a/drivers/net/ethernet/mtk/soc_rt2880.c b/drivers/net/ethernet/mtk/soc_rt2880.c
+deleted file mode 100644
+index 6c89c997d925..000000000000
+--- a/drivers/net/ethernet/mtk/soc_rt2880.c
++++ /dev/null
+@@ -1,76 +0,0 @@
+-/*   This program is free software; you can redistribute it and/or modify
+- *   it under the terms of the GNU General Public License as published by
+- *   the Free Software Foundation; version 2 of the License
+- *
+- *   This program is distributed in the hope that it will be useful,
+- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+- *   GNU General Public License for more details.
+- *
+- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
+- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
+- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
+- */
+-
+-#include <linux/module.h>
+-
+-#include <asm/mach-ralink/ralink_regs.h>
+-
+-#include "mtk_eth_soc.h"
+-#include "mdio_rt2880.h"
+-
+-#define RT2880_RESET_FE			BIT(18)
+-
+-static void rt2880_init_data(struct fe_soc_data *data,
+-			     struct net_device *netdev)
+-{
+-	struct fe_priv *priv = netdev_priv(netdev);
+-
+-	priv->flags = FE_FLAG_PADDING_64B | FE_FLAG_PADDING_BUG |
+-		FE_FLAG_JUMBO_FRAME | FE_FLAG_CALIBRATE_CLK;
+-	netdev->hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_TX;
+-	/* this should work according to the datasheet but actually does not*/
+-	/* netdev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_RXCSUM; */
+-}
+-
+-void rt2880_fe_reset(void)
+-{
+-	fe_reset(RT2880_RESET_FE);
+-}
+-
+-static int rt2880_fwd_config(struct fe_priv *priv)
+-{
+-	int ret;
+-
+-	ret = fe_set_clock_cycle(priv);
+-	if (ret)
+-		return ret;
+-
+-	fe_fwd_config(priv);
+-	fe_w32(FE_PSE_FQFC_CFG_INIT, FE_PSE_FQ_CFG);
+-	fe_csum_config(priv);
+-
+-	return ret;
+-}
+-
+-struct fe_soc_data rt2880_data = {
+-	.init_data = rt2880_init_data,
+-	.reset_fe = rt2880_fe_reset,
+-	.fwd_config = rt2880_fwd_config,
+-	.pdma_glo_cfg = FE_PDMA_SIZE_8DWORDS,
+-	.checksum_bit = RX_DMA_L4VALID,
+-	.rx_int = FE_RX_DONE_INT,
+-	.tx_int = FE_TX_DONE_INT,
+-	.status_int = FE_CNT_GDM_AF,
+-	.mdio_read = rt2880_mdio_read,
+-	.mdio_write = rt2880_mdio_write,
+-	.mdio_adjust_link = rt2880_mdio_link_adjust,
+-	.port_init = rt2880_port_init,
+-};
+-
+-const struct of_device_id of_fe_match[] = {
+-	{ .compatible = "ralink,rt2880-eth", .data = &rt2880_data },
+-	{},
+-};
+-
+-MODULE_DEVICE_TABLE(of, of_fe_match);
+diff --git a/drivers/net/ethernet/mtk/soc_rt3050.c b/drivers/net/ethernet/mtk/soc_rt3050.c
+deleted file mode 100644
+index 914b81410e5c..000000000000
+--- a/drivers/net/ethernet/mtk/soc_rt3050.c
++++ /dev/null
+@@ -1,158 +0,0 @@
+-/*   This program is free software; you can redistribute it and/or modify
+- *   it under the terms of the GNU General Public License as published by
+- *   the Free Software Foundation; version 2 of the License
+- *
+- *   This program is distributed in the hope that it will be useful,
+- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+- *   GNU General Public License for more details.
+- *
+- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
+- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
+- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
+- */
+-
+-#include <linux/module.h>
+-
+-#include <asm/mach-ralink/ralink_regs.h>
+-
+-#include "mtk_eth_soc.h"
+-#include "mdio_rt2880.h"
+-
+-#define RT305X_RESET_FE         BIT(21)
+-#define RT305X_RESET_ESW        BIT(23)
+-
+-static const u16 rt5350_reg_table[FE_REG_COUNT] = {
+-	[FE_REG_PDMA_GLO_CFG] = RT5350_PDMA_GLO_CFG,
+-	[FE_REG_PDMA_RST_CFG] = RT5350_PDMA_RST_CFG,
+-	[FE_REG_DLY_INT_CFG] = RT5350_DLY_INT_CFG,
+-	[FE_REG_TX_BASE_PTR0] = RT5350_TX_BASE_PTR0,
+-	[FE_REG_TX_MAX_CNT0] = RT5350_TX_MAX_CNT0,
+-	[FE_REG_TX_CTX_IDX0] = RT5350_TX_CTX_IDX0,
+-	[FE_REG_TX_DTX_IDX0] = RT5350_TX_DTX_IDX0,
+-	[FE_REG_RX_BASE_PTR0] = RT5350_RX_BASE_PTR0,
+-	[FE_REG_RX_MAX_CNT0] = RT5350_RX_MAX_CNT0,
+-	[FE_REG_RX_CALC_IDX0] = RT5350_RX_CALC_IDX0,
+-	[FE_REG_RX_DRX_IDX0] = RT5350_RX_DRX_IDX0,
+-	[FE_REG_FE_INT_ENABLE] = RT5350_FE_INT_ENABLE,
+-	[FE_REG_FE_INT_STATUS] = RT5350_FE_INT_STATUS,
+-	[FE_REG_FE_RST_GL] = 0,
+-	[FE_REG_FE_DMA_VID_BASE] = 0,
+-};
+-
+-static void rt305x_init_data(struct fe_soc_data *data,
+-			     struct net_device *netdev)
+-{
+-	struct fe_priv *priv = netdev_priv(netdev);
+-
+-	priv->flags = FE_FLAG_PADDING_64B | FE_FLAG_PADDING_BUG |
+-		FE_FLAG_CALIBRATE_CLK | FE_FLAG_HAS_SWITCH;
+-	netdev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM |
+-		NETIF_F_RXCSUM | NETIF_F_HW_VLAN_CTAG_TX;
+-}
+-
+-static int rt3050_fwd_config(struct fe_priv *priv)
+-{
+-	int ret;
+-
+-	if (ralink_soc != RT305X_SOC_RT3052) {
+-		ret = fe_set_clock_cycle(priv);
+-		if (ret)
+-			return ret;
+-	}
+-
+-	fe_fwd_config(priv);
+-	if (ralink_soc != RT305X_SOC_RT3352)
+-		fe_w32(FE_PSE_FQFC_CFG_INIT, FE_PSE_FQ_CFG);
+-	fe_csum_config(priv);
+-
+-	return 0;
+-}
+-
+-static void rt305x_fe_reset(void)
+-{
+-	fe_reset(RT305X_RESET_FE);
+-}
+-
+-static void rt5350_init_data(struct fe_soc_data *data,
+-			     struct net_device *netdev)
+-{
+-	struct fe_priv *priv = netdev_priv(netdev);
+-
+-	priv->flags = FE_FLAG_HAS_SWITCH;
+-	netdev->hw_features = NETIF_F_SG | NETIF_F_RXCSUM;
+-}
+-
+-static void rt5350_set_mac(struct fe_priv *priv, unsigned char *mac)
+-{
+-	unsigned long flags;
+-
+-	spin_lock_irqsave(&priv->page_lock, flags);
+-	fe_w32((mac[0] << 8) | mac[1], RT5350_SDM_MAC_ADRH);
+-	fe_w32((mac[2] << 24) | (mac[3] << 16) | (mac[4] << 8) | mac[5],
+-	       RT5350_SDM_MAC_ADRL);
+-	spin_unlock_irqrestore(&priv->page_lock, flags);
+-}
+-
+-static void rt5350_rxcsum_config(bool enable)
+-{
+-	if (enable)
+-		fe_w32(fe_r32(RT5350_SDM_CFG) | (RT5350_SDM_ICS_EN |
+-				RT5350_SDM_TCS_EN | RT5350_SDM_UCS_EN),
+-				RT5350_SDM_CFG);
+-	else
+-		fe_w32(fe_r32(RT5350_SDM_CFG) & ~(RT5350_SDM_ICS_EN |
+-				RT5350_SDM_TCS_EN | RT5350_SDM_UCS_EN),
+-				RT5350_SDM_CFG);
+-}
+-
+-static int rt5350_fwd_config(struct fe_priv *priv)
+-{
+-	struct net_device *dev = priv_netdev(priv);
+-
+-	rt5350_rxcsum_config((dev->features & NETIF_F_RXCSUM));
+-
+-	return 0;
+-}
+-
+-static void rt5350_tx_dma(struct fe_tx_dma *txd)
+-{
+-	txd->txd4 = 0;
+-}
+-
+-static void rt5350_fe_reset(void)
+-{
+-	fe_reset(RT305X_RESET_FE | RT305X_RESET_ESW);
+-}
+-
+-static struct fe_soc_data rt3050_data = {
+-	.init_data = rt305x_init_data,
+-	.reset_fe = rt305x_fe_reset,
+-	.fwd_config = rt3050_fwd_config,
+-	.pdma_glo_cfg = FE_PDMA_SIZE_8DWORDS,
+-	.checksum_bit = RX_DMA_L4VALID,
+-	.rx_int = FE_RX_DONE_INT,
+-	.tx_int = FE_TX_DONE_INT,
+-	.status_int = FE_CNT_GDM_AF,
+-};
+-
+-static struct fe_soc_data rt5350_data = {
+-	.init_data = rt5350_init_data,
+-	.reg_table = rt5350_reg_table,
+-	.reset_fe = rt5350_fe_reset,
+-	.set_mac = rt5350_set_mac,
+-	.fwd_config = rt5350_fwd_config,
+-	.tx_dma = rt5350_tx_dma,
+-	.pdma_glo_cfg = FE_PDMA_SIZE_8DWORDS,
+-	.checksum_bit = RX_DMA_L4VALID,
+-	.rx_int = RT5350_RX_DONE_INT,
+-	.tx_int = RT5350_TX_DONE_INT,
+-};
+-
+-const struct of_device_id of_fe_match[] = {
+-	{ .compatible = "ralink,rt3050-eth", .data = &rt3050_data },
+-	{ .compatible = "ralink,rt5350-eth", .data = &rt5350_data },
+-	{},
+-};
+-
+-MODULE_DEVICE_TABLE(of, of_fe_match);
+diff --git a/drivers/net/ethernet/mtk/soc_rt3883.c b/drivers/net/ethernet/mtk/soc_rt3883.c
+deleted file mode 100644
+index 4935b7fbd43e..000000000000
+--- a/drivers/net/ethernet/mtk/soc_rt3883.c
++++ /dev/null
+@@ -1,75 +0,0 @@
+-/*   This program is free software; you can redistribute it and/or modify
+- *   it under the terms of the GNU General Public License as published by
+- *   the Free Software Foundation; version 2 of the License
+- *
+- *   This program is distributed in the hope that it will be useful,
+- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+- *   GNU General Public License for more details.
+- *
+- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
+- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
+- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
+- */
+-
+-#include <linux/module.h>
+-
+-#include <asm/mach-ralink/ralink_regs.h>
+-
+-#include "mtk_eth_soc.h"
+-#include "mdio_rt2880.h"
+-
+-#define RT3883_RSTCTRL_FE		BIT(21)
+-
+-static void rt3883_fe_reset(void)
+-{
+-	fe_reset(RT3883_RSTCTRL_FE);
+-}
+-
+-static int rt3883_fwd_config(struct fe_priv *priv)
+-{
+-	int ret;
+-
+-	ret = fe_set_clock_cycle(priv);
+-	if (ret)
+-		return ret;
+-
+-	fe_fwd_config(priv);
+-	fe_w32(FE_PSE_FQFC_CFG_256Q, FE_PSE_FQ_CFG);
+-	fe_csum_config(priv);
+-
+-	return ret;
+-}
+-
+-static void rt3883_init_data(struct fe_soc_data *data,
+-			     struct net_device *netdev)
+-{
+-	struct fe_priv *priv = netdev_priv(netdev);
+-
+-	priv->flags = FE_FLAG_PADDING_64B | FE_FLAG_PADDING_BUG |
+-		FE_FLAG_JUMBO_FRAME | FE_FLAG_CALIBRATE_CLK;
+-	netdev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM |
+-		NETIF_F_RXCSUM | NETIF_F_HW_VLAN_CTAG_TX;
+-}
+-
+-static struct fe_soc_data rt3883_data = {
+-	.init_data = rt3883_init_data,
+-	.reset_fe = rt3883_fe_reset,
+-	.fwd_config = rt3883_fwd_config,
+-	.pdma_glo_cfg = FE_PDMA_SIZE_8DWORDS,
+-	.rx_int = FE_RX_DONE_INT,
+-	.tx_int = FE_TX_DONE_INT,
+-	.status_int = FE_CNT_GDM_AF,
+-	.checksum_bit = RX_DMA_L4VALID,
+-	.mdio_read = rt2880_mdio_read,
+-	.mdio_write = rt2880_mdio_write,
+-	.mdio_adjust_link = rt2880_mdio_link_adjust,
+-	.port_init = rt2880_port_init,
+-};
+-
+-const struct of_device_id of_fe_match[] = {
+-	{ .compatible = "ralink,rt3883-eth", .data = &rt3883_data },
+-	{},
+-};
+-
+-MODULE_DEVICE_TABLE(of, of_fe_match);
+diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
+index 0bcf7099f1c2..fd8fec6d0249 100644
+--- a/drivers/net/phy/phy.c
++++ b/drivers/net/phy/phy.c
+@@ -980,10 +980,7 @@ void phy_state_machine(struct work_struct *work)
+ 		/* If the link is down, give up on negotiation for now */
+ 		if (!phydev->link) {
+ 			phydev->state = PHY_NOLINK;
+-			if (!phydev->no_auto_carrier_off)
+-				phy_link_down(phydev, true);
+-			else
+-				phy_link_down(phydev, false);
++			phy_link_down(phydev, true);
+ 			break;
+ 		}
+ 
+@@ -1070,10 +1067,7 @@ void phy_state_machine(struct work_struct *work)
+ 			phy_link_up(phydev);
+ 		} else {
+ 			phydev->state = PHY_NOLINK;
+-			if (!phydev->no_auto_carrier_off)
+-				phy_link_down(phydev, true);
+-			else
+-				phy_link_down(phydev, false);
++			phy_link_down(phydev, true);
+ 		}
+ 
+ 		if (phy_interrupt_is_valid(phydev))
+@@ -1083,10 +1077,7 @@ void phy_state_machine(struct work_struct *work)
+ 	case PHY_HALTED:
+ 		if (phydev->link) {
+ 			phydev->link = 0;
+-			if (!phydev->no_auto_carrier_off)
+-				phy_link_down(phydev, true);
+-			else
+-				phy_link_down(phydev, false);
++			phy_link_down(phydev, true);
+ 			do_suspend = true;
+ 		}
+ 		break;
+diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c
+index 5e55c22840f2..86e58398e58d 100644
+--- a/drivers/net/phy/phy_device.c
++++ b/drivers/net/phy/phy_device.c
+@@ -1929,7 +1929,7 @@ static struct phy_driver genphy_driver = {
+ 	.config_init	= genphy_config_init,
+ 	.features	= PHY_GBIT_FEATURES | SUPPORTED_MII |
+ 			  SUPPORTED_AUI | SUPPORTED_FIBRE |
+-			  SUPPORTED_BNC,
++			  SUPPORTED_BNC | SUPPORTED_Pause | SUPPORTED_Asym_Pause,
+ 	.config_aneg	= genphy_config_aneg,
+ 	.aneg_done	= genphy_aneg_done,
+ 	.read_status	= genphy_read_status,
+-- 
+2.17.1
+
unchanged:
--- /dev/null
+++ b/target/linux/ramips/patches-4.14/2001-Adding-MT7621-basic-syscon-clock.patch
@@ -0,0 +1,813 @@
+From 80ddc3b0b63accc2b23fdcce695a23f3f6bb4af1 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Ren=C3=A9=20van=20Dorst?= <opensource@vdorst.com>
+Date: Thu, 19 Jul 2018 15:57:42 +0200
+Subject: [PATCH 2001/2002] Adding MT7621 basic syscon clock.
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: René van Dorst <opensource@vdorst.com>
+---
+ arch/mips/ralink/Kconfig               |   2 +
+ drivers/clk/mediatek/Kconfig           |  16 +
+ drivers/clk/mediatek/clk-mt7621-eth.c  | 108 +++++
+ drivers/clk/mediatek/clk-mt7621.c      | 589 +++++++++++++++++++++++++
+ include/dt-bindings/clock/mt7621-clk.h |  37 ++
+ 5 files changed, 752 insertions(+)
+ create mode 100644 drivers/clk/mediatek/clk-mt7621-eth.c
+ create mode 100644 drivers/clk/mediatek/clk-mt7621.c
+ create mode 100644 include/dt-bindings/clock/mt7621-clk.h
+
+diff --git a/arch/mips/ralink/Kconfig b/arch/mips/ralink/Kconfig
+index e8c699d24e28..1addc7466982 100644
+--- a/arch/mips/ralink/Kconfig
++++ b/arch/mips/ralink/Kconfig
+@@ -59,6 +59,8 @@ choice
+ 		select HW_HAS_PCI
+ 		select WEAK_REORDERING_BEYOND_LLSC
+ 		select GENERIC_CLOCKEVENTS_BROADCAST
++		select CLK_MT762
++		select CLK_MT762_ETHSYS
+ endchoice
+ 
+ choice
+diff --git a/drivers/clk/mediatek/Kconfig b/drivers/clk/mediatek/Kconfig
+index 1f9ea0f21df1..77aae573bfe4 100644
+--- a/drivers/clk/mediatek/Kconfig
++++ b/drivers/clk/mediatek/Kconfig
+@@ -181,4 +181,20 @@ config COMMON_CLK_MT8173
+ 	default ARCH_MEDIATEK
+ 	---help---
+ 	  This driver supports MediaTek MT8173 clocks.
++
++config COMMON_CLK_MT7621
++	bool "Clock driver for Mediatek MT7621"
++	depends on SOC_MT7621 || COMPILE_TEST
++	select COMMON_CLK_MEDIATEK
++	default SOC_MT7621
++	---help---
++	  This driver supports Mediatek MT7621 basic clocks.
++
++config COMMON_CLK_MT7621_ETHSYS
++	bool "Clock driver for Mediatek MT7621 ethsys"
++	depends on COMMON_CLK_MT7621
++	depends on MFD_SYSCON
++	---help---
++	  This driver supports Mediatek MT7621 ethsys clocks.
++
+ endmenu
+diff --git a/drivers/clk/mediatek/clk-mt7621-eth.c b/drivers/clk/mediatek/clk-mt7621-eth.c
+new file mode 100644
+index 000000000000..678d33900a0e
+--- /dev/null
++++ b/drivers/clk/mediatek/clk-mt7621-eth.c
+@@ -0,0 +1,108 @@
++/*
++ * Copyright (c) 2017 MediaTek Inc.
++ * Author: Chen Zhong <chen.zhong@mediatek.com>
++ *	   Sean Wang <sean.wang@mediatek.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#include <linux/clk-provider.h>
++#include <linux/of.h>
++#include <linux/of_address.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++
++#include "clk-mtk.h"
++#include "clk-gate.h"
++
++#include <dt-bindings/clock/mt7621-clk.h>
++
++#define GATE_ETH(_id, _name, _parent, _shift) {	\
++		.id = _id,				\
++		.name = _name,				\
++		.parent_name = _parent,			\
++		.regs = &eth_cg_regs,			\
++		.shift = _shift,			\
++		.ops = &mtk_clk_gate_ops_no_setclr_inv,	\
++	}
++
++static const struct mtk_gate_regs eth_cg_regs = {
++	.set_ofs = 0x30,
++	.clr_ofs = 0x30,
++	.sta_ofs = 0x30,
++};
++
++static const struct mtk_gate eth_clks[] = {
++	GATE_ETH(CLK_ETHSYS_HSDMA, "eth_hsdma_en", "clkxtal", 5),
++	GATE_ETH(CLK_ETHSYS_ESW, "eth_esw_en", "clkxtal", 6),
++	GATE_ETH(CLK_ETHSYS_GDMA, "eth_gdma_en", "clkxtal", 14),
++	GATE_ETH(CLK_ETHSYS_I2C, "eth_i2c_en", "clkxtal", 16),
++	GATE_ETH(CLK_ETHSYS_ETH, "eth_eth_en", "clkxtal", 23),
++	GATE_ETH(CLK_ETHSYS_CRYPTO, "eth_crypto_en", "clkxtal", 29),
++};
++
++static int clk_mt7621_ethsys_init(struct platform_device *pdev)
++{
++	struct clk_onecell_data *clk_data;
++	struct device_node *node = pdev->dev.of_node;
++	int r;
++
++	clk_data = mtk_alloc_clk_data(CLK_ETHSYS_NR);
++
++	mtk_clk_register_gates(node, eth_clks, ARRAY_SIZE(eth_clks),
++			       clk_data);
++
++	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
++	if (r)
++		dev_err(&pdev->dev,
++			"could not register clock provider: %s: %d\n",
++			pdev->name, r);
++
++	mtk_register_reset_controller(node, 1, 0x34);
++
++	return r;
++}
++
++static const struct of_device_id of_match_clk_mt7621_eth[] = {
++	{
++		.compatible = "mediatek,mt7621-ethsys",
++		.data = clk_mt7621_ethsys_init,
++	}, {
++		/* sentinel */
++	}
++};
++
++static int clk_mt7621_eth_probe(struct platform_device *pdev)
++{
++	int (*clk_init)(struct platform_device *);
++	int r;
++
++	clk_init = of_device_get_match_data(&pdev->dev);
++	if (!clk_init)
++		return -EINVAL;
++
++	r = clk_init(pdev);
++	if (r)
++		dev_err(&pdev->dev,
++			"could not register clock provider: %s: %d\n",
++			pdev->name, r);
++
++	return r;
++}
++
++static struct platform_driver clk_mt7621_eth_drv = {
++	.probe = clk_mt7621_eth_probe,
++	.driver = {
++		.name = "clk-mt7621-eth",
++		.of_match_table = of_match_clk_mt7621_eth,
++	},
++};
++
++builtin_platform_driver(clk_mt7621_eth_drv);
+diff --git a/drivers/clk/mediatek/clk-mt7621.c b/drivers/clk/mediatek/clk-mt7621.c
+new file mode 100644
+index 000000000000..0786ada35ede
+--- /dev/null
++++ b/drivers/clk/mediatek/clk-mt7621.c
+@@ -0,0 +1,589 @@
++/*
++ * Copyright (c) 2017 MediaTek Inc.
++ * Author: Chen Zhong <chen.zhong@mediatek.com>
++ *	   Sean Wang <sean.wang@mediatek.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#include <linux/clk-provider.h>
++#include <linux/of.h>
++#include <linux/of_address.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++
++#include "clk-mtk.h"
++#include "clk-gate.h"
++#include "clk-cpumux.h"
++
++#include <dt-bindings/clock/mt7621-clk.h>
++#include <linux/clk.h> /* for consumer */
++
++#define MT7621_PLL_FMAX		(2500UL * MHZ)
++#define CON0_MT7621_RST_BAR	BIT(27)
++
++#define PLL_xtal(_id, _name, _reg, _pwr_reg, _en_mask, _flags, _pcwbits,\
++			_pd_reg, _pd_shift, _tuner_reg, _pcw_reg,	\
++			_pcw_shift, _div_table, _parent_name) {		\
++		.id = _id,						\
++		.name = _name,						\
++		.reg = _reg,						\
++		.pwr_reg = _pwr_reg,					\
++		.en_mask = _en_mask,					\
++		.flags = _flags,					\
++		.rst_bar_mask = CON0_MT7621_RST_BAR,			\
++		.fmax = MT7621_PLL_FMAX,				\
++		.pcwbits = _pcwbits,					\
++		.pd_reg = _pd_reg,					\
++		.pd_shift = _pd_shift,					\
++		.tuner_reg = _tuner_reg,				\
++		.pcw_reg = _pcw_reg,					\
++		.pcw_shift = _pcw_shift,				\
++		.div_table = _div_table,				\
++		.parent_name = _parent_name,				\
++	}
++
++#define PLL(_id, _name, _reg, _pwr_reg, _en_mask, _flags, _pcwbits,	\
++			_pd_reg, _pd_shift, _tuner_reg, _pcw_reg,	\
++			_pcw_shift)					\
++	PLL_xtal(_id, _name, _reg, _pwr_reg, _en_mask, _flags, _pcwbits,\
++		 _pd_reg, _pd_shift, _tuner_reg, _pcw_reg, _pcw_shift,  \
++		 NULL, "clkxtal")
++
++#define GATE_APMIXED(_id, _name, _parent, _shift) {			\
++		.id = _id,						\
++		.name = _name,						\
++		.parent_name = _parent,					\
++		.regs = &apmixed_cg_regs,				\
++		.shift = _shift,					\
++		.ops = &mtk_clk_gate_ops_no_setclr_inv,			\
++	}
++
++#define GATE_INFRA(_id, _name, _parent, _shift) {			\
++		.id = _id,						\
++		.name = _name,						\
++		.parent_name = _parent,					\
++		.regs = &infra_cg_regs,					\
++		.shift = _shift,					\
++		.ops = &mtk_clk_gate_ops_setclr,			\
++	}
++
++#define GATE_TOP0(_id, _name, _parent, _shift) {			\
++		.id = _id,						\
++		.name = _name,						\
++		.parent_name = _parent,					\
++		.regs = &top0_cg_regs,					\
++		.shift = _shift,					\
++		.ops = &mtk_clk_gate_ops_no_setclr,			\
++	}
++
++#define GATE_TOP1(_id, _name, _parent, _shift) {			\
++		.id = _id,						\
++		.name = _name,						\
++		.parent_name = _parent,					\
++		.regs = &top1_cg_regs,					\
++		.shift = _shift,					\
++		.ops = &mtk_clk_gate_ops_no_setclr,			\
++	}
++
++#define GATE_PERI0(_id, _name, _parent, _shift) {			\
++		.id = _id,						\
++		.name = _name,						\
++		.parent_name = _parent,					\
++		.regs = &peri0_cg_regs,					\
++		.shift = _shift,					\
++		.ops = &mtk_clk_gate_ops_setclr,			\
++	}
++
++#define GATE_PERI1(_id, _name, _parent, _shift) {			\
++		.id = _id,						\
++		.name = _name,						\
++		.parent_name = _parent,					\
++		.regs = &peri1_cg_regs,					\
++		.shift = _shift,					\
++		.ops = &mtk_clk_gate_ops_setclr,			\
++	}
++
++static DEFINE_SPINLOCK(mt7621_clk_lock);
++
++static const char * const infra_mux1_parents[] = {
++	"clkxtal",
++	"armpll",
++	"main_core_en",
++	"armpll"
++};
++
++static const char * const axi_parents[] = {
++	"clkxtal",
++	"syspll1_d2",
++	"syspll_d5",
++	"syspll1_d4",
++	"univpll_d5",
++	"univpll2_d2",
++	"univpll_d7"
++};
++
++static const char * const mem_parents[] = {
++	"clkxtal",
++	"dmpll_ck"
++};
++
++static const char * const ddrphycfg_parents[] = {
++	"clkxtal",
++	"syspll1_d8"
++};
++
++static const char * const eth_parents[] = {
++	"clkxtal",
++	"ddrpll",
++	"apll"
++};
++
++static const char * const pwm_parents[] = {
++	"clkxtal",
++	"univpll2_d4"
++};
++
++static const char * const f10m_ref_parents[] = {
++	"clkxtal",
++	"syspll4_d16"
++};
++
++static const char * const nfi_infra_parents[] = {
++	"clkxtal",
++	"clkxtal",
++	"clkxtal",
++	"clkxtal",
++	"clkxtal",
++	"clkxtal",
++	"clkxtal",
++	"clkxtal",
++	"univpll2_d8",
++	"syspll1_d8",
++	"univpll1_d8",
++	"syspll4_d2",
++	"univpll2_d4",
++	"univpll3_d2",
++	"syspll1_d4"
++};
++
++static const char * const flash_parents[] = {
++	"clkxtal",
++	"univpll_d80_d4",
++	"syspll2_d8",
++	"syspll3_d4",
++	"univpll3_d4",
++	"univpll1_d8",
++	"syspll2_d4",
++	"univpll2_d4"
++};
++
++static const char * const uart_parents[] = {
++	"clkxtal",
++	"univpll2_d8"
++};
++
++static const char * const spi0_parents[] = {
++	"clkxtal",
++	"syspll3_d2",
++	"clkxtal",
++	"syspll2_d4",
++	"syspll4_d2",
++	"univpll2_d4",
++	"univpll1_d8",
++	"clkxtal"
++};
++
++static const char * const spi1_parents[] = {
++	"clkxtal",
++	"syspll3_d2",
++	"clkxtal",
++	"syspll4_d4",
++	"syspll4_d2",
++	"univpll2_d4",
++	"univpll1_d8",
++	"clkxtal"
++};
++
++static const char * const msdc30_0_parents[] = {
++	"clkxtal",
++	"univpll2_d16",
++	"univ48m"
++};
++
++static const char * const a1sys_hp_parents[] = {
++	"clkxtal",
++	"aud1pll_ck",
++	"aud2pll_ck",
++	"clkxtal"
++};
++
++static const char * const intdir_parents[] = {
++	"clkxtal",
++	"syspll_d2",
++	"univpll_d2",
++	"sgmiipll_ck"
++};
++
++static const char * const aud_intbus_parents[] = {
++	"clkxtal",
++	"syspll1_d4",
++	"syspll4_d2",
++	"syspll3_d2"
++};
++
++static const char * const pmicspi_parents[] = {
++	"clkxtal",
++	"clk_null",
++	"clk_null",
++	"clk_null",
++	"clk_null",
++	"univpll2_d16"
++};
++
++static const char * const atb_parents[] = {
++	"clkxtal",
++	"syspll1_d2",
++	"syspll_d5"
++};
++
++static const char * const audio_parents[] = {
++	"clkxtal",
++	"syspll3_d4",
++	"syspll4_d4",
++	"univpll1_d16"
++};
++
++static const char * const usb20_parents[] = {
++	"clkxtal",
++	"univpll3_d4",
++	"syspll1_d8",
++	"clkxtal"
++};
++
++static const char * const aud1_parents[] = {
++	"clkxtal",
++	"aud1pll_ck"
++};
++
++static const char * const aud2_parents[] = {
++	"clkxtal",
++	"aud2pll_ck"
++};
++
++static const char * const asm_l_parents[] = {
++	"clkxtal",
++	"syspll_d5",
++	"univpll2_d2",
++	"univpll2_d4"
++};
++
++static const char * const apll1_ck_parents[] = {
++	"aud1_sel",
++	"aud2_sel"
++};
++
++static const char * const peribus_ck_parents[] = {
++	"syspll1_d8",
++	"syspll1_d4"
++};
++
++static const struct mtk_gate_regs apmixed_cg_regs = {
++	.set_ofs = 0x8,
++	.clr_ofs = 0x8,
++	.sta_ofs = 0x8,
++};
++
++static const struct mtk_gate_regs infra_cg_regs = {
++	.set_ofs = 0x40,
++	.clr_ofs = 0x44,
++	.sta_ofs = 0x48,
++};
++
++static const struct mtk_gate_regs top0_cg_regs = {
++	.set_ofs = 0x120,
++	.clr_ofs = 0x120,
++	.sta_ofs = 0x120,
++};
++
++static const struct mtk_gate_regs top1_cg_regs = {
++	.set_ofs = 0x128,
++	.clr_ofs = 0x128,
++	.sta_ofs = 0x128,
++};
++
++static const struct mtk_gate_regs peri0_cg_regs = {
++	.set_ofs = 0x8,
++	.clr_ofs = 0x10,
++	.sta_ofs = 0x18,
++};
++
++static const struct mtk_gate_regs peri1_cg_regs = {
++	.set_ofs = 0xC,
++	.clr_ofs = 0x14,
++	.sta_ofs = 0x1C,
++};
++
++static const struct mtk_pll_data plls[] = {
++	PLL(CLK_APMIXED_ARMPLL, "armpll", 0x0200, 0x020C, 0x00000001,
++	    PLL_AO, 21, 0x0204, 24, 0, 0x0204, 0),
++	PLL(CLK_APMIXED_MAINPLL, "mainpll", 0x0210, 0x021C, 0x00000001,
++	    HAVE_RST_BAR, 21, 0x0214, 24, 0, 0x0214, 0),
++	PLL(CLK_APMIXED_UNIV2PLL, "univ2pll", 0x0220, 0x022C, 0x00000001,
++	    HAVE_RST_BAR, 7, 0x0224, 24, 0, 0x0224, 14),
++	PLL(CLK_APMIXED_ETH1PLL, "eth1pll", 0x0300, 0x0310, 0x00000001,
++	    0, 21, 0x0300, 1, 0, 0x0304, 0),
++	PLL(CLK_APMIXED_ETH2PLL, "eth2pll", 0x0314, 0x0320, 0x00000001,
++	    0, 21, 0x0314, 1, 0, 0x0318, 0),
++	PLL(CLK_APMIXED_AUD1PLL, "aud1pll", 0x0324, 0x0330, 0x00000001,
++	    0, 31, 0x0324, 1, 0, 0x0328, 0),
++	PLL(CLK_APMIXED_AUD2PLL, "aud2pll", 0x0334, 0x0340, 0x00000001,
++	    0, 31, 0x0334, 1, 0, 0x0338, 0),
++	PLL(CLK_APMIXED_TRGPLL, "trgpll", 0x0344, 0x0354, 0x00000001,
++	    0, 21, 0x0344, 1, 0, 0x0348, 0),
++	PLL(CLK_APMIXED_SGMIPLL, "sgmipll", 0x0358, 0x0368, 0x00000001,
++	    0, 21, 0x0358, 1, 0, 0x035C, 0),
++};
++
++static const struct mtk_gate apmixed_clks[] = {
++	GATE_APMIXED(CLK_APMIXED_MAIN_CORE_EN, "main_core_en", "mainpll", 5),
++};
++
++static const struct mtk_gate infra_clks[] = {
++	GATE_INFRA(CLK_INFRA_DBGCLK_PD, "infra_dbgclk_pd", "axi_sel", 0),
++	GATE_INFRA(CLK_INFRA_TRNG, "trng_ck", "axi_sel", 2),
++	GATE_INFRA(CLK_INFRA_AUDIO_PD, "infra_audio_pd", "aud_intbus_sel", 5),
++	GATE_INFRA(CLK_INFRA_IRRX_PD, "infra_irrx_pd", "irrx_sel", 16),
++	GATE_INFRA(CLK_INFRA_APXGPT_PD, "infra_apxgpt_pd", "f10m_ref_sel", 18),
++	GATE_INFRA(CLK_INFRA_PMIC_PD, "infra_pmic_pd", "pmicspi_sel", 22),
++};
++
++static const struct mtk_fixed_clk top_fixed_clks[] = {
++	FIXED_CLK(CLK_TOP_TO_U2_PHY, "to_u2_phy", "clkxtal",
++		  31250000),
++};
++
++static const struct mtk_fixed_factor top_divs[] = {
++	FACTOR(CLK_TOP_TO_USB3_SYS, "to_usb3_sys", "eth1pll", 1, 4),
++	FACTOR(CLK_TOP_P1_1MHZ, "p1_1mhz", "eth1pll", 1, 500),
++	FACTOR(CLK_TOP_4MHZ, "free_run_4mhz", "eth1pll", 1, 125),
++	FACTOR(CLK_TOP_P0_1MHZ, "p0_1mhz", "eth1pll", 1, 500),
++	FACTOR(CLK_TOP_TXCLK_SRC_PRE, "txclk_src_pre", "sgmiipll_d2", 1, 1),
++	FACTOR(CLK_TOP_RTC, "rtc", "clkxtal", 1, 1024),
++	FACTOR(CLK_TOP_MEMPLL, "mempll", "clkxtal", 32, 1),
++	FACTOR(CLK_TOP_DMPLL, "dmpll_ck", "mempll", 1, 1),
++	FACTOR(CLK_TOP_SYSPLL_D2, "syspll_d2", "mainpll", 1, 2),
++	FACTOR(CLK_TOP_SYSPLL1_D2, "syspll1_d2", "mainpll", 1, 4),
++	FACTOR(CLK_TOP_SYSPLL1_D4, "syspll1_d4", "mainpll", 1, 8),
++	FACTOR(CLK_TOP_SYSPLL1_D8, "syspll1_d8", "mainpll", 1, 16),
++	FACTOR(CLK_TOP_SYSPLL2_D4, "syspll2_d4", "mainpll", 1, 12),
++	FACTOR(CLK_TOP_SYSPLL2_D8, "syspll2_d8", "mainpll", 1, 24),
++	FACTOR(CLK_TOP_SYSPLL_D5, "syspll_d5", "mainpll", 1, 5),
++	FACTOR(CLK_TOP_SYSPLL3_D2, "syspll3_d2", "mainpll", 1, 10),
++	FACTOR(CLK_TOP_SYSPLL3_D4, "syspll3_d4", "mainpll", 1, 20),
++	FACTOR(CLK_TOP_SYSPLL4_D2, "syspll4_d2", "mainpll", 1, 14),
++	FACTOR(CLK_TOP_SYSPLL4_D4, "syspll4_d4", "mainpll", 1, 28),
++	FACTOR(CLK_TOP_SYSPLL4_D16, "syspll4_d16", "mainpll", 1, 112),
++	FACTOR(CLK_TOP_UNIVPLL, "univpll", "univ2pll", 1, 2),
++	FACTOR(CLK_TOP_UNIVPLL_D2, "univpll_d2", "univpll", 1, 2),
++	FACTOR(CLK_TOP_UNIVPLL1_D2, "univpll1_d2", "univpll", 1, 4),
++	FACTOR(CLK_TOP_UNIVPLL1_D4, "univpll1_d4", "univpll", 1, 8),
++	FACTOR(CLK_TOP_UNIVPLL1_D8, "univpll1_d8", "univpll", 1, 16),
++	FACTOR(CLK_TOP_UNIVPLL1_D16, "univpll1_d16", "univpll", 1, 32),
++	FACTOR(CLK_TOP_UNIVPLL2_D2, "univpll2_d2", "univpll", 1, 6),
++	FACTOR(CLK_TOP_UNIVPLL2_D4, "univpll2_d4", "univpll", 1, 12),
++	FACTOR(CLK_TOP_UNIVPLL2_D8, "univpll2_d8", "univpll", 1, 24),
++	FACTOR(CLK_TOP_UNIVPLL2_D16, "univpll2_d16", "univpll", 1, 48),
++	FACTOR(CLK_TOP_UNIVPLL_D5, "univpll_d5", "univpll", 1, 5),
++	FACTOR(CLK_TOP_UNIVPLL3_D2, "univpll3_d2", "univpll", 1, 10),
++	FACTOR(CLK_TOP_UNIVPLL3_D4, "univpll3_d4", "univpll", 1, 20),
++	FACTOR(CLK_TOP_UNIVPLL3_D16, "univpll3_d16", "univpll", 1, 80),
++	FACTOR(CLK_TOP_UNIVPLL_D7, "univpll_d7", "univpll", 1, 7),
++	FACTOR(CLK_TOP_UNIVPLL_D80_D4, "univpll_d80_d4", "univpll", 1, 320),
++	FACTOR(CLK_TOP_UNIV48M, "univ48m", "univpll", 1, 25),
++	FACTOR(CLK_TOP_SGMIIPLL, "sgmiipll_ck", "sgmipll", 1, 1),
++	FACTOR(CLK_TOP_SGMIIPLL_D2, "sgmiipll_d2", "sgmipll", 1, 2),
++	FACTOR(CLK_TOP_AUD1PLL, "aud1pll_ck", "aud1pll", 1, 1),
++	FACTOR(CLK_TOP_AUD2PLL, "aud2pll_ck", "aud2pll", 1, 1),
++	FACTOR(CLK_TOP_AUD_I2S2_MCK, "aud_i2s2_mck", "i2s2_mck_sel", 1, 2),
++	FACTOR(CLK_TOP_TO_USB3_REF, "to_usb3_ref", "univpll2_d4", 1, 4),
++	FACTOR(CLK_TOP_PCIE1_MAC_EN, "pcie1_mac_en", "univpll1_d4", 1, 1),
++	FACTOR(CLK_TOP_PCIE0_MAC_EN, "pcie0_mac_en", "univpll1_d4", 1, 1),
++	FACTOR(CLK_TOP_ETH_500M, "eth_500m", "eth1pll", 1, 1),
++};
++
++static const struct mtk_gate top_clks[] = {
++	/* TOP0 */
++	GATE_TOP0(CLK_TOP_APLL1_DIV_PD, "apll1_ck_div_pd", "apll1_ck_div", 0),
++	GATE_TOP0(CLK_TOP_APLL2_DIV_PD, "apll2_ck_div_pd", "apll2_ck_div", 1),
++	GATE_TOP0(CLK_TOP_I2S0_MCK_DIV_PD, "i2s0_mck_div_pd", "i2s0_mck_div",
++		  2),
++	GATE_TOP0(CLK_TOP_I2S1_MCK_DIV_PD, "i2s1_mck_div_pd", "i2s1_mck_div",
++		  3),
++	GATE_TOP0(CLK_TOP_I2S2_MCK_DIV_PD, "i2s2_mck_div_pd", "i2s2_mck_div",
++		  4),
++	GATE_TOP0(CLK_TOP_I2S3_MCK_DIV_PD, "i2s3_mck_div_pd", "i2s3_mck_div",
++		  5),
++
++	/* TOP1 */
++	GATE_TOP1(CLK_TOP_A1SYS_HP_DIV_PD, "a1sys_div_pd", "a1sys_div", 0),
++	GATE_TOP1(CLK_TOP_A2SYS_HP_DIV_PD, "a2sys_div_pd", "a2sys_div", 16),
++};
++
++static const struct mtk_clk_divider top_adj_divs[] = {
++	DIV_ADJ(CLK_TOP_APLL1_DIV, "apll1_ck_div", "apll1_ck_sel",
++		0x120, 24, 3),
++	DIV_ADJ(CLK_TOP_APLL2_DIV, "apll2_ck_div", "apll2_ck_sel",
++		0x120, 28, 3),
++	DIV_ADJ(CLK_TOP_I2S0_MCK_DIV, "i2s0_mck_div", "i2s0_mck_sel",
++		0x124, 0, 7),
++	DIV_ADJ(CLK_TOP_I2S1_MCK_DIV, "i2s1_mck_div", "i2s1_mck_sel",
++		0x124, 8, 7),
++	DIV_ADJ(CLK_TOP_I2S2_MCK_DIV, "i2s2_mck_div", "aud_i2s2_mck",
++		0x124, 16, 7),
++	DIV_ADJ(CLK_TOP_I2S3_MCK_DIV, "i2s3_mck_div", "i2s3_mck_sel",
++		0x124, 24, 7),
++	DIV_ADJ(CLK_TOP_A1SYS_HP_DIV, "a1sys_div", "a1sys_hp_sel",
++		0x128, 8, 7),
++	DIV_ADJ(CLK_TOP_A2SYS_HP_DIV, "a2sys_div", "a2sys_hp_sel",
++		0x128, 24, 7),
++};
++
++static const struct mtk_gate peri_clks[] = {
++	/* PERI0 */
++	GATE_PERI0(CLK_PERI_THERM_PD, "peri_therm_pd", "axi_sel", 1),
++	GATE_PERI0(CLK_PERI_PWM1_PD, "peri_pwm1_pd", "clkxtal", 2),
++	GATE_PERI0(CLK_PERI_PWM2_PD, "peri_pwm2_pd", "clkxtal", 3),
++	GATE_PERI0(CLK_PERI_PWM3_PD, "peri_pwm3_pd", "clkxtal", 4),
++	GATE_PERI0(CLK_PERI_PWM4_PD, "peri_pwm4_pd", "clkxtal", 5),
++	GATE_PERI0(CLK_PERI_PWM5_PD, "peri_pwm5_pd", "clkxtal", 6),
++	GATE_PERI0(CLK_PERI_PWM6_PD, "peri_pwm6_pd", "clkxtal", 7),
++	GATE_PERI0(CLK_PERI_PWM7_PD, "peri_pwm7_pd", "clkxtal", 8),
++	GATE_PERI0(CLK_PERI_PWM_PD, "peri_pwm_pd", "clkxtal", 9),
++	GATE_PERI0(CLK_PERI_AP_DMA_PD, "peri_ap_dma_pd", "axi_sel", 12),
++	GATE_PERI0(CLK_PERI_MSDC30_0_PD, "peri_msdc30_0", "msdc30_0_sel", 13),
++	GATE_PERI0(CLK_PERI_MSDC30_1_PD, "peri_msdc30_1", "msdc30_1_sel", 14),
++	GATE_PERI0(CLK_PERI_UART0_PD, "peri_uart0_pd", "axi_sel", 17),
++	GATE_PERI0(CLK_PERI_UART1_PD, "peri_uart1_pd", "axi_sel", 18),
++	GATE_PERI0(CLK_PERI_UART2_PD, "peri_uart2_pd", "axi_sel", 19),
++	GATE_PERI0(CLK_PERI_UART3_PD, "peri_uart3_pd", "axi_sel", 20),
++	GATE_PERI0(CLK_PERI_UART4_PD, "peri_uart4_pd", "axi_sel", 21),
++	GATE_PERI0(CLK_PERI_BTIF_PD, "peri_btif_pd", "axi_sel", 22),
++	GATE_PERI0(CLK_PERI_I2C0_PD, "peri_i2c0_pd", "axi_sel", 23),
++	GATE_PERI0(CLK_PERI_I2C1_PD, "peri_i2c1_pd", "axi_sel", 24),
++	GATE_PERI0(CLK_PERI_I2C2_PD, "peri_i2c2_pd", "axi_sel", 25),
++	GATE_PERI0(CLK_PERI_SPI1_PD, "peri_spi1_pd", "spi1_sel", 26),
++	GATE_PERI0(CLK_PERI_AUXADC_PD, "peri_auxadc_pd", "clkxtal", 27),
++	GATE_PERI0(CLK_PERI_SPI0_PD, "peri_spi0_pd", "spi0_sel", 28),
++	GATE_PERI0(CLK_PERI_SNFI_PD, "peri_snfi_pd", "nfi_infra_sel", 29),
++	GATE_PERI0(CLK_PERI_NFI_PD, "peri_nfi_pd", "axi_sel", 30),
++	GATE_PERI0(CLK_PERI_NFIECC_PD, "peri_nfiecc_pd", "axi_sel", 31),
++
++	/* PERI1 */
++	GATE_PERI1(CLK_PERI_FLASH_PD, "peri_flash_pd", "flash_sel", 1),
++	GATE_PERI1(CLK_PERI_IRTX_PD, "peri_irtx_pd", "irtx_sel", 2),
++};
++
++static struct mtk_composite infra_muxes[] __initdata = {
++	MUX(CLK_INFRA_MUX1_SEL, "infra_mux1_sel", infra_mux1_parents,
++	    0x000, 2, 2),
++};
++
++static struct mtk_composite top_muxes[] = {
++	/* CLK_CFG_0 */
++	MUX_GATE(CLK_TOP_ETH_SEL, "eth_sel", eth_parents,
++		 0x040, 24, 3, 31),
++};
++
++static struct mtk_composite peri_muxes[] = {
++	/* PERI_GLOBALCON_CKSEL */
++	MUX(CLK_PERIBUS_SEL, "peribus_ck_sel", peribus_ck_parents, 0x05C, 0, 1),
++};
++
++static int mtk_topckgen_init(struct platform_device *pdev)
++{
++	struct clk_onecell_data *clk_data;
++	void __iomem *base;
++	struct device_node *node = pdev->dev.of_node;
++	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++
++	base = devm_ioremap_resource(&pdev->dev, res);
++	if (IS_ERR(base))
++		return PTR_ERR(base);
++
++	clk_data = mtk_alloc_clk_data(CLK_TOP_NR_CLK);
++
++	mtk_clk_register_fixed_clks(top_fixed_clks, ARRAY_SIZE(top_fixed_clks),
++				    clk_data);
++
++	mtk_clk_register_factors(top_divs, ARRAY_SIZE(top_divs),
++				 clk_data);
++
++	mtk_clk_register_composites(top_muxes, ARRAY_SIZE(top_muxes),
++				    base, &mt7621_clk_lock, clk_data);
++
++	mtk_clk_register_dividers(top_adj_divs, ARRAY_SIZE(top_adj_divs),
++				  base, &mt7621_clk_lock, clk_data);
++
++	mtk_clk_register_gates(node, top_clks, ARRAY_SIZE(top_clks),
++			       clk_data);
++
++	clk_prepare_enable(clk_data->clks[CLK_TOP_AXI_SEL]);
++	clk_prepare_enable(clk_data->clks[CLK_TOP_MEM_SEL]);
++	clk_prepare_enable(clk_data->clks[CLK_TOP_DDRPHYCFG_SEL]);
++
++	return of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
++}
++
++static const struct of_device_id of_match_clk_mt7621[] = {
++	{
++		.compatible = "mediatek,mt7621-topckgen",
++		.data = mtk_topckgen_init,
++	}, {
++		/* sentinel */
++	}
++};
++
++static int clk_mt7621_probe(struct platform_device *pdev)
++{
++	int (*clk_init)(struct platform_device *);
++	int r;
++	
++	dev_err(&pdev->dev, "clk_mt7621_probe\n");
++
++	clk_init = of_device_get_match_data(&pdev->dev);
++	if (!clk_init) {
++		dev_err(&pdev->dev, "clk_mt7621_probe failed\n");
++		return -EINVAL;
++	};
++    
++	r = clk_init(pdev);
++	if (r)
++		dev_err(&pdev->dev,
++			"could not register clock provider: %s: %d\n",
++			pdev->name, r);
++
++	return r;
++}
++
++static struct platform_driver clk_mt7621_drv = {
++	.probe = clk_mt7621_probe,
++	.driver = {
++		.name = "clk-mt7621",
++		.of_match_table = of_match_clk_mt7621,
++	},
++};
++
++static int clk_mt7621_init(void)
++{
++	return platform_driver_register(&clk_mt7621_drv);
++}
++
++arch_initcall(clk_mt7621_init);
+diff --git a/include/dt-bindings/clock/mt7621-clk.h b/include/dt-bindings/clock/mt7621-clk.h
+new file mode 100644
+index 000000000000..7e6b66a9e644
+--- /dev/null
++++ b/include/dt-bindings/clock/mt7621-clk.h
+@@ -0,0 +1,37 @@
++/*
++ * Copyright (c) 2017 MediaTek Inc.
++ * Author: Chen Zhong <chen.zhong@mediatek.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#ifndef _DT_BINDINGS_CLK_MT7621_H
++#define _DT_BINDINGS_CLK_MT7621_H
++
++/* FIXED */
++
++#define CLK_TOP_XTAL			0
++#define CLK_TOP_ETH_500M		1
++#define CLK_TOP_ETH_SEL			2
++#define CLK_TOP_APLL_SEL		3
++#define CLK_TOP_NR_CLK			4
++
++/* ETHSYS */
++
++#define CLK_ETHSYS_HSDMA		1
++#define CLK_ETHSYS_ESW			2
++#define CLK_ETHSYS_GDMA			3
++#define CLK_ETHSYS_I2C			4
++#define CLK_ETHSYS_ETH			5
++#define CLK_ETHSYS_CRYPTO		6
++#define CLK_ETHSYS_NR			7
++
++#endif /* _DT_BINDINGS_CLK_MT7621_H */
++
+-- 
+2.17.1
+
unchanged:
--- /dev/null
+++ b/target/linux/ramips/patches-4.14/2002-Adding-MT7621-DSA-support.patch
@@ -0,0 +1,452 @@
+From 0994aa91b24ae1d3f9a98630c87f20758e2ac2b5 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Ren=C3=A9=20van=20Dorst?= <opensource@vdorst.com>
+Date: Thu, 19 Jul 2018 16:12:40 +0200
+Subject: [PATCH 2002/2002] Adding MT7621 DSA support.
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: René van Dorst <opensource@vdorst.com>
+---
+ drivers/net/dsa/mt7530.c                    | 37 +++++++++-
+ drivers/net/ethernet/mtk/Kconfig       |  4 +-
+ 4 files changed, 135 insertions(+), 8 deletions(-)
+
+diff --git a/drivers/net/dsa/mt7530.c b/drivers/net/dsa/mt7530.c
+index d8407a72d676..dc48f01674ab 100644
+--- a/drivers/net/dsa/mt7530.c
++++ b/drivers/net/dsa/mt7530.c
+@@ -662,6 +662,7 @@ static void mt7530_adjust_link(struct dsa_switch *ds, int port,
+ 			if (flowctrl & FLOW_CTRL_RX)
+ 				mcr |= PMCR_RX_FC_EN;
+ 		}
++		dev_info(priv->dev, "Adjust link: %d, %x\n", port, mcr);
+ 		mt7530_write(priv, MT7530_PMCR_P(port), mcr);
+ 	}
+ }
+@@ -673,6 +674,8 @@ mt7530_cpu_port_enable(struct mt7530_priv *priv,
+ 	u8 port_mask = 0;
+ 	int i;
+ 
++	dev_info(priv->dev, "mt7530_cpu_port_enable: %d", port);
++
+ 	/* Enable Mediatek header mode on the cpu port */
+ 	mt7530_write(priv, MT7530_PVC_P(port),
+ 		     PORT_SPEC_TAG);
+@@ -944,6 +947,8 @@ mt7530_setup(struct dsa_switch *ds)
+ 	if (IS_ERR(priv->ethernet))
+ 		return PTR_ERR(priv->ethernet);
+ 
++#ifndef CONFIG_SOC_MT7621
++	// FIXME: Enable regulators on MT7621 if needed
+ 	regulator_set_voltage(priv->core_pwr, 1000000, 1000000);
+ 	ret = regulator_enable(priv->core_pwr);
+ 	if (ret < 0) {
+@@ -959,7 +964,7 @@ mt7530_setup(struct dsa_switch *ds)
+ 			ret);
+ 		return ret;
+ 	}
+-
++#endif
+ 	/* Reset whole chip through gpio pin or memory-mapped registers for
+ 	 * different type of hardware
+ 	 */
+@@ -994,17 +999,38 @@ mt7530_setup(struct dsa_switch *ds)
+ 		     SYS_CTRL_PHY_RST | SYS_CTRL_SW_RST |
+ 		     SYS_CTRL_REG_RST);
+ 
+-	/* Enable Port 6 only; P5 as GMAC5 which currently is not supported */
++	/* Enable Port 6 only; P5 as GMAC5 */
+ 	val = mt7530_read(priv, MT7530_MHWTRAP);
++
+ 	val &= ~MHWTRAP_P5_DIS & ~MHWTRAP_P6_DIS & ~MHWTRAP_PHY_ACCESS;
+ 	val |= MHWTRAP_MANUAL;
++
+ 	if (!dsa_is_cpu_port(ds, 5)) {
+ 		val |= MHWTRAP_P5_DIS;
+ 		val |= MHWTRAP_P5_MAC_SEL;
+ 		val |= MHWTRAP_P5_RGMII_MODE;
+-	}
++	};
++
+ 	mt7530_write(priv, MT7530_MHWTRAP, val);
+ 
++	if (!dsa_is_cpu_port(ds, 5)) {
++		dev_info(priv->dev, "P5 disabled.\n");
++		/* (P5, link OFF) */
++		mt7530_write(priv, MT7530_PMCR_P(5), PMCR_FORCE_MODE);
++
++		/* P5 RGMII TX Clock Control, delay 0 */
++		mt7530_write(priv, MT7530_P5RGMIITXCR, CSR_RGMII_TXC_CFG(0x10));
++
++		/* reduce P5 RGMII Tx driving, 8mA*/
++		val = P5_IO_CLK_DRV(1);
++		val |= P5_IO_DATA_DRV(1);
++		mt7530_write(priv, MT7530_IO_DRV_CR, val);
++
++		/* P5 RGMII RX Clock Control: delay setting for 1000M */
++		val = CSR_RGMII_EDGE_ALIGN | CSR_RGMII_RXC_0DEG_CFG(2);
++		mt7530_write(priv, MT7530_P5RGMIIRXCR, val);
++	}
++
+ 	/* Enable and reset MIB counters */
+ 	mt7530_mib_reset(ds);
+ 
+@@ -1054,6 +1080,8 @@ mt7530_probe(struct platform_device *mdiodev)
+ 	struct mt7530_priv *priv;
+ 	struct device_node *dn, *mdio;
+ 
++	dev_info(&mdiodev->dev,"mt7530_probe\n");
++
+ 	dn = mdiodev->dev.of_node;
+ 
+ 	priv = devm_kzalloc(&mdiodev->dev, sizeof(*priv), GFP_KERNEL);
+@@ -1078,6 +1106,8 @@ mt7530_probe(struct platform_device *mdiodev)
+ 		}
+ 	}
+ 
++#ifndef CONFIG_SOC_MT7621
++	// FIXME: Enable regulators on MT7621 if needed
+ 	priv->core_pwr = devm_regulator_get(&mdiodev->dev, "core");
+ 	if (IS_ERR(priv->core_pwr))
+ 		return PTR_ERR(priv->core_pwr);
+@@ -1085,6 +1115,7 @@ mt7530_probe(struct platform_device *mdiodev)
+ 	priv->io_pwr = devm_regulator_get(&mdiodev->dev, "io");
+ 	if (IS_ERR(priv->io_pwr))
+ 		return PTR_ERR(priv->io_pwr);
++#endif
+ 
+ 	/* Not MCM that indicates switch works as the remote standalone
+ 	 * integrated circuit so the GPIO pin would be used to complete
+diff --git a/drivers/net/ethernet/mtk/Kconfig b/drivers/net/ethernet/mtk/Kconfig
+index f9149d2a4694..2f00a59d8734 100644
+--- a/drivers/net/ethernet/mtk/Kconfig
++++ b/drivers/net/ethernet/mtk/Kconfig
+@@ -1,6 +1,6 @@
+ config NET_VENDOR_MEDIATEK
+ 	bool "MediaTek ethernet driver"
+-	depends on ARCH_MEDIATEK
++	depends on ARCH_MEDIATEK || SOC_MT7621
+ 	---help---
+ 	  If you have a Mediatek SoC with ethernet, say Y.
+ 
+@@ -9,7 +9,7 @@ if NET_VENDOR_MEDIATEK
+ config NET_MEDIATEK_SOC
+ 	tristate "MediaTek SoC Gigabit Ethernet support"
+ 	depends on NET_VENDOR_MEDIATEK
+-	select PHYLIB
++	select PHYLINK
+ 	---help---
+ 	  This driver supports the gigabit ethernet MACs in the
+ 	  MediaTek SoC family.
+diff --git a/drivers/net/ethernet/mtk/mtk_eth_soc.c b/drivers/net/ethernet/mtk/mtk_eth_soc.c
+index b5f3241d48b0..1debf9eeb24c 100644
+--- a/drivers/net/ethernet/mtk/mtk_eth_soc.c
++++ b/drivers/net/ethernet/mtk/mtk_eth_soc.c
+@@ -143,12 +143,16 @@ static int mtk_mdio_read(struct mii_bus *bus, int phy_addr, int phy_reg)
+ static void mtk_gmac0_rgmii_adjust(struct mtk_eth *eth, int speed)
+ {
+ 	u32 val;
++#ifndef CONFIG_SOC_MT7621
+ 	int ret;
++#endif
+ 
+ 	val = (speed == SPEED_1000) ?
+ 		INTF_MODE_RGMII_1000 : INTF_MODE_RGMII_10_100;
+ 	mtk_w32(eth, val, INTF_MODE);
+ 
++#ifndef CONFIG_SOC_MT7621
++	// FIXME: Add TRGMII init code for MT7621!
+ 	regmap_update_bits(eth->ethsys, ETHSYS_CLKCFG0,
+ 			   ETHSYS_TRGMII_CLK_SEL362_5,
+ 			   ETHSYS_TRGMII_CLK_SEL362_5);
+@@ -157,6 +161,7 @@ static void mtk_gmac0_rgmii_adjust(struct mtk_eth *eth, int speed)
+ 	ret = clk_set_rate(eth->clks[MTK_CLK_TRGPLL], val);
+ 	if (ret)
+ 		dev_err(eth->dev, "Failed to set trgmii pll: %d\n", ret);
++#endif
+ 
+ 	val = (speed == SPEED_1000) ?
+ 		RCK_CTRL_RGMII_1000 : RCK_CTRL_RGMII_10_100;
+@@ -167,6 +172,7 @@ static void mtk_gmac0_rgmii_adjust(struct mtk_eth *eth, int speed)
+ 	mtk_w32(eth, val, TRGMII_TCK_CTRL);
+ }
+ 
++#ifndef CONFIG_SOC_MT7621
+ static void mtk_gmac_sgmii_hw_setup(struct mtk_eth *eth, int mac_id)
+ {
+ 	u32 val;
+@@ -207,6 +213,7 @@ static void mtk_gmac_sgmii_hw_setup(struct mtk_eth *eth, int mac_id)
+ 		dev_info(eth->dev, "setup gmac1 going through sgmii");
+ 	}
+ }
++#endif
+ 
+ static void mtk_phy_link_adjust(struct net_device *dev)
+ {
+@@ -257,11 +264,13 @@ static void mtk_phy_link_adjust(struct net_device *dev)
+ 		if (flowctrl & FLOW_CTRL_RX)
+ 			mcr |= MAC_MCR_FORCE_RX_FC;
+ 
+-		netif_dbg(mac->hw, link, dev, "rx pause %s, tx pause %s\n",
++		netif_info(mac->hw, link, dev, "rx pause %s, tx pause %s\n",
+ 			  flowctrl & FLOW_CTRL_RX ? "enabled" : "disabled",
+ 			  flowctrl & FLOW_CTRL_TX ? "enabled" : "disabled");
+ 	}
+ 
++	printk("mtk_phy_link_adjust: %d, %x\n", mac->id, mcr);
++
+ 	mtk_w32(mac->hw, mcr, MTK_MAC_MCR(mac->id));
+ 
+ 	if (dev->phydev->link)
+@@ -324,10 +333,12 @@ static int mtk_phy_connect(struct net_device *dev)
+ 	case PHY_INTERFACE_MODE_RGMII_ID:
+ 	case PHY_INTERFACE_MODE_RGMII:
+ 		break;
++#ifndef CONFIG_SOC_MT7621
+ 	case PHY_INTERFACE_MODE_SGMII:
+ 		if (MTK_HAS_CAPS(eth->soc->caps, MTK_SGMII))
+ 			mtk_gmac_sgmii_hw_setup(eth, mac->id);
+ 		break;
++#endif
+ 	case PHY_INTERFACE_MODE_MII:
+ 		mac->ge_mode = 1;
+ 		break;
+@@ -1768,6 +1779,28 @@ static void mtk_tx_timeout(struct net_device *dev)
+ 	schedule_work(&eth->pending_work);
+ }
+ 
++#ifdef CONFIG_SOC_MT7621
++static irqreturn_t mtk_handle_irq(int irq, void *_eth)
++{
++	struct mtk_eth *eth = _eth;
++
++	/* RX */
++	if (mtk_r32(eth, MTK_PDMA_INT_STATUS) & MTK_RX_DONE_INT)
++		if (likely(napi_schedule_prep(&eth->rx_napi))) {
++			__napi_schedule(&eth->rx_napi);
++			mtk_rx_irq_disable(eth, MTK_RX_DONE_INT);
++		}
++
++	/* TX */
++	if (mtk_r32(eth, MTK_QMTK_INT_STATUS) & MTK_TX_DONE_INT)
++		if (likely(napi_schedule_prep(&eth->tx_napi))) {
++			__napi_schedule(&eth->tx_napi);
++			mtk_tx_irq_disable(eth, MTK_TX_DONE_INT);
++		}
++
++	return IRQ_HANDLED;
++}
++#else
+ static irqreturn_t mtk_handle_irq_rx(int irq, void *_eth)
+ {
+ 	struct mtk_eth *eth = _eth;
+@@ -1791,6 +1824,7 @@ static irqreturn_t mtk_handle_irq_tx(int irq, void *_eth)
+ 
+ 	return IRQ_HANDLED;
+ }
++#endif
+ 
+ #ifdef CONFIG_NET_POLL_CONTROLLER
+ static void mtk_poll_controller(struct net_device *dev)
+@@ -1800,7 +1834,9 @@ static void mtk_poll_controller(struct net_device *dev)
+ 
+ 	mtk_tx_irq_disable(eth, MTK_TX_DONE_INT);
+ 	mtk_rx_irq_disable(eth, MTK_RX_DONE_INT);
++#ifndef CONFIG_SOC_MT7621
+ 	mtk_handle_irq_rx(eth->irq[2], dev);
++#endif
+ 	mtk_tx_irq_enable(eth, MTK_TX_DONE_INT);
+ 	mtk_rx_irq_enable(eth, MTK_RX_DONE_INT);
+ }
+@@ -1976,6 +2012,27 @@ static int mtk_hw_init(struct mtk_eth *eth)
+ 	}
+ 	regmap_write(eth->ethsys, ETHSYS_SYSCFG0, val);
+ 
++#ifdef CONFIG_SOC_MT7621
++
++#define SYSC_PAD_RGMII2_MDIO	0x58
++#define SYSC_GPIO_MODE	0x60
++#define SYSC_REG_CFG1	0x14
++	printk("MT7621: GE2: Pininit\n");
++
++	/* reduce RGMII1 PAD driving strength */
++	regmap_read(eth->ethsys, SYSC_PAD_RGMII2_MDIO, &val);
++	// MDIO
++	val &= ~(3 << 4);
++	// RGMII2, 12mA
++	val &= ~(3 <<20); 
++	val |= (2 << 20); 
++	regmap_write(eth->ethsys, SYSC_PAD_RGMII2_MDIO, val);
++
++	/* gpio mux - RGMII1&RGMII2=Normal mode, set GMAC1,2 RGMII mode  */
++	regmap_read(eth->ethsys, SYSC_GPIO_MODE, &val);
++	val &= ~(BIT(14) | BIT(15) | 3 << 12 | 3 << 14);
++	regmap_write(eth->ethsys, SYSC_GPIO_MODE, val);
++#else
+ 	if (eth->pctl) {
+ 		/* Set GE2 driving and slew rate */
+ 		regmap_write(eth->pctl, GPIO_DRV_SEL10, 0xa00);
+@@ -1986,6 +2043,7 @@ static int mtk_hw_init(struct mtk_eth *eth)
+ 		/* set GE2 TUNE */
+ 		regmap_write(eth->pctl, GPIO_BIAS_CTRL, 0x0);
+ 	}
++#endif
+ 
+ 	/* Set linkdown as the default for each GMAC. Its own MCR would be set
+ 	 * up with the more appropriate value when mtk_phy_link_adjust call is
+@@ -2555,11 +2613,13 @@ static int mtk_probe(struct platform_device *pdev)
+ 
+ 	eth->ethsys = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,
+ 						      "mediatek,ethsys");
++
+ 	if (IS_ERR(eth->ethsys)) {
+ 		dev_err(&pdev->dev, "no ethsys regmap found\n");
+ 		return PTR_ERR(eth->ethsys);
+ 	}
+ 
++#ifndef CONFIG_SOC_MT7621
+ 	if (MTK_HAS_CAPS(eth->soc->caps, MTK_SGMII)) {
+ 		eth->sgmiisys =
+ 		syscon_regmap_lookup_by_phandle(pdev->dev.of_node,
+@@ -2569,6 +2629,7 @@ static int mtk_probe(struct platform_device *pdev)
+ 			return PTR_ERR(eth->sgmiisys);
+ 		}
+ 	}
++#endif
+ 
+ 	if (eth->soc->required_pctl) {
+ 		eth->pctl = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,
+@@ -2579,13 +2640,15 @@ static int mtk_probe(struct platform_device *pdev)
+ 		}
+ 	}
+ 
+-	for (i = 0; i < 3; i++) {
++	for (i = 0; i < IRQ_MAX; i++)
++	{
+ 		eth->irq[i] = platform_get_irq(pdev, i);
+ 		if (eth->irq[i] < 0) {
+ 			dev_err(&pdev->dev, "no IRQ%d resource found\n", i);
+ 			return -ENXIO;
+ 		}
+ 	}
++
+ 	for (i = 0; i < ARRAY_SIZE(eth->clks); i++) {
+ 		eth->clks[i] = devm_clk_get(eth->dev,
+ 					    mtk_clks_source_name[i]);
+@@ -2627,6 +2690,11 @@ static int mtk_probe(struct platform_device *pdev)
+ 			goto err_deinit_hw;
+ 	}
+ 
++#ifdef CONFIG_SOC_MT7621
++	/* MT7621 has only 1 interrupt for rx & tx */
++	err = devm_request_irq(eth->dev, eth->irq[0], mtk_handle_irq, 0,
++	           dev_name(eth->dev), eth);
++#else
+ 	err = devm_request_irq(eth->dev, eth->irq[1], mtk_handle_irq_tx, 0,
+ 			       dev_name(eth->dev), eth);
+ 	if (err)
+@@ -2634,6 +2702,7 @@ static int mtk_probe(struct platform_device *pdev)
+ 
+ 	err = devm_request_irq(eth->dev, eth->irq[2], mtk_handle_irq_rx, 0,
+ 			       dev_name(eth->dev), eth);
++#endif
+ 	if (err)
+ 		goto err_free_dev;
+ 
+@@ -2706,6 +2775,11 @@ static const struct mtk_soc_data mt2701_data = {
+ 	.required_pctl = true,
+ };
+ 
++static const struct mtk_soc_data mt7621_data = {
++	.caps = 0,
++	.required_clks = MT7621_CLKS_BITMAP
++};
++
+ static const struct mtk_soc_data mt7622_data = {
+ 	.caps = MTK_DUAL_GMAC_SHARED_SGMII | MTK_GMAC1_ESW,
+ 	.required_clks = MT7622_CLKS_BITMAP,
+@@ -2720,6 +2794,7 @@ static const struct mtk_soc_data mt7623_data = {
+ 
+ const struct of_device_id of_mtk_match[] = {
+ 	{ .compatible = "mediatek,mt2701-eth", .data = &mt2701_data},
++	{ .compatible = "mediatek,mt7621-eth", .data = &mt7621_data},
+ 	{ .compatible = "mediatek,mt7622-eth", .data = &mt7622_data},
+ 	{ .compatible = "mediatek,mt7623-eth", .data = &mt7623_data},
+ 	{},
+diff --git a/drivers/net/ethernet/mtk/mtk_eth_soc.h b/drivers/net/ethernet/mtk/mtk_eth_soc.h
+index 8c657616a102..747f715310ca 100644
+--- a/drivers/net/ethernet/mtk/mtk_eth_soc.h
++++ b/drivers/net/ethernet/mtk/mtk_eth_soc.h
+@@ -364,18 +364,28 @@
+ #define ETHSYS_CHIPID4_7	0x4
+ #define MT7623_ETH		7623
+ #define MT7622_ETH		7622
++#define MT7621_ETH		7621
+ 
+ /* ethernet subsystem config register */
+ #define ETHSYS_SYSCFG0		0x14
+ #define SYSCFG0_GE_MASK		0x3
+ #define SYSCFG0_GE_MODE(x, y)	(x << (12 + (y * 2)))
++
++#ifndef CONFIG_SOC_MT7621
+ #define SYSCFG0_SGMII_MASK	(3 << 8)
+ #define SYSCFG0_SGMII_GMAC1	((2 << 8) & GENMASK(9, 8))
+ #define SYSCFG0_SGMII_GMAC2	((3 << 8) & GENMASK(9, 8))
++#endif
+ 
+ /* ethernet subsystem clock register */
+ #define ETHSYS_CLKCFG0		0x2c
++
++#ifdef CONFIG_SOC_MT7621
++#define ETHSYS_TRGMII_CLK_SEL_MASK	( BIT(5) | BIT(6) )
++#define ETHSYS_TRGMII_CLK_SEL_APLL 	BIT(6)
++#else
+ #define ETHSYS_TRGMII_CLK_SEL362_5	BIT(11)
++#endif
+ 
+ /* ethernet reset control register */
+ #define ETHSYS_RSTCTRL		0x34
+@@ -489,6 +499,8 @@ enum mtk_clks_map {
+ 				 BIT(MTK_CLK_SGMII_CDR_FB) | \
+ 				 BIT(MTK_CLK_SGMII_CK) | \
+ 				 BIT(MTK_CLK_ETH2PLL))
++#define MT7621_CLKS_BITMAP	(BIT(MTK_CLK_ETHIF) | BIT(MTK_CLK_ESW) )
++
+ enum mtk_dev_state {
+ 	MTK_HW_INIT,
+ 	MTK_RESETTING
+@@ -621,6 +633,13 @@ struct mtk_soc_data {
+  * @soc:		Holding specific data among vaious SoCs
+  */
+ 
++/* Number of IRQs used */
++#ifdef CONFIG_SOC_MT7621
++#define IRQ_MAX 1
++#else
++#define IRQ_MAX 3
++#endif
++
+ struct mtk_eth {
+ 	struct device			*dev;
+ 	void __iomem			*base;
+@@ -630,11 +649,13 @@ struct mtk_eth {
+ 	struct net_device		dummy_dev;
+ 	struct net_device		*netdev[MTK_MAX_DEVS];
+ 	struct mtk_mac			*mac[MTK_MAX_DEVS];
+-	int				irq[3];
++	int				irq[IRQ_MAX];
+ 	u32				msg_enable;
+ 	unsigned long			sysclk;
+ 	struct regmap			*ethsys;
++#ifndef CONFIG_SOC_MT7621
+ 	struct regmap			*sgmiisys;
++#endif
+ 	struct regmap			*pctl;
+ 	u32				chip_id;
+ 	bool				hwlro;
+-- 
+2.17.1
+
unchanged:
--- /dev/null
+++ b/target/linux/ramips/patches-4.14/2100-at803x-advertise-fiber-support.patch
@@ -0,0 +1,99 @@
+From 3e45b08c39176b29b6a2394cd41fbbdebe1ab70b Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Ren=C3=A9=20van=20Dorst?= <opensource@vdorst.com>
+Date: Wed, 25 Jul 2018 13:52:56 +0200
+Subject: [PATCH] at803x: advertise fiber support.
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Also adding ethtool support.
+Signed-off-by: René van Dorst <opensource@vdorst.com>
+---
+ drivers/net/phy/at803x.c | 51 +++++++++++++++++++++++++++++++++++++++-
+ 1 file changed, 50 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/net/phy/at803x.c b/drivers/net/phy/at803x.c
+index 584bf34ef721..b8bf14a3ef4e 100644
+--- a/drivers/net/phy/at803x.c
++++ b/drivers/net/phy/at803x.c
+@@ -82,6 +82,16 @@ MODULE_DESCRIPTION("Atheros 803x PHY driver");
+ MODULE_AUTHOR("Matus Ujhelyi");
+ MODULE_LICENSE("GPL");
+ 
++struct at803x_hw_stat {
++	const char *string;
++	u8 reg;
++	u8 bits;
++};
++
++static struct at803x_hw_stat at803x_hw_stats[] = {
++	{ "phy_idle_errors", 10, 8 },
++};
++
+ struct at803x_priv {
+ 	bool phy_reset:1;
+ 	struct gpio_desc *gpiod_reset;
+@@ -97,6 +107,41 @@ struct at803x_context {
+ 	u16 led_control;
+ };
+ 
++
++static int at803x_phy_get_sset_count(struct phy_device *phydev)
++{
++	return ARRAY_SIZE(at803x_hw_stat);
++}
++
++static void at803x_phy_get_strings(struct phy_device *phydev, u8 *data)
++{
++	unsigned int i;
++
++	for (i = 0; i < ARRAY_SIZE(at803x_phy_hw_stats); i++)
++		memcpy(data + i * ETH_GSTRING_LEN,
++		       at803x_phy_hw_stats[i].string, ETH_GSTRING_LEN);
++}
++
++static void at803x_phy_get_stats(struct phy_device *phydev, u64 *shadow,
++		       struct ethtool_stats *stats, u64 *data)
++{
++	unsigned int i;
++	int val;
++	struct at803x_phy_hw_stat stat;
++	u64 ret;
++
++	for (i = 0; i < ARRAY_SIZE(at803x_phy_hw_stats); i++) {
++		stat = at803x_phy_hw_stats[i];
++		val = phy_read(phydev, stat.reg);
++		if (val < 0) {
++			ret = UINT64_MAX;
++		} else {
++			val >>= stat.shift;
++			ret = val & ((1 << stat.bits) - 1);
++		}
++		data[i] = ret;
++}
++
+ static int at803x_debug_reg_read(struct phy_device *phydev, u16 reg)
+ {
+ 	int ret;
+@@ -521,13 +566,17 @@ static struct phy_driver at803x_driver[] = {
+ 	.get_wol		= at803x_get_wol,
+ 	.suspend		= at803x_suspend,
+ 	.resume			= at803x_resume,
+-	.features		= PHY_GBIT_FEATURES,
++	.features		= PHY_GBIT_FEATURES | SUPPORTED_FIBRE,
+ 	.flags			= PHY_HAS_INTERRUPT,
+ 	.config_aneg		= genphy_config_aneg,
+ 	.read_status		= genphy_read_status,
+ 	.aneg_done		= at803x_aneg_done,
+ 	.ack_interrupt		= &at803x_ack_interrupt,
+ 	.config_intr		= &at803x_config_intr,
++	.set_loopback		= genphy_loopback,
++	.get_sset_count		= at803x_get_sset_count,
++	.get_strings		= at803x_get_strings,
++	.get_stats		= at803x_get_stats,
+ }, {
+ 	/* ATHEROS 8032 */
+ 	.phy_id			= ATH8032_PHY_ID,
+-- 
+2.17.1
+
