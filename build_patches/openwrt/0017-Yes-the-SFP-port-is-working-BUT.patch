From bf599736920cffa93ca29c455f933acdd12010ed Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ren=C3=A9=20van=20Dorst?= <opensource@vdorst.com>
Date: Tue, 7 Aug 2018 22:16:35 +0200
Subject: [PATCH 9/9] Yes the SFP port is working, BUT...

SFP port is connected to switch P5 not to the 2nd GMAC.
I tried hard to get SFP working with 2nd GMAC but I do something wrong.
After reinstalling UBNT v1.10.5 and looking at io settings.
I discovered that 2nd GMAC is disables and also GPIO pins are in GPIO MODE.

Switch port P5 is enabled and running as MAC.

You need to force speed autoneg and duplex of lan5.
Autoneg is detecting the wrong speed. Also try to fix that.
---
 .../ramips/base-files/etc/board.d/02_network  |   2 +-
 target/linux/ramips/dts/UBNT-ER-e50.dtsi      |  15 ++-
 target/linux/ramips/dts/UBNT-ERX-SFP.dts      |   2 +-
 .../ramips/patches-4.14/2101-at803x.patch     |  59 +++++-----
 .../ramips/patches-4.14/2102-mt7530.patch     |  87 ++++++---------
 .../ramips/patches-4.14/2103-mtk-eth.patch    | 105 +++++++++++++++---
 6 files changed, 165 insertions(+), 105 deletions(-)

diff --git a/target/linux/ramips/base-files/etc/board.d/02_network b/target/linux/ramips/base-files/etc/board.d/02_network
index fcacaacbe6..a55d7d1e2a 100755
--- a/target/linux/ramips/base-files/etc/board.d/02_network
+++ b/target/linux/ramips/base-files/etc/board.d/02_network
@@ -380,7 +380,7 @@ ramips_setup_interfaces()
 		;;
 	ubnt-erx-sfp)
 		ucidef_set_interface_lan "lan0 lan1 lan2 lan3 lan4"
-		ucidef_set_interface_wan eth1
+		ucidef_set_interface_wan lan5
 		;;
 	*)
 		RT3X5X=`cat /proc/cpuinfo | egrep "(RT3.5|RT5350)"`
diff --git a/target/linux/ramips/dts/UBNT-ER-e50.dtsi b/target/linux/ramips/dts/UBNT-ER-e50.dtsi
index a939fb20b3..faa92e0a9c 100644
--- a/target/linux/ramips/dts/UBNT-ER-e50.dtsi
+++ b/target/linux/ramips/dts/UBNT-ER-e50.dtsi
@@ -75,14 +75,6 @@
 		};
 	};
 
-	gmac1: mac@1 {
-		compatible = "mediatek,eth-mac";
-		mtd-mac-address = <&factory 0x22>;
-		mtd-mac-address-increment = <1>;
-		reg = <1>;
-		phy-mode = "rgmii";
-		phy-handle = <&ephy5>;
-	};
 
 	mdio: mdio-bus {
 		#address-cells = <1>;
@@ -143,6 +135,13 @@
 			cpu = <&cpu_port0>;
 		};
 
+		lan5: port@5 {
+			reg = <5>;
+			label = "lan5";
+			cpu = <&cpu_port0>;
+			phy-handle = <&ephy5>;
+		};
+
 		cpu_port0: port@6 {
 			reg = <6>;
 			label = "cpu";
diff --git a/target/linux/ramips/dts/UBNT-ERX-SFP.dts b/target/linux/ramips/dts/UBNT-ERX-SFP.dts
index 33ccfaf34b..478c83f5e4 100644
--- a/target/linux/ramips/dts/UBNT-ERX-SFP.dts
+++ b/target/linux/ramips/dts/UBNT-ERX-SFP.dts
@@ -102,7 +102,7 @@
        };
 };
 
-&gmac1 {
+&lan5 {
        managed = "in-band-status";
        sfp = <&sfp5>;
 };
diff --git a/target/linux/ramips/patches-4.14/2101-at803x.patch b/target/linux/ramips/patches-4.14/2101-at803x.patch
index a74b0c1b89..6f7af99617 100644
--- a/target/linux/ramips/patches-4.14/2101-at803x.patch
+++ b/target/linux/ramips/patches-4.14/2101-at803x.patch
@@ -1,5 +1,5 @@
 diff --git a/drivers/net/phy/at803x.c b/drivers/net/phy/at803x.c
-index d801c99a74ec..69d31840b24c 100644
+index d801c99a74ec..4542a17203ec 100644
 --- a/drivers/net/phy/at803x.c
 +++ b/drivers/net/phy/at803x.c
 @@ -78,6 +78,18 @@
@@ -115,7 +115,7 @@ index d801c99a74ec..69d31840b24c 100644
  		value |= AT803X_INTR_ENABLE_AUTONEG_ERR;
  		value |= AT803X_INTR_ENABLE_SPEED_CHANGED;
  		value |= AT803X_INTR_ENABLE_DUPLEX_CHANGED;
-@@ -488,36 +528,159 @@ static void at803x_link_change_notify(struct phy_device *phydev)
+@@ -488,36 +528,166 @@ static void at803x_link_change_notify(struct phy_device *phydev)
  	}
  }
  
@@ -169,9 +169,6 @@ index d801c99a74ec..69d31840b24c 100644
 +	int adv, oldadv;
 +	u32 advertise;
 +
-+	if (phydev->autoneg != AUTONEG_ENABLE)
-+		return genphy_setup_forced(phydev);
-+
 +	/* Only allow advertising what this PHY supports */
 +	phydev->advertising &= phydev->supported;
 +	advertise = phydev->advertising;
@@ -218,7 +215,9 @@ index d801c99a74ec..69d31840b24c 100644
 +
 +	return changed;
 +}
-+
+ 
+-	/* switch to SGMII/fiber page */
+-	phy_write(phydev, AT803X_REG_CHIP_CONFIG, ccr & ~AT803X_BT_BX_REG_SEL);
 +static int at803x_config_aneg(struct phy_device *phydev)
 +{
 +	int v, ret;
@@ -228,20 +227,14 @@ index d801c99a74ec..69d31840b24c 100644
 +
 +	v = phy_read(phydev, MII_BMCR);
 +	printk("at803x_config_aneg: MII_BMC: %x\n", v);
++	v &= BMCR_LOOPBACK | BMCR_ISOLATE | BMCR_PDOWN;
 +
-+#if 1
 +	if (phydev->autoneg != AUTONEG_ENABLE) {
-+		printk("at803x: genphy_setup_forced!\n");
- 
--	/* switch to SGMII/fiber page */
--	phy_write(phydev, AT803X_REG_CHIP_CONFIG, ccr & ~AT803X_BT_BX_REG_SEL);
++		printk("at803x: genphy_setup_forced! SPEED: %d, DUPLEX: %x\n", phydev->speed, phydev->duplex);
++
 +		phydev->pause = 0;
 +		phydev->asym_pause = 0;
- 
--	/* check if the SGMII link is OK. */
--	if (!(phy_read(phydev, AT803X_PSSR) & AT803X_PSSR_MR_AN_COMPLETE)) {
--		pr_warn("803x_aneg_done: SGMII link is not ok\n");
--		aneg_done = 0;
++
 +		if (SPEED_1000 == phydev->speed)
 +			v |= BMCR_SPEED1000;
 +		else if (SPEED_100 == phydev->speed)
@@ -252,28 +245,40 @@ index d801c99a74ec..69d31840b24c 100644
 +	} else {
 +		/* enable SGMII autonegotiation */
 +		v |= BIT(12) | BIT(9);
++	}
++	printk("at803x_config_aneg: MII_BMC set: %x\n", v);
++	ret = phy_write(phydev, MII_BMCR, v);
++	if (ret < 0)
++		goto error;
+ 
+-	/* check if the SGMII link is OK. */
+-	if (!(phy_read(phydev, AT803X_PSSR) & AT803X_PSSR_MR_AN_COMPLETE)) {
+-		pr_warn("803x_aneg_done: SGMII link is not ok\n");
+-		aneg_done = 0;
++	if (phydev->autoneg == AUTONEG_ENABLE) {
++		printk("at803x: marvell_config_aneg_fiber!\n");
++		ret = marvell_config_aneg_fiber(phydev);
++		if (ret < 0)
++			goto error;
  	}
 -	/* switch back to copper page */
 -	phy_write(phydev, AT803X_REG_CHIP_CONFIG, ccr | AT803X_BT_BX_REG_SEL);
-+	ret = phy_write(phydev, MII_BMCR, v);
-+#else
-+	ret = marvell_config_aneg_fiber(phydev);
-+#endif
-+
+ 
 +	v = phy_read(phydev, MII_BMCR);
++error:
 +	printk("at803x_config_aneg: MII_BMC: %x\n", v);
 +	return ret;
 +}
 +
 +static int at803x_aneg_done(struct phy_device *phydev)
 +{
-+	int ccr;
++	int ccr, v;
 +	int aneg_done = genphy_aneg_done(phydev);
 +
 +	/* Read PHY-Specific Status */
 +	ccr = phy_read(phydev, AT803X_PSSR);
 +	printk("803x_aneg_done: AT803X_PSSR: %x, %x\n", ccr, aneg_done);
- 
++
 +	/* SGMII serdes enable for fiber */
 +	if ((phy_read(phydev, AT803X_REG_CHIP_CONFIG) & 0xF) == 2) {
 +		pr_warn("803x_aneg_done: Fiber mode\n");
@@ -283,10 +288,12 @@ index d801c99a74ec..69d31840b24c 100644
 +		if (!(ccr & AT803X_PSSR_MR_AN_COMPLETE)) {
 +			pr_warn("803x_aneg_done: SGMII link is not ok\n");
 +			aneg_done = 0;
-+		} 
++		}
 +	}
 +end:
-+	pr_warn("803x_aneg_done: %x\n", aneg_done);
++	v = phy_read(phydev, MII_BMCR);
++	printk("at803x_config_aneg: MII_BMC: %x\n", v);
++	pr_warn("803x_aneg_done: %x, %x\n", aneg_done, v);
  	return aneg_done;
  }
  
@@ -294,7 +301,7 @@ index d801c99a74ec..69d31840b24c 100644
  static struct phy_driver at803x_driver[] = {
  {
  	/* ATHEROS 8035 */
-@@ -567,9 +730,9 @@ static struct phy_driver at803x_driver[] = {
+@@ -567,9 +737,9 @@ static struct phy_driver at803x_driver[] = {
  	.resume			= at803x_resume,
  	.features		= PHY_GBIT_FEATURES | SUPPORTED_FIBRE,
  	.flags			= PHY_HAS_INTERRUPT,
diff --git a/target/linux/ramips/patches-4.14/2102-mt7530.patch b/target/linux/ramips/patches-4.14/2102-mt7530.patch
index e378eb9d50..95ee19a018 100644
--- a/target/linux/ramips/patches-4.14/2102-mt7530.patch
+++ b/target/linux/ramips/patches-4.14/2102-mt7530.patch
@@ -1,71 +1,52 @@
 diff --git a/drivers/net/dsa/mt7530.c b/drivers/net/dsa/mt7530.c
-index dc48f01674ab..f3831002e3fb 100644
+index dc48f01674ab..fd3069ab4340 100644
 --- a/drivers/net/dsa/mt7530.c
 +++ b/drivers/net/dsa/mt7530.c
-@@ -1005,14 +1005,62 @@ mt7530_setup(struct dsa_switch *ds)
+@@ -1005,14 +1005,21 @@ mt7530_setup(struct dsa_switch *ds)
  	val &= ~MHWTRAP_P5_DIS & ~MHWTRAP_P6_DIS & ~MHWTRAP_PHY_ACCESS;
  	val |= MHWTRAP_MANUAL;
  
--	if (!dsa_is_cpu_port(ds, 5)) {
--		val |= MHWTRAP_P5_DIS;
 +#if 0
-+	if ( !dsa_is_normal_port(ds, 5) ) {
-+		dev_info(priv->dev, "P5 enable as ephy.\n");
+ 	if (!dsa_is_cpu_port(ds, 5)) {
+ 		val |= MHWTRAP_P5_DIS;
  		val |= MHWTRAP_P5_MAC_SEL;
--		val |= MHWTRAP_P5_RGMII_MODE;
--	};
-+		val |= MHWTRAP_P5_RGMII_MODE;	
-+	} else {
+ 		val |= MHWTRAP_P5_RGMII_MODE;
+ 	};
 +#endif
-+		/* label = dsa */
-+		if (!dsa_is_dsa_port(ds, 5)) {
-+			val |= MHWTRAP_P5_DIS;
-+			val |= MHWTRAP_P5_MAC_SEL;
-+			val |= MHWTRAP_P5_RGMII_MODE;
-+		}
++
++	// Enable P5
++	val |= MHWTRAP_P5_MAC_SEL;
++	val |= MHWTRAP_P5_RGMII_MODE;
  
  	mt7530_write(priv, MT7530_MHWTRAP, val);
  
 +#if 0
-+	if ( !dsa_is_normal_port(ds, 5) ) {
-+		dev_info(priv->dev, "P5 enabled.\n");
-+		/* (P5, link ON) */
-+		mt7530_write(priv, MT7530_PMCR_P(5), 0x7e33b);
+ 	if (!dsa_is_cpu_port(ds, 5)) {
+ 		dev_info(priv->dev, "P5 disabled.\n");
+ 		/* (P5, link OFF) */
+@@ -1030,6 +1037,25 @@ mt7530_setup(struct dsa_switch *ds)
+ 		val = CSR_RGMII_EDGE_ALIGN | CSR_RGMII_RXC_0DEG_CFG(2);
+ 		mt7530_write(priv, MT7530_P5RGMIIRXCR, val);
+ 	}
++#else
 +
-+		/* Disable GMAC 2 */
-+		regmap_write(priv->ethernet, 0x103500, 0x8000);
-+		/* GMAC 2 Mode RJ45 */
-+		regmap_read(priv->ethernet, 0x14, &val);
-+		val |= (3<14);
-+		regmap_write(priv->ethernet, 0x14, val);
-+		/* RGMII2_MODE */
-+		regmap_read(priv->ethernet, 0x60, &val);
-+		val &= ~BIT(15); // RGMII2
-+		regmap_write(priv->ethernet, 0x60, val);
++	dev_info(priv->dev, "P5 enabled.\n");
 +
-+		/* P5 RGMII TX Clock Control, delay 0 */
-+		// mt7530_write(priv, MT7530_P5RGMIITXCR, CSR_RGMII_TXC_CFG(0x10));
++	/* (P5, link OFF) */
++	mt7530_write(priv, MT7530_PMCR_P(5), PMCR_COMMON_LINK);
 +
-+		/* reduce P5 RGMII Tx driving, 8mA*/
-+		// val = P5_IO_CLK_DRV(1);
-+		// val |= P5_IO_DATA_DRV(1);
-+		// t7530_write(priv, MT7530_IO_DRV_CR, val);
++	/* P5 RGMII TX Clock Control, delay 0 */
++	mt7530_write(priv, MT7530_P5RGMIITXCR, CSR_RGMII_TXC_CFG(0x10));
 +
-+		/* P5 RGMII RX Clock Control: delay setting for 1000M */
-+		// val = CSR_RGMII_EDGE_ALIGN | CSR_RGMII_RXC_0DEG_CFG(2);
-+		// mt7530_write(priv, MT7530_P5RGMIIRXCR, val);
-+		
-+		mt7530_write(priv, 0x7b00, 0x102); // P5 RGMII RX Clock Control
-+		mt7530_write(priv, 0x7b04, 0x14); // P5 RGMII TX Clock Control, delay 4
-+		val = mt7530_read(priv, 0x7810);
-+		val &= ~3;
-+		val |= 2;
-+		
-+		mt7530_write(priv, 0x7810, val); // 12mA derive strength.
-+		
-+		
-+	} else {
++	/* reduce P5 RGMII Tx driving, 8mA*/
++	val = P5_IO_CLK_DRV(1);
++	val |= P5_IO_DATA_DRV(1);
++	mt7530_write(priv, MT7530_IO_DRV_CR, val);
++
++	/* P5 RGMII RX Clock Control: delay setting for 1000M */
++	val = CSR_RGMII_EDGE_ALIGN | CSR_RGMII_RXC_0DEG_CFG(2);
++	mt7530_write(priv, MT7530_P5RGMIIRXCR, val);
 +#endif
- 	if (!dsa_is_cpu_port(ds, 5)) {
- 		dev_info(priv->dev, "P5 disabled.\n");
- 		/* (P5, link OFF) */
+ 
+ 	/* Enable and reset MIB counters */
+ 	mt7530_mib_reset(ds);
diff --git a/target/linux/ramips/patches-4.14/2103-mtk-eth.patch b/target/linux/ramips/patches-4.14/2103-mtk-eth.patch
index bd3217c5ec..b7fe1de12d 100644
--- a/target/linux/ramips/patches-4.14/2103-mtk-eth.patch
+++ b/target/linux/ramips/patches-4.14/2103-mtk-eth.patch
@@ -1,56 +1,121 @@
 diff --git a/drivers/net/ethernet/mediatek/mtk_eth_soc.c b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-index 1debf9eeb24c..fac7082df0cb 100644
+index 1debf9eeb24c..a17c423a0e99 100644
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-@@ -1026,8 +1026,10 @@ static int mtk_poll_rx(struct napi_struct *napi, int budget,
- 		}
+@@ -372,8 +372,9 @@ static int mtk_phy_connect(struct net_device *dev)
+ 		dev->phydev->supported |=
+ 		SUPPORTED_Pause | SUPPORTED_Asym_Pause;
+ 
++	/* FIXME: Get external phy info??? */
+ 	dev->phydev->supported &= PHY_GBIT_FEATURES | SUPPORTED_Pause |
+-				   SUPPORTED_Asym_Pause;
++				   SUPPORTED_Asym_Pause | SUPPORTED_FIBRE;
+ 	dev->phydev->advertising = dev->phydev->supported |
+ 				    ADVERTISED_Autoneg;
+ 	phy_start_aneg(dev->phydev);
+@@ -1018,16 +1019,18 @@ static int mtk_poll_rx(struct napi_struct *napi, int budget,
+ 		 * we can assume that the traffic is coming from the builtin mt7530
+ 		 * and the DSA driver has loaded. FPORT will be the physical switch
+ 		 * port in this case rather than the FE forward port id. */
+-		if (!(trxd.rxd4 & RX_DMA_SP_TAG)) {
+-			/* values start at 1 */
+-			mac = (trxd.rxd4 >> RX_DMA_FPORT_SHIFT) &
+-			      RX_DMA_FPORT_MASK;
+-			mac--;
+-		}
++		mac = (trxd.rxd4 >> RX_DMA_FPORT_SHIFT) & RX_DMA_FPORT_MASK;
++		mac--;
  
  		if (unlikely(mac < 0 || mac >= MTK_MAC_COUNT ||
 -			     !eth->netdev[mac]))
 +			     !eth->netdev[mac])) {
 +			printk("mtk_poll_rx: MAC: %d, %x\n", mac, trxd.rxd4);
  			goto release_desc;
++		}
++
++		if (unlikely(mac == 1)) {
++			printk("2nd GMAC data\n");
 +		}
  
  		netdev = eth->netdev[mac];
  
-@@ -2007,6 +2009,9 @@ static int mtk_hw_init(struct mtk_eth *eth)
+@@ -1038,6 +1041,7 @@ static int mtk_poll_rx(struct napi_struct *napi, int budget,
+ 		new_data = napi_alloc_frag(ring->frag_size);
+ 		if (unlikely(!new_data)) {
+ 			netdev->stats.rx_dropped++;
++			printk("drop data %d\n", mac);
+ 			goto release_desc;
+ 		}
+ 		dma_addr = dma_map_single(eth->dev,
+@@ -1047,6 +1051,7 @@ static int mtk_poll_rx(struct napi_struct *napi, int budget,
+ 		if (unlikely(dma_mapping_error(eth->dev, dma_addr))) {
+ 			skb_free_frag(new_data);
+ 			netdev->stats.rx_dropped++;
++			printk("DMA ERR data %d\n", mac);
+ 			goto release_desc;
+ 		}
+ 
+@@ -2007,6 +2012,7 @@ static int mtk_hw_init(struct mtk_eth *eth)
  	for (i = 0; i < MTK_MAC_COUNT; i++) {
  		if (!eth->mac[i])
  			continue;
-+		else 
-+			printk("MT7621: MTK_MAC_COUNT %x, no mac!\n", i);
 +		printk("MT7621: MAC%d MODE %x, id: %x\n", i, eth->mac[i]->ge_mode, eth->mac[i]->id);
  		val &= ~SYSCFG0_GE_MODE(SYSCFG0_GE_MASK, eth->mac[i]->id);
  		val |= SYSCFG0_GE_MODE(eth->mac[i]->ge_mode, eth->mac[i]->id);
  	}
-@@ -2021,17 +2026,20 @@ static int mtk_hw_init(struct mtk_eth *eth)
+@@ -2021,17 +2027,26 @@ static int mtk_hw_init(struct mtk_eth *eth)
  
  	/* reduce RGMII1 PAD driving strength */
  	regmap_read(eth->ethsys, SYSC_PAD_RGMII2_MDIO, &val);
 -	// MDIO
 +	// MDIO driving 2mA
  	val &= ~(3 << 4);
- 	// RGMII2, 12mA
+-	// RGMII2, 12mA
 -	val &= ~(3 <<20); 
 -	val |= (2 << 20); 
-+	val &= ~(3 <<20);
-+	val |= (2 << 20);
- 	regmap_write(eth->ethsys, SYSC_PAD_RGMII2_MDIO, val);
+-	regmap_write(eth->ethsys, SYSC_PAD_RGMII2_MDIO, val);
  
 -	/* gpio mux - RGMII1&RGMII2=Normal mode, set GMAC1,2 RGMII mode  */
++	if (eth->mac[1]) {
++		// When 2nd MAC is enabled set pin strength.
++		// RGMII2, 12mA
++		val &= ~(3 <<20);
++		val |= (2 << 20);
++		regmap_write(eth->ethsys, SYSC_PAD_RGMII2_MDIO, val);
++	};
++
 +	/* set GMAC1,2 RGMII mode  */
  	regmap_read(eth->ethsys, SYSC_GPIO_MODE, &val);
 -	val &= ~(BIT(14) | BIT(15) | 3 << 12 | 3 << 14);
 +	val &= ~(3<<12); // MDIO_MODE = MDIO
-+	val &= ~(BIT(15) | BIT(14)); // RGMIIx GPIO MODE = RGMIIx
++		val &= ~(BIT(15) | BIT(14)); // RGMIIx GPIO MODE = RGMIIx
++	if (!eth->mac[1])
++		val |= BIT(15);
  	regmap_write(eth->ethsys, SYSC_GPIO_MODE, val);
 +
 +
  #else
  	if (eth->pctl) {
  		/* Set GE2 driving and slew rate */
-@@ -2212,6 +2220,8 @@ static void mtk_pending_work(struct work_struct *work)
+@@ -2084,7 +2099,7 @@ static int mtk_hw_init(struct mtk_eth *eth)
+ 	mtk_w32(eth, MTK_RX_DONE_INT, MTK_QDMA_INT_GRP2);
+ 	mtk_w32(eth, 0x21021000, MTK_FE_INT_GRP);
+ 
+-	for (i = 0; i < 2; i++) {
++	for (i = 0; i < MTK_MAC_COUNT; i++) {
+ 		u32 val = mtk_r32(eth, MTK_GDMA_FWD_CFG(i));
+ 
+ 		/* setup the forward port to send frame to PDMA */
+@@ -2093,6 +2108,8 @@ static int mtk_hw_init(struct mtk_eth *eth)
+ 		/* Enable RX checksum */
+ 		val |= MTK_GDMA_ICS_EN | MTK_GDMA_TCS_EN | MTK_GDMA_UCS_EN;
+ 
++		printk("MTK_GDMA_FWD_CFG: %d, %u\n", i, val);
++
+ 		/* setup the mac dma */
+ 		mtk_w32(eth, val, MTK_GDMA_FWD_CFG(i));
+ 	}
+@@ -2212,6 +2229,8 @@ static void mtk_pending_work(struct work_struct *work)
  	for (i = 0; i < MTK_MAC_COUNT; i++) {
  		if (!test_bit(i, &restart))
  			continue;
@@ -59,7 +124,7 @@ index 1debf9eeb24c..fac7082df0cb 100644
  		err = mtk_open(eth->netdev[i]);
  		if (err) {
  			netif_alert(eth, ifup, eth->netdev[i],
-@@ -2483,6 +2493,8 @@ static int mtk_add_mac(struct mtk_eth *eth, struct device_node *np)
+@@ -2483,6 +2502,8 @@ static int mtk_add_mac(struct mtk_eth *eth, struct device_node *np)
  	struct mtk_mac *mac;
  	const __be32 *_id = of_get_property(np, "reg", NULL);
  	int id, err;
@@ -68,7 +133,7 @@ index 1debf9eeb24c..fac7082df0cb 100644
  
  	if (!_id) {
  		dev_err(eth->dev, "missing mac id\n");
-@@ -2506,6 +2518,10 @@ static int mtk_add_mac(struct mtk_eth *eth, struct device_node *np)
+@@ -2506,6 +2527,10 @@ static int mtk_add_mac(struct mtk_eth *eth, struct device_node *np)
  		return -ENOMEM;
  	}
  	mac = netdev_priv(eth->netdev[id]);
@@ -79,7 +144,7 @@ index 1debf9eeb24c..fac7082df0cb 100644
  	eth->mac[id] = mac;
  	mac->id = id;
  	mac->hw = eth;
-@@ -2543,6 +2559,8 @@ static int mtk_add_mac(struct mtk_eth *eth, struct device_node *np)
+@@ -2543,6 +2568,8 @@ static int mtk_add_mac(struct mtk_eth *eth, struct device_node *np)
  	eth->netdev[id]->irq = eth->irq[0];
  	eth->netdev[id]->dev.of_node = np;
  
@@ -88,3 +153,11 @@ index 1debf9eeb24c..fac7082df0cb 100644
  	return 0;
  
  free_netdev:
+@@ -2578,6 +2605,7 @@ static int mtk_get_chip_id(struct mtk_eth *eth, u32 *chip_id)
+ static bool mtk_is_hwlro_supported(struct mtk_eth *eth)
+ {
+ 	switch (eth->chip_id) {
++	case MT7621_ETH:
+ 	case MT7622_ETH:
+ 	case MT7623_ETH:
+ 		return true;
-- 
2.20.1

