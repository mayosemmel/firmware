From ae1d46a57e8a235b9d11d4b1aaf5c0af9c34b955 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ren=C3=A9=20van=20Dorst?= <opensource@vdorst.com>
Date: Sun, 29 Jul 2018 23:29:59 +0200
Subject: [PATCH 5/9] Last status

---
 target/linux/ramips/dts/UBNT-ER-e50.dtsi      |   2 +-
 .../ramips/patches-4.14/2101-at803x.patch     | 189 ++++++++++++++----
 .../ramips/patches-4.14/2103-mtk-eth.patch    |   9 +-
 3 files changed, 155 insertions(+), 45 deletions(-)

diff --git a/target/linux/ramips/dts/UBNT-ER-e50.dtsi b/target/linux/ramips/dts/UBNT-ER-e50.dtsi
index a939fb20b3..d76e1418b0 100644
--- a/target/linux/ramips/dts/UBNT-ER-e50.dtsi
+++ b/target/linux/ramips/dts/UBNT-ER-e50.dtsi
@@ -89,7 +89,7 @@
 		#size-cells = <0>;
 		ephy5: ethernet-phy@7 {
 			reg = <7>;
-			phy-mode = "rgmii-rxid";
+			phy-mode = "rgmii";
 		};
 	};
 };
diff --git a/target/linux/ramips/patches-4.14/2101-at803x.patch b/target/linux/ramips/patches-4.14/2101-at803x.patch
index df30c242c7..a74b0c1b89 100644
--- a/target/linux/ramips/patches-4.14/2101-at803x.patch
+++ b/target/linux/ramips/patches-4.14/2101-at803x.patch
@@ -1,5 +1,5 @@
 diff --git a/drivers/net/phy/at803x.c b/drivers/net/phy/at803x.c
-index d801c99a74ec..382c8c558c00 100644
+index d801c99a74ec..69d31840b24c 100644
 --- a/drivers/net/phy/at803x.c
 +++ b/drivers/net/phy/at803x.c
 @@ -78,6 +78,18 @@
@@ -21,7 +21,7 @@ index d801c99a74ec..382c8c558c00 100644
  MODULE_DESCRIPTION("Atheros 803x PHY driver");
  MODULE_AUTHOR("Matus Ujhelyi");
  MODULE_LICENSE("GPL");
-@@ -343,24 +355,36 @@ static int at803x_config_init(struct phy_device *phydev)
+@@ -343,35 +355,49 @@ static int at803x_config_init(struct phy_device *phydev)
  	int ret;
  	u32 v;
  
@@ -63,11 +63,51 @@ index d801c99a74ec..382c8c558c00 100644
  			return ret;
 +
 +		phydev->supported |= SUPPORTED_FIBRE;
-+		phydev->advertising |= SUPPORTED_FIBRE;
  	}
  
  	ret = genphy_config_init(phydev);
-@@ -421,6 +445,7 @@ static int at803x_config_intr(struct phy_device *phydev)
+ 	if (ret < 0)
+ 		return ret;
+ 
++	phydev->advertising |= SUPPORTED_FIBRE;
++
+ 	if (phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID ||
+ 			phydev->interface == PHY_INTERFACE_MODE_RGMII_ID) {
+ 		ret = at803x_enable_rx_delay(phydev);
+ 		if (ret < 0)
+ 			return ret;
++		printk("at803x_config_init: enable_rx_delay\n");
+ 	}
+ 
+ 	if (phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID ||
+@@ -379,6 +405,7 @@ static int at803x_config_init(struct phy_device *phydev)
+ 		ret = at803x_enable_tx_delay(phydev);
+ 		if (ret < 0)
+ 			return ret;
++		printk("at803x_config_init: enable_tx_delay\n");
+ 	}
+ 
+ 	pdata = dev_get_platdata(&phydev->mdio.dev);
+@@ -401,6 +428,18 @@ static int at803x_config_init(struct phy_device *phydev)
+ 				AT803X_DEBUG_TX_CLK_DLY_EN, 0);
+ 	}
+ 
++#if 0 // Loopback test
++	v = phy_read(phydev, AT803X_REG_CHIP_CONFIG);
++	printk("at803x_config_init_2: Force loopback test: %x\n", v);
++	v |= BIT(14);
++	ret = phy_write(phydev, MII_BMCR, v);
++
++	v = phy_read(phydev, AT803X_REG_CHIP_CONFIG);
++	ret = phy_write(phydev, AT803X_REG_CHIP_CONFIG, v | AT803X_BT_BX_REG_SEL);
++	if (ret)
++		return ret;
++#endif
++
+ 	return 0;
+ }
+ 
+@@ -421,6 +460,7 @@ static int at803x_config_intr(struct phy_device *phydev)
  	value = phy_read(phydev, AT803X_INTR_ENABLE);
  
  	if (phydev->interrupts == PHY_INTERRUPT_ENABLED) {
@@ -75,10 +115,11 @@ index d801c99a74ec..382c8c558c00 100644
  		value |= AT803X_INTR_ENABLE_AUTONEG_ERR;
  		value |= AT803X_INTR_ENABLE_SPEED_CHANGED;
  		value |= AT803X_INTR_ENABLE_DUPLEX_CHANGED;
-@@ -488,36 +513,92 @@ static void at803x_link_change_notify(struct phy_device *phydev)
+@@ -488,36 +528,159 @@ static void at803x_link_change_notify(struct phy_device *phydev)
  	}
  }
  
+-static int at803x_aneg_done(struct phy_device *phydev)
 +/**
 + * ethtool_adv_to_fiber_adv_t
 + * @ethadv: the ethtool advertisement settings
@@ -88,14 +129,21 @@ index d801c99a74ec..382c8c558c00 100644
 + * MII_ADV register for fiber link.
 + */
 +static inline u32 ethtool_adv_to_fiber_adv_t(u32 ethadv)
-+{
+ {
+-	int ccr;
 +	u32 result = 0;
-+
+ 
+-	int aneg_done = genphy_aneg_done(phydev);
+-	if (aneg_done != BMSR_ANEGCOMPLETE)
+-		return aneg_done;
 +	if (ethadv & ADVERTISED_1000baseT_Half)
 +		result |= ADVERTISE_FIBER_1000HALF;
 +	if (ethadv & ADVERTISED_1000baseT_Full)
 +		result |= ADVERTISE_FIBER_1000FULL;
-+
+ 
+-	/*
+-	 * in SGMII mode, if copper side autoneg is successful,
+-	 * also check SGMII side autoneg result
 +	if ((ethadv & ADVERTISE_PAUSE_ASYM) && (ethadv & ADVERTISE_PAUSE_CAP))
 +		result |= LPA_PAUSE_ASYM_FIBER;
 +	else if (ethadv & ADVERTISE_PAUSE_CAP)
@@ -105,6 +153,72 @@ index d801c99a74ec..382c8c558c00 100644
 +	return result;
 +}
 +
++/**
++ * marvell_config_aneg_fiber - restart auto-negotiation or write BMCR
++ * @phydev: target phy_device struct
++ *
++ * Description: If auto-negotiation is enabled, we configure the
++ *   advertising, and then restart auto-negotiation.  If it is not
++ *   enabled, then we write the BMCR. Adapted for fiber link in
++ *   some Marvell's devices.
++ */
++static int marvell_config_aneg_fiber(struct phy_device *phydev)
++{
++	int changed = 0;
++	int err;
++	int adv, oldadv;
++	u32 advertise;
++
++	if (phydev->autoneg != AUTONEG_ENABLE)
++		return genphy_setup_forced(phydev);
++
++	/* Only allow advertising what this PHY supports */
++	phydev->advertising &= phydev->supported;
++	advertise = phydev->advertising;
++
++	/* Setup fiber advertisement */
++	adv = phy_read(phydev, MII_ADVERTISE);
++	if (adv < 0)
++		return adv;
++
++	oldadv = adv;
++	adv &= ~(ADVERTISE_FIBER_1000HALF | ADVERTISE_FIBER_1000FULL
++		| LPA_PAUSE_FIBER);
++	adv |= ethtool_adv_to_fiber_adv_t(advertise);
++
++	if (adv != oldadv) {
++		err = phy_write(phydev, MII_ADVERTISE, adv);
++		if (err < 0)
++			return err;
++
++		changed = 1;
++	}
++
++	if (changed == 0) {
++		/* Advertisement hasn't changed, but maybe aneg was never on to
++		 * begin with?	Or maybe phy was isolated?
++		 */
++		int ctl = phy_read(phydev, MII_BMCR);
++
++		if (ctl < 0)
++			return ctl;
++
++		if (!(ctl & BMCR_ANENABLE) || (ctl & BMCR_ISOLATE))
++			changed = 1; /* do restart aneg */
++	}
++
++	/* Only restart aneg if we are advertising something different
++	 * than we were before.
+ 	 */
+-	ccr = phy_read(phydev, AT803X_REG_CHIP_CONFIG);
+-	if ((ccr & AT803X_MODE_CFG_MASK) != AT803X_MODE_CFG_SGMII)
+-		return aneg_done;
++	if (changed > 0)
++		changed = genphy_restart_aneg(phydev);
++
++	return changed;
++}
++
 +static int at803x_config_aneg(struct phy_device *phydev)
 +{
 +	int v, ret;
@@ -114,15 +228,20 @@ index d801c99a74ec..382c8c558c00 100644
 +
 +	v = phy_read(phydev, MII_BMCR);
 +	printk("at803x_config_aneg: MII_BMC: %x\n", v);
-+	v &= BMCR_LOOPBACK | BMCR_ISOLATE | BMCR_PDOWN;
 +
++#if 1
 +	if (phydev->autoneg != AUTONEG_ENABLE) {
 +		printk("at803x: genphy_setup_forced!\n");
-+		
-+
+ 
+-	/* switch to SGMII/fiber page */
+-	phy_write(phydev, AT803X_REG_CHIP_CONFIG, ccr & ~AT803X_BT_BX_REG_SEL);
 +		phydev->pause = 0;
 +		phydev->asym_pause = 0;
-+
+ 
+-	/* check if the SGMII link is OK. */
+-	if (!(phy_read(phydev, AT803X_PSSR) & AT803X_PSSR_MR_AN_COMPLETE)) {
+-		pr_warn("803x_aneg_done: SGMII link is not ok\n");
+-		aneg_done = 0;
 +		if (SPEED_1000 == phydev->speed)
 +			v |= BMCR_SPEED1000;
 +		else if (SPEED_100 == phydev->speed)
@@ -133,51 +252,39 @@ index d801c99a74ec..382c8c558c00 100644
 +	} else {
 +		/* enable SGMII autonegotiation */
 +		v |= BIT(12) | BIT(9);
-+	}
-+	printk("at803x_config_aneg: MII_BMC: %x\n", v);
+ 	}
+-	/* switch back to copper page */
+-	phy_write(phydev, AT803X_REG_CHIP_CONFIG, ccr | AT803X_BT_BX_REG_SEL);
 +	ret = phy_write(phydev, MII_BMCR, v);
++#else
++	ret = marvell_config_aneg_fiber(phydev);
++#endif
++
++	v = phy_read(phydev, MII_BMCR);
++	printk("at803x_config_aneg: MII_BMC: %x\n", v);
 +	return ret;
 +}
 +
- static int at803x_aneg_done(struct phy_device *phydev)
- {
- 	int ccr;
--
- 	int aneg_done = genphy_aneg_done(phydev);
--	if (aneg_done != BMSR_ANEGCOMPLETE)
--		return aneg_done;
- 
--	/*
--	 * in SGMII mode, if copper side autoneg is successful,
--	 * also check SGMII side autoneg result
--	 */
--	ccr = phy_read(phydev, AT803X_REG_CHIP_CONFIG);
--	if ((ccr & AT803X_MODE_CFG_MASK) != AT803X_MODE_CFG_SGMII)
--		return aneg_done;
++static int at803x_aneg_done(struct phy_device *phydev)
++{
++	int ccr;
++	int aneg_done = genphy_aneg_done(phydev);
++
 +	/* Read PHY-Specific Status */
 +	ccr = phy_read(phydev, AT803X_PSSR);
 +	printk("803x_aneg_done: AT803X_PSSR: %x, %x\n", ccr, aneg_done);
  
--	/* switch to SGMII/fiber page */
--	phy_write(phydev, AT803X_REG_CHIP_CONFIG, ccr & ~AT803X_BT_BX_REG_SEL);
 +	/* SGMII serdes enable for fiber */
 +	if ((phy_read(phydev, AT803X_REG_CHIP_CONFIG) & 0xF) == 2) {
 +		pr_warn("803x_aneg_done: Fiber mode\n");
- 
--	/* check if the SGMII link is OK. */
--	if (!(phy_read(phydev, AT803X_PSSR) & AT803X_PSSR_MR_AN_COMPLETE)) {
--		pr_warn("803x_aneg_done: SGMII link is not ok\n");
--		aneg_done = 0;
++
 +		ccr = phy_read(phydev, AT803X_PSSR);
 +		/* check if the SGMII link is OK. */
 +		if (!(ccr & AT803X_PSSR_MR_AN_COMPLETE)) {
 +			pr_warn("803x_aneg_done: SGMII link is not ok\n");
 +			aneg_done = 0;
 +		} 
- 	}
--	/* switch back to copper page */
--	phy_write(phydev, AT803X_REG_CHIP_CONFIG, ccr | AT803X_BT_BX_REG_SEL);
--
++	}
 +end:
 +	pr_warn("803x_aneg_done: %x\n", aneg_done);
  	return aneg_done;
@@ -187,7 +294,7 @@ index d801c99a74ec..382c8c558c00 100644
  static struct phy_driver at803x_driver[] = {
  {
  	/* ATHEROS 8035 */
-@@ -567,9 +648,9 @@ static struct phy_driver at803x_driver[] = {
+@@ -567,9 +730,9 @@ static struct phy_driver at803x_driver[] = {
  	.resume			= at803x_resume,
  	.features		= PHY_GBIT_FEATURES | SUPPORTED_FIBRE,
  	.flags			= PHY_HAS_INTERRUPT,
diff --git a/target/linux/ramips/patches-4.14/2103-mtk-eth.patch b/target/linux/ramips/patches-4.14/2103-mtk-eth.patch
index 452f21771d..b1c9e2e5ec 100644
--- a/target/linux/ramips/patches-4.14/2103-mtk-eth.patch
+++ b/target/linux/ramips/patches-4.14/2103-mtk-eth.patch
@@ -1,16 +1,19 @@
 diff --git a/drivers/net/ethernet/mediatek/mtk_eth_soc.c b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-index 1debf9eeb24c..1eded7f5ec17 100644
+index 1debf9eeb24c..3af9627f040b 100644
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-@@ -2007,6 +2007,7 @@ static int mtk_hw_init(struct mtk_eth *eth)
+@@ -2005,8 +2005,10 @@ static int mtk_hw_init(struct mtk_eth *eth)
+ 
+ 	regmap_read(eth->ethsys, ETHSYS_SYSCFG0, &val);
  	for (i = 0; i < MTK_MAC_COUNT; i++) {
++		printk("MT7621: MTK_MAC_COUNT %x\n", i);
  		if (!eth->mac[i])
  			continue;
 +		printk("MT7621: MAC%d MODE %x, id: %x\n", i, eth->mac[i]->ge_mode, eth->mac[i]->id);
  		val &= ~SYSCFG0_GE_MODE(SYSCFG0_GE_MASK, eth->mac[i]->id);
  		val |= SYSCFG0_GE_MODE(eth->mac[i]->ge_mode, eth->mac[i]->id);
  	}
-@@ -2021,17 +2022,20 @@ static int mtk_hw_init(struct mtk_eth *eth)
+@@ -2021,17 +2023,20 @@ static int mtk_hw_init(struct mtk_eth *eth)
  
  	/* reduce RGMII1 PAD driving strength */
  	regmap_read(eth->ethsys, SYSC_PAD_RGMII2_MDIO, &val);
-- 
2.20.1

