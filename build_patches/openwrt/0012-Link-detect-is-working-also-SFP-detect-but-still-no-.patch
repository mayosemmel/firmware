From b73d0d2041f2fadee2b73d3aef9bcec3cb832820 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ren=C3=A9=20van=20Dorst?= <opensource@vdorst.com>
Date: Sun, 29 Jul 2018 22:03:58 +0200
Subject: [PATCH 4/9] Link detect is working, also SFP detect, but still no
 data output.

---
 target/linux/ramips/dts/UBNT-ER-e50.dtsi      |   2 +-
 target/linux/ramips/dts/UBNT-ERX-SFP.dts      |   1 -
 .../ramips/patches-4.14/2101-at803x.patch     | 200 ++++++++++++++++++
 .../ramips/patches-4.14/2102-mt7530.patch     |  71 +++++++
 .../ramips/patches-4.14/2103-mtk-eth.patch    |  38 ++++
 5 files changed, 310 insertions(+), 2 deletions(-)
 create mode 100644 target/linux/ramips/patches-4.14/2101-at803x.patch
 create mode 100644 target/linux/ramips/patches-4.14/2102-mt7530.patch
 create mode 100644 target/linux/ramips/patches-4.14/2103-mtk-eth.patch

diff --git a/target/linux/ramips/dts/UBNT-ER-e50.dtsi b/target/linux/ramips/dts/UBNT-ER-e50.dtsi
index d76e1418b0..a939fb20b3 100644
--- a/target/linux/ramips/dts/UBNT-ER-e50.dtsi
+++ b/target/linux/ramips/dts/UBNT-ER-e50.dtsi
@@ -89,7 +89,7 @@
 		#size-cells = <0>;
 		ephy5: ethernet-phy@7 {
 			reg = <7>;
-			phy-mode = "rgmii";
+			phy-mode = "rgmii-rxid";
 		};
 	};
 };
diff --git a/target/linux/ramips/dts/UBNT-ERX-SFP.dts b/target/linux/ramips/dts/UBNT-ERX-SFP.dts
index a633d8bedd..33ccfaf34b 100644
--- a/target/linux/ramips/dts/UBNT-ERX-SFP.dts
+++ b/target/linux/ramips/dts/UBNT-ERX-SFP.dts
@@ -102,7 +102,6 @@
        };
 };
 
-
 &gmac1 {
        managed = "in-band-status";
        sfp = <&sfp5>;
diff --git a/target/linux/ramips/patches-4.14/2101-at803x.patch b/target/linux/ramips/patches-4.14/2101-at803x.patch
new file mode 100644
index 0000000000..df30c242c7
--- /dev/null
+++ b/target/linux/ramips/patches-4.14/2101-at803x.patch
@@ -0,0 +1,200 @@
+diff --git a/drivers/net/phy/at803x.c b/drivers/net/phy/at803x.c
+index d801c99a74ec..382c8c558c00 100644
+--- a/drivers/net/phy/at803x.c
++++ b/drivers/net/phy/at803x.c
+@@ -78,6 +78,18 @@
+ #define AT803X_PHY_ID_MASK			0xffffffef
+ #define AT8032_PHY_ID_MASK			0xffffffff
+ 
++#define ADVERTISE_FIBER_1000HALF	0x40
++#define ADVERTISE_FIBER_1000FULL	0x20
++
++#define ADVERTISE_PAUSE_FIBER		0x180
++#define ADVERTISE_PAUSE_ASYM_FIBER	0x100
++
++#define LPA_FIBER_1000HALF	0x40
++#define LPA_FIBER_1000FULL	0x20
++
++#define LPA_PAUSE_FIBER		0x180
++#define LPA_PAUSE_ASYM_FIBER	0x100
++
+ MODULE_DESCRIPTION("Atheros 803x PHY driver");
+ MODULE_AUTHOR("Matus Ujhelyi");
+ MODULE_LICENSE("GPL");
+@@ -343,24 +355,36 @@ static int at803x_config_init(struct phy_device *phydev)
+ 	int ret;
+ 	u32 v;
+ 
+-	if (phydev->drv->phy_id == ATH8031_PHY_ID &&
+-		phydev->interface == PHY_INTERFACE_MODE_SGMII)
++	v = phy_read(phydev, AT803X_REG_CHIP_CONFIG);
++	printk("at803x_config_init: CHIP: %x\n", v);
++
++	/* reset device */
++	ret = genphy_soft_reset(phydev);
++	if (ret < 0)
++		return ret;
++
++	v = phy_read(phydev, AT803X_REG_CHIP_CONFIG);
++	printk("at803x_config_init_2: CHIP: %x\n", v);
++
++	if ( (v & 0xf) == 2 )
+ 	{
+-		v = phy_read(phydev, AT803X_REG_CHIP_CONFIG);
++		printk("at803x_config_init: fibre mode\n");
++
+ 		/* select SGMII/fiber page */
+ 		ret = phy_write(phydev, AT803X_REG_CHIP_CONFIG,
+ 						v & ~AT803X_BT_BX_REG_SEL);
+ 		if (ret)
+ 			return ret;
++
++		v = phy_read(phydev, MII_BMCR);
++		printk("at803x_config_init: MII_BMCR: %x\n", v);
+ 		/* enable SGMII autonegotiation */
+-		ret = phy_write(phydev, MII_BMCR, AT803X_SGMII_ANEG_EN);
+-		if (ret)
+-			return ret;
+-		/* select copper page */
+-		ret = phy_write(phydev, AT803X_REG_CHIP_CONFIG,
+-						v | AT803X_BT_BX_REG_SEL);
++		ret = phy_write(phydev, MII_BMCR, v | AT803X_SGMII_ANEG_EN | BIT(9) );
+ 		if (ret)
+ 			return ret;
++
++		phydev->supported |= SUPPORTED_FIBRE;
++		phydev->advertising |= SUPPORTED_FIBRE;
+ 	}
+ 
+ 	ret = genphy_config_init(phydev);
+@@ -421,6 +445,7 @@ static int at803x_config_intr(struct phy_device *phydev)
+ 	value = phy_read(phydev, AT803X_INTR_ENABLE);
+ 
+ 	if (phydev->interrupts == PHY_INTERRUPT_ENABLED) {
++		printk("at803x_config_intr: PHY_INTERRUPT_ENABLED\n");
+ 		value |= AT803X_INTR_ENABLE_AUTONEG_ERR;
+ 		value |= AT803X_INTR_ENABLE_SPEED_CHANGED;
+ 		value |= AT803X_INTR_ENABLE_DUPLEX_CHANGED;
+@@ -488,36 +513,92 @@ static void at803x_link_change_notify(struct phy_device *phydev)
+ 	}
+ }
+ 
++/**
++ * ethtool_adv_to_fiber_adv_t
++ * @ethadv: the ethtool advertisement settings
++ *
++ * A small helper function that translates ethtool advertisement
++ * settings to phy autonegotiation advertisements for the
++ * MII_ADV register for fiber link.
++ */
++static inline u32 ethtool_adv_to_fiber_adv_t(u32 ethadv)
++{
++	u32 result = 0;
++
++	if (ethadv & ADVERTISED_1000baseT_Half)
++		result |= ADVERTISE_FIBER_1000HALF;
++	if (ethadv & ADVERTISED_1000baseT_Full)
++		result |= ADVERTISE_FIBER_1000FULL;
++
++	if ((ethadv & ADVERTISE_PAUSE_ASYM) && (ethadv & ADVERTISE_PAUSE_CAP))
++		result |= LPA_PAUSE_ASYM_FIBER;
++	else if (ethadv & ADVERTISE_PAUSE_CAP)
++		result |= (ADVERTISE_PAUSE_FIBER
++			   & (~ADVERTISE_PAUSE_ASYM_FIBER));
++
++	return result;
++}
++
++static int at803x_config_aneg(struct phy_device *phydev)
++{
++	int v, ret;
++
++	v = phy_read(phydev, AT803X_REG_CHIP_CONFIG);
++	printk("at803x_config_aneg: CHIP: %x\n", v);
++
++	v = phy_read(phydev, MII_BMCR);
++	printk("at803x_config_aneg: MII_BMC: %x\n", v);
++	v &= BMCR_LOOPBACK | BMCR_ISOLATE | BMCR_PDOWN;
++
++	if (phydev->autoneg != AUTONEG_ENABLE) {
++		printk("at803x: genphy_setup_forced!\n");
++		
++
++		phydev->pause = 0;
++		phydev->asym_pause = 0;
++
++		if (SPEED_1000 == phydev->speed)
++			v |= BMCR_SPEED1000;
++		else if (SPEED_100 == phydev->speed)
++			v |= BMCR_SPEED100;
++
++		if (DUPLEX_FULL == phydev->duplex)
++			v |= BMCR_FULLDPLX;
++	} else {
++		/* enable SGMII autonegotiation */
++		v |= BIT(12) | BIT(9);
++	}
++	printk("at803x_config_aneg: MII_BMC: %x\n", v);
++	ret = phy_write(phydev, MII_BMCR, v);
++	return ret;
++}
++
+ static int at803x_aneg_done(struct phy_device *phydev)
+ {
+ 	int ccr;
+-
+ 	int aneg_done = genphy_aneg_done(phydev);
+-	if (aneg_done != BMSR_ANEGCOMPLETE)
+-		return aneg_done;
+ 
+-	/*
+-	 * in SGMII mode, if copper side autoneg is successful,
+-	 * also check SGMII side autoneg result
+-	 */
+-	ccr = phy_read(phydev, AT803X_REG_CHIP_CONFIG);
+-	if ((ccr & AT803X_MODE_CFG_MASK) != AT803X_MODE_CFG_SGMII)
+-		return aneg_done;
++	/* Read PHY-Specific Status */
++	ccr = phy_read(phydev, AT803X_PSSR);
++	printk("803x_aneg_done: AT803X_PSSR: %x, %x\n", ccr, aneg_done);
+ 
+-	/* switch to SGMII/fiber page */
+-	phy_write(phydev, AT803X_REG_CHIP_CONFIG, ccr & ~AT803X_BT_BX_REG_SEL);
++	/* SGMII serdes enable for fiber */
++	if ((phy_read(phydev, AT803X_REG_CHIP_CONFIG) & 0xF) == 2) {
++		pr_warn("803x_aneg_done: Fiber mode\n");
+ 
+-	/* check if the SGMII link is OK. */
+-	if (!(phy_read(phydev, AT803X_PSSR) & AT803X_PSSR_MR_AN_COMPLETE)) {
+-		pr_warn("803x_aneg_done: SGMII link is not ok\n");
+-		aneg_done = 0;
++		ccr = phy_read(phydev, AT803X_PSSR);
++		/* check if the SGMII link is OK. */
++		if (!(ccr & AT803X_PSSR_MR_AN_COMPLETE)) {
++			pr_warn("803x_aneg_done: SGMII link is not ok\n");
++			aneg_done = 0;
++		} 
+ 	}
+-	/* switch back to copper page */
+-	phy_write(phydev, AT803X_REG_CHIP_CONFIG, ccr | AT803X_BT_BX_REG_SEL);
+-
++end:
++	pr_warn("803x_aneg_done: %x\n", aneg_done);
+ 	return aneg_done;
+ }
+ 
++
+ static struct phy_driver at803x_driver[] = {
+ {
+ 	/* ATHEROS 8035 */
+@@ -567,9 +648,9 @@ static struct phy_driver at803x_driver[] = {
+ 	.resume			= at803x_resume,
+ 	.features		= PHY_GBIT_FEATURES | SUPPORTED_FIBRE,
+ 	.flags			= PHY_HAS_INTERRUPT,
+-	.config_aneg		= genphy_config_aneg,
+ 	.read_status		= genphy_read_status,
+ 	.aneg_done		= at803x_aneg_done,
++	.config_aneg		= at803x_config_aneg,
+ 	.ack_interrupt		= at803x_ack_interrupt,
+ 	.config_intr		= at803x_config_intr,
+ 	.set_loopback		= genphy_loopback,
diff --git a/target/linux/ramips/patches-4.14/2102-mt7530.patch b/target/linux/ramips/patches-4.14/2102-mt7530.patch
new file mode 100644
index 0000000000..e378eb9d50
--- /dev/null
+++ b/target/linux/ramips/patches-4.14/2102-mt7530.patch
@@ -0,0 +1,71 @@
+diff --git a/drivers/net/dsa/mt7530.c b/drivers/net/dsa/mt7530.c
+index dc48f01674ab..f3831002e3fb 100644
+--- a/drivers/net/dsa/mt7530.c
++++ b/drivers/net/dsa/mt7530.c
+@@ -1005,14 +1005,62 @@ mt7530_setup(struct dsa_switch *ds)
+ 	val &= ~MHWTRAP_P5_DIS & ~MHWTRAP_P6_DIS & ~MHWTRAP_PHY_ACCESS;
+ 	val |= MHWTRAP_MANUAL;
+ 
+-	if (!dsa_is_cpu_port(ds, 5)) {
+-		val |= MHWTRAP_P5_DIS;
++#if 0
++	if ( !dsa_is_normal_port(ds, 5) ) {
++		dev_info(priv->dev, "P5 enable as ephy.\n");
+ 		val |= MHWTRAP_P5_MAC_SEL;
+-		val |= MHWTRAP_P5_RGMII_MODE;
+-	};
++		val |= MHWTRAP_P5_RGMII_MODE;	
++	} else {
++#endif
++		/* label = dsa */
++		if (!dsa_is_dsa_port(ds, 5)) {
++			val |= MHWTRAP_P5_DIS;
++			val |= MHWTRAP_P5_MAC_SEL;
++			val |= MHWTRAP_P5_RGMII_MODE;
++		}
+ 
+ 	mt7530_write(priv, MT7530_MHWTRAP, val);
+ 
++#if 0
++	if ( !dsa_is_normal_port(ds, 5) ) {
++		dev_info(priv->dev, "P5 enabled.\n");
++		/* (P5, link ON) */
++		mt7530_write(priv, MT7530_PMCR_P(5), 0x7e33b);
++
++		/* Disable GMAC 2 */
++		regmap_write(priv->ethernet, 0x103500, 0x8000);
++		/* GMAC 2 Mode RJ45 */
++		regmap_read(priv->ethernet, 0x14, &val);
++		val |= (3<14);
++		regmap_write(priv->ethernet, 0x14, val);
++		/* RGMII2_MODE */
++		regmap_read(priv->ethernet, 0x60, &val);
++		val &= ~BIT(15); // RGMII2
++		regmap_write(priv->ethernet, 0x60, val);
++
++		/* P5 RGMII TX Clock Control, delay 0 */
++		// mt7530_write(priv, MT7530_P5RGMIITXCR, CSR_RGMII_TXC_CFG(0x10));
++
++		/* reduce P5 RGMII Tx driving, 8mA*/
++		// val = P5_IO_CLK_DRV(1);
++		// val |= P5_IO_DATA_DRV(1);
++		// t7530_write(priv, MT7530_IO_DRV_CR, val);
++
++		/* P5 RGMII RX Clock Control: delay setting for 1000M */
++		// val = CSR_RGMII_EDGE_ALIGN | CSR_RGMII_RXC_0DEG_CFG(2);
++		// mt7530_write(priv, MT7530_P5RGMIIRXCR, val);
++		
++		mt7530_write(priv, 0x7b00, 0x102); // P5 RGMII RX Clock Control
++		mt7530_write(priv, 0x7b04, 0x14); // P5 RGMII TX Clock Control, delay 4
++		val = mt7530_read(priv, 0x7810);
++		val &= ~3;
++		val |= 2;
++		
++		mt7530_write(priv, 0x7810, val); // 12mA derive strength.
++		
++		
++	} else {
++#endif
+ 	if (!dsa_is_cpu_port(ds, 5)) {
+ 		dev_info(priv->dev, "P5 disabled.\n");
+ 		/* (P5, link OFF) */
diff --git a/target/linux/ramips/patches-4.14/2103-mtk-eth.patch b/target/linux/ramips/patches-4.14/2103-mtk-eth.patch
new file mode 100644
index 0000000000..452f21771d
--- /dev/null
+++ b/target/linux/ramips/patches-4.14/2103-mtk-eth.patch
@@ -0,0 +1,38 @@
+diff --git a/drivers/net/ethernet/mediatek/mtk_eth_soc.c b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+index 1debf9eeb24c..1eded7f5ec17 100644
+--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
++++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+@@ -2007,6 +2007,7 @@ static int mtk_hw_init(struct mtk_eth *eth)
+ 	for (i = 0; i < MTK_MAC_COUNT; i++) {
+ 		if (!eth->mac[i])
+ 			continue;
++		printk("MT7621: MAC%d MODE %x, id: %x\n", i, eth->mac[i]->ge_mode, eth->mac[i]->id);
+ 		val &= ~SYSCFG0_GE_MODE(SYSCFG0_GE_MASK, eth->mac[i]->id);
+ 		val |= SYSCFG0_GE_MODE(eth->mac[i]->ge_mode, eth->mac[i]->id);
+ 	}
+@@ -2021,17 +2022,20 @@ static int mtk_hw_init(struct mtk_eth *eth)
+ 
+ 	/* reduce RGMII1 PAD driving strength */
+ 	regmap_read(eth->ethsys, SYSC_PAD_RGMII2_MDIO, &val);
+-	// MDIO
++	// MDIO driving 2mA
+ 	val &= ~(3 << 4);
+ 	// RGMII2, 12mA
+-	val &= ~(3 <<20); 
+-	val |= (2 << 20); 
++	val &= ~(3 <<20);
++	val |= (2 << 20);
+ 	regmap_write(eth->ethsys, SYSC_PAD_RGMII2_MDIO, val);
+ 
+-	/* gpio mux - RGMII1&RGMII2=Normal mode, set GMAC1,2 RGMII mode  */
++	/* set GMAC1,2 RGMII mode  */
+ 	regmap_read(eth->ethsys, SYSC_GPIO_MODE, &val);
+-	val &= ~(BIT(14) | BIT(15) | 3 << 12 | 3 << 14);
++	val &= ~(3<<12); // MDIO_MODE = MDIO
++	val &= ~(BIT(15) | BIT(14)); // RGMIIx GPIO MODE = RGMIIx
+ 	regmap_write(eth->ethsys, SYSC_GPIO_MODE, val);
++
++
+ #else
+ 	if (eth->pctl) {
+ 		/* Set GE2 driving and slew rate */
-- 
2.20.1

